---
category: 微前端
order: 19
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/article/前端面试题合集/read.html">
</nav-head>


# 微前端

## 什么是微前端?

微前端是将大型前端应用拆解为独立模块的架构模式，支持独立开发、部署与技术栈异构。
微前端通过将复杂应用拆分为多个小型子应用（如按业务模块划分），每个子应用可独立开发、测试、部署，并通过运行时集成（如模块联邦、iframe、Web Components）组合成完整应用。优势包括团队协作解耦、技术栈灵活、渐进升级能力，适合多团队维护的中后台系统或遗留项目重构。

## 实现微前端有哪些技术方案？

微前端实现方案包括**运行时集成**、**构建时组合**、**Web Components**、**模块联邦**等多种技术手段，核心在于独立开发与动态聚合。

1. **运行时集成**
   - **框架型**：如 `single-spa`、`Qiankun`，主应用通过路由动态加载子应用，沙箱隔离资源。
   - **iframe**：天然隔离但通信复杂，体验割裂。
2. **构建时组合**
   - **模块联邦**（Webpack 5）：跨应用共享代码，依赖预构建，适合技术栈统一的项目。
3. **原生隔离**
   - **Web Components**：通过 Shadow DOM 和 Custom Elements 实现组件级隔离，但生态较弱。
4. **服务端聚合**
   - **SSI/Nginx**：服务端拼接 HTML 片段，简单但灵活性低。

**选型关键**：根据团队规模、技术栈差异、隔离需求（如 CSS/JS 冲突）和部署复杂度综合权衡。

## 微前端架构一般是如何做Js隔离的？

微前端通过**JS沙箱**技术（如Proxy代理、快照隔离）限制子应用全局副作用，实现JS执行环境的隔离。



1. **单例沙箱**（Legacy Sandbox）：
   - 通过重写 `window` 对象的属性存取（如`Proxy`），记录子应用修改的全局变量，卸载时恢复原始状态。
   - 适用场景：单页面同时仅运行一个子应用。
2. **多例沙箱**（Proxy Sandbox）：
   - 为每个子应用创建独立的`Proxy`代理对象，子应用操作全局变量实际指向沙箱内的虚拟环境，互不影响。
   - 优势：支持多子应用并行运行。
3. **快照沙箱**（Snapshot Sandbox）：
   - 子应用加载前保存全局对象快照，卸载时还原，通过`diff`恢复变更（兼容低版本浏览器，但无法多实例并行）。

**其他方案**：

- **iframe**：天然JS隔离，但通信成本高；
- **Web Workers**：独立线程运行JS，但无法直接操作DOM。

**核心目标**：避免全局变量污染（如`window`、`document`）、事件冲突，确保子应用独立销毁与加载。

## 微前端可以解决什么问题？

微前端主要解决**巨石应用维护难、技术栈升级难、团队协作效率低**的问题，实现复杂系统的解耦与渐进式演进。

1. **拆分巨石应用**：将庞大单体前端按业务模块拆分为独立子应用，降低代码耦合，提升可维护性；
2. **独立开发部署**：不同团队可独立开发、测试、部署子应用，避免协作阻塞，加快交付效率；
3. **技术栈异构**：允许子应用使用不同框架（如 Vue/React/Angular），兼容遗留系统，避免全量重构；
4. **渐进升级**：旧系统可逐步替换为新模块，降低技术迁移风险；
5. **运行时隔离**：通过沙箱机制避免 CSS/JS 全局污染，保障子应用独立性。

**典型场景**：中后台系统、多团队协作项目、长期迭代的复杂产品。

## 低代码平台怎么设计渲染模块？

低代码平台的渲染模块通过**数据驱动 + 组件动态解析**，将可视化配置的JSON描述转换为可交互的运行时界面。

1. **配置解析引擎**：将用户拖拽生成的DSL（如JSON Schema）解析为AST，映射到预置的原子组件（表单、表格等）；
2. **组件动态加载**：基于组件注册中心，按需加载本地或远程组件库，支持版本控制与热更新；
3. **数据绑定机制**：通过表达式引擎（如`\{\{data.field}}`）实现组件与数据模型的动态关联，处理表单校验、联动逻辑；
4. **运行时沙箱**：隔离渲染环境，防止组件样式/JS污染，支持实时预览与调试；
5. **扩展能力**：提供自定义插槽、生命周期钩子（如渲染前后事件），允许注入业务逻辑。

**优化方向**：缓存渲染结果、虚拟滚动性能优化、SSR兼容。

## 在微前端中如何设计全局状态管理？
