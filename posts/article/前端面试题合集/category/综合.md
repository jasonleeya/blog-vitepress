---
category: 综合
order: 6
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 综合


## 谈一谈你对前端框架的理解?

前端框架（如Vue/React）是**高效构建用户界面**的工具，核心价值在于：

1. **组件化开发**：
   - 将UI拆分为独立、可复用的组件，提升代码复用性与可维护性。
2. **数据驱动视图**：
   - 通过响应式或虚拟DOM机制，数据变化自动更新视图，减少手动DOM操作。
3. **生态整合**：
   - 提供路由（Vue Router/React Router）、状态管理（Pinia/Redux）、构建工具（Vite/Webpack）等完整开发链路支持。
4. **性能优化**：
   - 虚拟DOM Diff算法、SSR服务端渲染、代码分割等优化手段，提升应用性能。

**解决的问题**：

- 传统开发中手动操作DOM的低效与复杂度；
- 大规模应用下代码组织混乱、维护困难；
- 跨团队协作规范不统一。

## 谈谈对 MVC、MVP、MVVM 模式的理解？

**1. MVC（Model-View-Controller）**

- **组成**：
  - **Model**：管理数据和业务逻辑。
  - **View**：负责 UI 展示。
  - **Controller**：接收用户输入，更新 Model，并通知 View 更新。
- **交互**：
  - 用户操作 → **Controller** → 更新 Model → **View** 监听 Model 变化并渲染。
- **特点**：
  - View 可直接访问 Model，导致**双向依赖**（如观察者模式），耦合度较高。
  - 典型应用：传统后端框架（如 Spring MVC）、早期前端框架。
- **问题**：View 和 Model 的强耦合可能导致代码维护困难。

**2. MVP（Model-View-Presenter）**

- **组成**：
  - **Model**：同 MVC，管理数据。
  - **View**：被动 UI，仅定义界面结构和触发事件。
  - **Presenter**：中介者，处理业务逻辑，更新 Model 并控制 View。
- **交互**：
  - 用户操作 → **View** → 通知 Presenter → 更新 Model → Presenter 更新 View。
- **特点**：
  - **View 与 Model 完全解耦**，所有逻辑集中在 Presenter。
  - 更易测试（Mock View 即可测试 Presenter）。
  - 典型应用：桌面应用（如 Android 早期开发）。
- **问题**：Presenter 可能变得臃肿，需手动同步 View 和 Model。

**3. MVVM（Model-View-ViewModel）**

- **组成**：
  - **Model**：数据层。
  - **View**：UI 展示。
  - **ViewModel**：通过数据绑定（Data Binding）连接 View 和 Model，暴露命令和状态。
- **交互**：
  - **双向绑定**：View 的输入自动更新 ViewModel，ViewModel 变化自动同步到 View。
  - **数据驱动**：Model 变化 → ViewModel 更新 → View 自动渲染（如 Vue/React）。
- **特点**：
  - **低耦合**：View 不直接操作 Model，通过 ViewModel 代理。
  - **高效开发**：减少手动 DOM 操作（如 Vue 的 `v-model`）。
  - 典型应用：现代前端框架（Vue.js、React + MobX）。
- **问题**：过度依赖数据绑定可能导致调试困难或性能问题（如大型列表渲染）。

**对比总结**

| 模式     | 核心思想                             | 通信方式                             | 适用场景                        |
| :------- | :----------------------------------- | :----------------------------------- | :------------------------------ |
| **MVC**  | 分层解耦，View 直接依赖 Model        | 多向通信（可能循环依赖）             | 传统后端、简单前端应用          |
| **MVP**  | Presenter 解耦 View 和 Model         | 单向通信（View ↔ Presenter ↔ Model） | 桌面应用、需要高测试性的场景    |
| **MVVM** | 数据绑定自动同步，ViewModel 代理逻辑 | 双向绑定（View ↔ ViewModel ↔ Model） | 现代前端框架（如 Vue、Angular） |

## 说说你对SPA（单页应用）的理解?

SPA（单页应用）是指**通过前端路由动态渲染内容**的 Web 应用，其核心特点是：

1. **单次加载**：首次访问加载完整 HTML、CSS 和 JS，后续页面切换通过 AJAX/API 获取数据，客户端动态更新 DOM，无需整页刷新。
2. **前端路由**：利用 `history API` 或 `hash` 实现 URL 变化与视图匹配，保持用户体验流畅性（如 Vue Router、React Router）。
3. **优点**：
   - 交互流畅，接近原生应用体验；
   - 减轻服务器压力，前后端分离开发；
   - 支持复杂状态管理（如 Redux、Pinia）。
4. **挑战**：
   - **SEO 不友好**：传统爬虫难以抓取动态内容（可通过 SSR/SSG 优化）；
   - **首屏性能**：资源加载较慢（需代码分割、懒加载优化）；
   - **内存管理**：长期运行需警惕内存泄漏。

## SPA（单页应用）首屏加载速度慢怎么解决？

1. **代码分割 + 懒加载**：
   - 用`import()`动态导入路由组件（Vue Router的`component: () => import('...')`），按需加载。
   - 使用Webpack的`SplitChunksPlugin`拆分公共代码和第三方库（如Vue、Vuex）。
2. **资源优化**：
   - 压缩JS/CSS（Terser、CSSNano）、图片转WebP/AVIF格式或用懒加载。
   - 开启Gzip/Brotli压缩（服务器配置）。
3. **预渲染（Prerender）或SSR**：
   - 对静态页面用`prerender-spa-plugin`预生成HTML，直接返回给用户。
   - 复杂场景用服务端渲染（如Nuxt.js），首屏直出HTML。
4. **CDN加速静态资源**：
   - 将第三方库（如Vue、lodash）通过CDN引入，减少打包体积。
5. **优化首屏关键资源**：
   - 内联关键CSS，异步加载非必要JS（如`async`/`defer`）。
   - 使用骨架屏（Skeleton）过渡，提升用户体验。
6. **缓存策略**：
   - 强缓存（Cache-Control）、协商缓存（ETag）减少重复请求。
   - Service Worker做离线缓存（PWA）。

**工具辅助**：用Lighthouse分析性能瓶颈，针对性优化。

## 常⻅兼容性问题

[前端开发中常见的浏览器兼容性问题及解决方案大汇总](https://juejin.cn/post/7067808335034220574)

## HTML中的attribute属性和JavaScript中的property属性的详解以及区别

**attribute**：是HTML标签上的某个属性，如id、class、value等以及自定义属性，它的值只能是字符串，关于这个属性一共有三个相关的方法，setAttribute、getAttribute、removeAttribute；
**property**：是js获取的DOM对象上的属性值，比如a，你可以将它看作为一个基本的js对象。这个节点包括很多property，比如value，className以及一些方法onclik等方法。

**注意**：在使用setAttribute的时候，该函数一定接收两个参数，setAttribute（attributeName,value）,无论value的值是什么类型都会编译为字符串类型。在html标签中添加属性，本质上是跟在标签里面写属性时一样的，所以属性值最终都会编译为字符串类型。

## HTML中的attribute属性和JavaScript中的property属性区别

- **Attribute**：
  - **HTML 标签上的属性**，定义在 HTML 中（如 `<input id="name" value="初始值">`）。
  - 通过 `setAttribute()`/`getAttribute()` 操作，**始终返回字符串**。
- **Property**：
  - **DOM 对象（如元素节点）的属性**，是 JavaScript 内存中的值。
  - 通过 `element.propertyName` 直接访问（如 `input.value`），**类型多样**（布尔、数字、对象等）。

## 常见的 web 前端网络攻击有哪些？

**1. XSS（跨站脚本攻击）**

- **原理**：攻击者注入恶意脚本到页面中，窃取用户数据（如 Cookie）。
- **类型**：存储型、反射型、DOM 型。
- **防御**：
  - 输入内容转义（如 `&` → `&`）。
  - 使用 CSP（内容安全策略）限制脚本来源。
  - 避免 `innerHTML`，优先用 `textContent`。

**2. CSRF（跨站请求伪造）**

- **原理**：诱导用户发起非预期的请求（如修改密码）。
- **防御**：
  - 关键操作校验 `Referer` 或 `Origin` 头。
  - 请求添加 CSRF Token（服务端生成并验证）。
  - Cookie 设置 `SameSite=Strict/Lax`。

**3. 点击劫持（Clickjacking）**

- **原理**：通过透明 iframe 覆盖诱骗用户点击隐藏按钮。
- **防御**：
  - HTTP 头设置 `X-Frame-Options: DENY/SAMEORIGIN`。
  - 前端 JS 判断 `self === top` 防止嵌套。

**4. 中间人攻击（MITM）**

- **原理**：劫持通信链路窃取或篡改数据。
- **防御**：
  - 全站启用 HTTPS（HTTP/2 + HSTS 强制跳转）。
  - 避免混合内容（HTTP 与 HTTPS 混用）。

**5. CORS 配置错误**

- **原理**：不当的跨域策略导致敏感数据泄露。
- **防御**：
  - 服务端严格设置 `Access-Control-Allow-Origin`（避免 `*`）。
  - 限制预检请求（`OPTIONS`）的响应头范围。

**6. DDoS（CC 攻击）**

- **原理**：高频请求耗尽服务器资源。
- **防御**：
  - 前端添加验证码或行为验证（如滑动拼图）。
  - 服务端限流（IP 频率限制）。

7. 恶意文件上传**

- **原理**：上传可执行文件（如 `.php`）到服务器。
- **防御**：
  - 前端限制文件类型（白名单校验）。
  - 服务端重命名文件并扫描内容。

**8. DNS 劫持**

- **原理**：篡改 DNS 解析结果导向恶意站点。
- **防御**：
  - 使用 HTTPS 加密通信。
  - 启用 DNS over HTTPS（DoH）。

## 什么是虚拟DOM?其优点有哪些？

虚拟 DOM（Virtual DOM）是一种**用 JavaScript 对象模拟真实 DOM 结构的中间层**，常见于 React、Vue 等框架，其核心原理与优点如下：

**一、虚拟 DOM 的核心原理**

1. **结构映射**：将真实 DOM 抽象为轻量的 JS 对象（如 `{ type: 'div', props: { className: 'box' }, children: [...] }`）。
2. **差异比对（Diff）**：状态变化时生成新虚拟 DOM，与旧版本对比，找出最小变更（差异）。
3. **批量更新**：将差异一次性应用到真实 DOM，减少直接操作次数。

**二、虚拟 DOM 的核心优点**

1. **性能优化**
   - **减少直接 DOM 操作**：真实 DOM 操作（如修改 `innerHTML`）会触发重排/重绘，成本高昂。
   - **批量更新与合并**：通过差异比对避免频繁的 DOM 修改，降低渲染开销。
2. **跨平台能力**
   - **抽象渲染逻辑**：虚拟 DOM 可对接不同平台（浏览器 DOM、移动端原生组件、Canvas 等），如 React Native。
3. **开发体验提升**
   - **声明式编程**：开发者关注数据与 UI 的关系，而非手动操作 DOM（如 `document.getElementById`）。
   - **自动优化**：框架处理底层 DOM 更新，简化复杂 UI 的维护。
4. **高效的 Diff 算法**
   - **同级对比**：React 等框架采用分层对比策略，时间复杂度从 O(n³) 优化至 O(n)。
   - **Key 值优化**：通过 `key` 标识元素，减少不必要的节点销毁与重建。

**三、虚拟 DOM 的适用场景**

- **动态复杂 UI**：频繁交互的页面（如数据看板、编辑器）。
- **跨平台应用**：一套代码适配多端渲染。
- **框架级优化**：与状态管理、组件化结合，构建高效应用。

**四、与传统直接操作 DOM 的对比**

| **场景**     | **直接操作 DOM**   | **虚拟 DOM**                 |
| :----------- | :----------------- | :--------------------------- |
| **简单更新** | 更快（无中间层）   | 略慢（需生成和对比虚拟 DOM） |
| **复杂更新** | 性能差（频繁重排） | 性能优（批量更新）           |
| **开发效率** | 低（手动更新）     | 高（声明式编程）             |

**总结**

虚拟 DOM 通过 **JS 对象抽象** 和 **差异比对机制**，在复杂场景下显著提升性能与开发效率，是现代前端框架的核心设计之一。其价值并非绝对性能最优，而是在开发体验与渲染效率之间找到最佳平衡。

## DOM树和渲染树有什么区别？

DOM 树和渲染树（Render Tree）的核心区别在于**作用范围和节点过滤**：

1. **节点范围**：
   - **DOM 树**：包含 HTML 文档所有节点（包括隐藏元素如 `display: none` 或 `<script>`）。
   - **渲染树**：仅包含**可见节点**（如 `display: none` 的元素会被排除）。
2. **构建依据**：
   - DOM 树由 HTML 解析直接生成，反映文档结构。
   - 渲染树由 DOM 树 + CSSOM（CSS 样式规则）组合生成，决定实际渲染内容。
3. **节点对应关系**：
   - DOM 节点与渲染树节点不一定一一对应（如 `visibility: hidden` 的元素仍占用渲染树空间）。
4. **核心作用**：
   - DOM 树提供文档结构操作能力（如 JS 增删节点）。
   - 渲染树驱动浏览器布局（Layout）和绘制（Paint），直接影响页面渲染性能。

**示例**：

- `<div style="display: none">` 会出现在 DOM 树中，但不会进入渲染树。
- `<span>Hello</span>` 在渲染树中可能被合并到父级文本块中。

## Vue与React的区别，分别在哪些场景下使用更合适？

一、核心区别

1. **数据绑定与响应式机制**

- **Vue**：采用**双向数据绑定**（如`v-model`），通过`getter/setter`劫持数据变化，自动追踪依赖并更新视图，简化了表单交互开发137。
- **React**：坚持**单向数据流**，需通过`setState`显式更新状态，依赖虚拟DOM的`diff`算法优化渲染性能，强调数据的不可变性169。

2. **模板与语法**

- **Vue**：使用基于HTML的模板语法（如`v-if`、`v-for`），逻辑与视图分离更直观，适合偏好声明式开发的团队268。
- **React**：完全依赖**JSX**（JavaScript XML），将HTML与JavaScript混合编写，提供更高的灵活性，适合函数式编程爱好者6910。

3. **组件通信与复用**

- **Vue**：通过`props`传递数据、`$emit`触发事件，支持`provide/inject`跨层级通信；逻辑复用多依赖`mixins`或`Composition API`17。
- **React**：父组件通过`props`传递回调函数，跨层级通信使用`Context API`；逻辑复用通过**HOC（高阶组件）**或**Hooks**实现159。

4. **状态管理**

- **Vue**：内置**Vuex/Pinia**，支持直接修改状态，深度集成响应式系统，开发体验更简洁179。
- **React**：依赖第三方库如**Redux/MobX**，强调不可变数据与纯函数，需通过`dispatch`触发状态变更，适合复杂状态流156。

5. **生态系统与工具链**

- **Vue**：官方提供全家桶（Vue Router、Vuex、Vite），适合快速搭建轻量级应用；中文文档友好，学习曲线平缓3610。
- **React**：社区生态庞大（如Next.js、React Native），工具链灵活但需自行选型；适合企业级应用与跨平台开发5610。

二、适用场景

1. **选择Vue的场景**

- **中小型项目**：快速原型开发、表单密集型应用（如后台管理系统），Vue的响应式系统能显著减少手动编码量368。
- **团队新手较多**：模板语法直观，文档详尽，适合传统Web开发者快速上手610。
- **渐进式集成**：需逐步替换旧项目（如jQuery），通过CDN引入局部功能升级510。

2. **选择React的场景**

- **大型复杂应用**：如社交平台、实时协作工具，React的单向数据流与虚拟DOM优化更易维护高性能动态界面569。
- **跨平台开发**：借助**React Native**实现iOS/Android代码复用，适用于需原生性能的移动端项目510。
- **强类型与测试需求**：结合TypeScript，提升代码健壮性；生命周期管理严格，适合微前端架构569。

3. **其他考量因素**

- **团队经验**：熟悉函数式编程选React，偏好HTML模板选Vue610。
- **长期维护性**：React的不可变数据与TypeScript支持降低重构风险；Vue的渐进式升级路径更明确（如Vue2→3平滑迁移）59。

## <span id="browser">从浏览器输入url后都经历了什么</span>

- 通过DNS解析获得网址的对应IP地址 

- 浏览器与远程web服务器 通过TCP三次握手协商来建立一个 TCP/IP 连接 

- 浏览器 通过TCP/IP连接 向web服务器 发送一个 HTTP 请求 

- 服务器的永久重定向响应 

- 浏览器跟踪重定向地址 

- 服务器处理请求 

- 服务器返回一个 HTTP 响应 

- 浏览器渲染:解析HTML、解析CSS、解析JS、Render树

## <span id="reflow-and-repaint">回流和重绘有什么区别？</span>

**1. 触发原因**

- **回流（Reflow）**：当元素的**几何属性或布局发生变化**（如宽高、位置、字体大小、窗口缩放等），浏览器需重新计算元素的几何信息并更新布局树。
- **重绘（Repaint）**：当元素的**样式变化但不影响布局**（如颜色、背景、透明度等），浏览器只需重新绘制受影响区域。

**2. 性能影响**

- **回流比重绘代价更高**：回流会导致子元素及后续元素的连锁重新计算（“布局抖动”），而重绘仅涉及像素更新。
- **回流必定触发重绘**：布局变化后必然需要重新绘制，但重绘不一定触发回流。

**3. 常见触发场景**

- **回流**：
  - 修改元素的尺寸、位置、边距（如 `width`、`margin`、`position`）。
  - 增删可见 DOM 元素。
  - 读取某些属性（如 `offsetTop`、`scrollHeight`）会强制同步回流。
- **重绘**：
  - 修改颜色（`color`）、背景（`background`）、阴影（`box-shadow`）。
  - 隐藏元素但保留布局（如 `visibility: hidden`）。

**优化策略**

1. **减少回流次数**：
   - 使用 `transform` 或 `opacity` 代替直接修改 `top/left`（触发 GPU 加速，跳过回流）。
   - 避免逐行修改样式，通过 `class` 或 `cssText` 批量更新。
   - 使用 `DocumentFragment` 批量操作 DOM。
2. **避免强制同步布局**：
   - 避免在循环中频繁读取布局属性（如 `offsetWidth`），会强制浏览器立即回流。

## 你知道哪些性能优化手段？

**一、网络请求优化**

1. **减少请求次数**
   - 合并资源（CSS/JS 文件、雪碧图）。
   - 使用 HTTP/2 多路复用降低队头阻塞。
2. **资源压缩与缓存**
   - 开启 Gzip/Brotli 压缩。
   - 强缓存（`Cache-Control`）与协商缓存（`ETag`）合理配置。
3. **CDN 加速**：静态资源分发至边缘节点，减少传输延迟。

**二、资源加载优化**

1. **按需加载**
   - 路由懒加载（React.lazy + Suspense）。
   - 图片懒加载（`loading="lazy"` 或 IntersectionObserver）。
2. **预加载关键资源**
   - `<link rel="preload">` 提前加载字体、核心 JS/CSS。
   - 异步脚本（`async/defer`）避免阻塞渲染。
3. **资源体积优化**
   - 代码分包（Webpack SplitChunks）。
   - 图片格式优化（WebP/AVIF）、响应式图片（`srcset`）。

**三、渲染性能优化**

1. **减少重排与重绘**
   - 避免频繁操作样式，使用 `transform/opacity` 触发 GPU 加速。
   - 批量 DOM 更新（DocumentFragment）。
2. **优化长列表**
   - 虚拟滚动（React Virtualized、Vue Virtual Scroller）。
3. **避免强制同步布局**
   - 分离读写操作（如先读取布局属性，再统一修改）。

**四、代码执行优化**

1. **减少主线程阻塞**
   - 长任务拆分（Web Workers）。
   - 防抖/节流（resize、scroll 事件）。
2. **内存管理**
   - 及时解绑事件监听、清除定时器。
   - 避免内存泄漏（闭包、全局变量滥用）。
3. **Tree Shaking**：删除未使用代码（ES Module 静态分析）。

**五、其他关键优化**

1. **SSR/SSG**：服务端渲染（如 Next.js）提升首屏速度。
2. **Web Vitals 指标优化**
   - LCP：优先加载关键资源，优化图片/字体。
   - FID：减少主线程长任务，延迟非关键 JS。
   - CLS：预留图片/广告位尺寸，避免布局偏移。
3. **性能监控**
   - Lighthouse 评分分析。
   - 埋点上报（FP/FCP/LCP 等关键指标）。

**总结**

性能优化需结合具体场景，核心思路是 **减少负载、加速渲染、避免阻塞**。通过工具分析瓶颈（如 Chrome DevTools Performance 面板），渐进式优化并持续监控。

## 前端动画有哪些实现方式？

1. **CSS动画**：使用 `transition` 和 `@keyframes` 实现简单动画，性能优化好，适合交互动效（如悬停、加载）。
2. **JavaScript动画库**：如 **GSAP**、Anime.js，适合复杂动画（时间轴、路径动画），控制精细。
3. **SVG动画**：通过 `<animate>` 标签或操作DOM属性，适合矢量图形动画（如图标变形）。
4. **Canvas/WebGL**：用 **Canvas API** 或 **Three.js** 实现高性能动画（游戏、数据可视化）。
5. **框架内置动画**：如 Vue 的 `<Transition>` 组件、React 的 **React Spring**，与框架深度集成。
6. **Web Animations API**：原生JS API，融合CSS和JS动画能力，可控性强。

## Canvas 和 SVG 的区别

Canvas 是**位图**，通过 JavaScript 动态绘制，适合高频渲染（如动画、游戏），但元素不可单独操作；

SVG 是**矢量图**，基于 XML 描述图形，支持缩放无损、DOM 事件绑定，适合静态或交互复杂图形（如图标、图表）。Canvas 性能更高，SVG 更易维护和交互。

## 如何判断用户设备？

1. 使用 navigator.userAgent（用户代理字符串）
2. 使用 CSS 媒体查询
3. js判断视口宽度
4. 第三方库（mobile-detect.js等）

## 你知道哪些自适应的方案？

1. **媒体查询（Media Queries）**
   通过CSS `@media` 根据屏幕尺寸适配不同样式，如断点布局（Bootstrap栅格系统）。
2. **弹性布局（Flexbox/Grid）**
   使用 `Flexbox` 或 `CSS Grid` 实现弹性容器，自动适应不同屏幕尺寸。
3. **百分比/视口单位（vw/vh）**
   用 `%`、`vw`（视口宽度单位）或 `vh`（视口高度单位）动态调整元素尺寸。
4. **Rem适配方案**
   结合 `rem`（根元素字体大小）和 `JavaScript` 动态计算根字体（如根据屏幕宽度设置 `1rem = 屏幕宽度的1/10`）。
5. **响应式图片**
   使用 `<picture>` 标签或 `srcset` 属性适配不同分辨率，结合 `max-width: 100%` 防止图片溢出。

##  前端需要注意哪些SEO

1. **语义化 HTML**
   合理使用 `<h1>`~`<h6>`、`<header>`、`<nav>`、`<article>` 等标签，增强内容可读性。
2. **标题与 Meta 标签**
   确保每个页面有唯一的 `<title>` 和 `meta description`，准确描述页面内容。
3. **图片优化**
   添加 `alt` 属性，压缩图片体积（WebP格式），使用 `srcset` 适配不同分辨率。
4. **友好的 URL 结构**
   采用静态路径（如 `/blog/seo-tips`），避免 `#` 路由或动态参数混乱。
5. **移动端适配**
   响应式设计 + `viewport` 配置，确保移动端体验良好（影响 Google 排名）。
6. **性能优化**
   压缩资源、减少渲染阻塞（如懒加载）、提升加载速度（Lighthouse 评分）。
7. **避免纯 SPA 问题**
   单页应用（如 React/Vue）需结合 SSR（服务端渲染）或预渲染，保证爬虫抓取内容。
8. **结构化数据（Schema）**
   使用 JSON-LD 标记关键信息（如产品价格、评分），提升搜索富片段展示。
9. **外链与内链优化**
   合理设置 `<a>` 标签的 `href`，避免死链，利用 `rel="nofollow"` 控制权重。
10. **Sitemap 与 robots.txt**
    提交 XML 站点地图，配置爬虫抓取规则。

## cookie 和 session有什么区别

1. **存储位置**
   - Cookie：数据存储在**客户端**（浏览器），通过请求头自动传递。
   - Session：数据存储在**服务端**，客户端仅保存 Session ID（通常通过 Cookie 存储）。
2. **安全性**
   - Cookie：易被篡改或窃取（需配合 `HttpOnly`、`Secure` 等属性提升安全性）。
   - Session：敏感数据存于服务端，仅暴露 ID，安全性更高。
3. **存储大小限制**
   - Cookie：单域名下通常限制为 **4KB** 左右。
   - Session：服务端存储，理论无严格大小限制。
4. **生命周期**
   - Cookie：可设置过期时间（如 `Expires` 或 `Max-Age`），支持长期保存。
   - Session：依赖服务端配置，通常浏览器关闭即失效（或服务端主动清理）。

## 懒加载和预加载有什么区别？

1. **加载时机**
   - **懒加载**：延迟加载非关键资源（如图片、组件），当用户即将需要时（如滚动到视口）触发。
   - **预加载**：提前加载后续可能需要的资源（如下一页内容），在空闲时间或用户操作前完成。
2. **核心目的**
   - **懒加载**：优化首屏加载速度，减少初始请求压力。
   - **预加载**：提升后续操作的流畅性，减少用户等待时间。
3. **典型场景**
   - **懒加载**：长列表、图库、非首屏内容。
   - **预加载**：幻灯片切换、关键功能模块、预测用户下一步行为。
4. **实现方式**
   - **懒加载**：通过 `Intersection Observer` 监听元素可见性，或动态 `import()` 异步加载组件。
   - **预加载**：使用 `<link rel="preload">` 或 `fetch()` 提前请求资源。

## 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

**使用 1x1 像素透明 GIF 图片发送埋点请求的核心原因**：

1. **无跨域限制**：
   `<img>` 标签天然支持跨域请求，无需 CORS 配置，避免浏览器拦截。
2. **性能损耗低**：
   1x1 透明 GIF 体积极小（约 43B），传输快且不占用额外资源，对页面性能影响最小。
3. **兼容性强**：
   所有浏览器均支持 GIF 格式，且图片加载无阻塞问题（相比脚本或 AJAX）。
4. **无副作用**：
   透明图片不会干扰页面展示，无需处理内容返回（服务器只需响应 204/200 状态码）。
5. **数据传参灵活**：
   通过 URL 的 query 参数携带埋点数据（如 `?event=click&user=123`），服务端解析日志即可。

## 简述一下 PWA

**PWA（渐进式网络应用）的核心要点**：

1. **核心能力**：
   - **离线可用**：通过 `Service Worker` 缓存资源，实现弱网或无网访问。
   - **类原生体验**：支持添加到主屏幕、全屏模式、推送通知（Push API）。
2. **关键技术**：
   - **Service Worker**：后台脚本管理缓存与网络代理。
   - **Web App Manifest**：定义应用图标、启动页等元数据（`manifest.json`）。
   - **HTTPS 强制**：确保通信安全。
3. **核心优势**：
   - **响应式设计**：适配多端（PC/移动）。
   - **低流量消耗**：优先加载缓存资源。
   - **无安装依赖**：通过浏览器访问，支持渐进增强（逐步支持高级功能）。

## 前端埋点有哪些方案？

1. **代码埋点（手动埋点）**
   在代码中插入上报逻辑（如点击/曝光事件），灵活但维护成本高。
2. **可视化埋点**
   通过工具（如GrowingIO）配置事件，无代码侵入，适合非技术人员操作。
3. **无埋点（全埋点）**
   自动采集全量用户行为（如点击、页面停留），通过后端过滤分析，数据全但处理复杂。
4. **服务端埋点**
   由后端记录日志（如API请求），避免客户端数据丢失，但无法捕获前端交互细节。
5. **基于Image/Beacon的请求**
   使用 `new Image().src` 或 `navigator.sendBeacon()` 发送数据，避免阻塞页面。

## 简述一下 WebAssembly

1. **定位**：
   - 一种**二进制指令格式**，能在浏览器中高性能执行（接近原生速度），与JS互补，非替代。
2. **核心能力**：
   - **高性能计算**：适用于图形渲染、游戏、加密等CPU密集型任务。
   - **跨语言支持**：C/C++/Rust等语言可编译成Wasm，复用现有生态。
   - **沙箱安全**：运行在隔离内存环境中，避免恶意代码攻击。
3. **应用场景**：
   - 浏览器内高性能应用（如FFmpeg视频解码）。
   - 跨平台应用（结合Web/桌面/移动端）。
   - 模块化加速（如JS性能瓶颈的数学计算）。

## 如何给自己团队的大型前端项目设计单元测试？

1. **选型与分层**
   - **框架**：选主流工具（如Jest+Vue Test Utils/React Testing Library），确保生态支持。
   - **分层策略**：按模块拆分（Utils → Components → Hooks → API层），优先覆盖核心逻辑与公共模块。
2. **覆盖率与规范**
   - **阈值设定**：核心代码覆盖率不低于80%（如业务Utils），UI组件可放宽。
   - **Mock策略**：用`jest.mock`隔离API、第三方库，避免真实网络请求。
3. **组件测试重点**
   - **渲染校验**：验证Props传递与条件渲染（如`toBeInTheDocument`）。
   - **交互测试**：模拟用户操作（点击/输入），断言状态或事件触发正确性。
4. **工程化集成**
   - **Husky + Lint**：提交代码前自动跑测试，拦截失败用例。
   - **CI流水线**：集成到Jenkins/GitHub Actions，生成可视化报告（如Jest HTML Reporter）。
5. **维护与优化**
   - **快照测试**：监控UI意外变更（慎用，避免频繁失效）。
   - **测试可读性**：用例命名清晰（`describe`场景，`it`预期结果），定期Review冗余用例。

## ECharts是什么？能够用来做什么？

`ECharts`（百度开源的**可视化图表库**）是一个基于`JavaScript`的开源可视化图表库，可以用来创建丰富、交互式的数据可视化图表。

`ECharts`能够用来展示各种类型的图表，包括**折线图、柱状图、条形图、散点图、饼图、雷达图、地图**等。它支持动态更新数据，通过交互操作，可以实现数据的**筛选、排序、缩放**等功能。

`ECharts`提供了丰富的配置项和API，使开发者可以根据自己的需求灵活定制图表的样式和行为，同时还支持多种数据格式的导入和导出。它适用于各类**数据分析、数据可视化、大屏展示**等场景，可以帮助用户更直观地理解和分析数据，从而做出更好的决策。

## 如何提高前端代码的可维护性和可拓展性？

1. **模块化与组件化**
   - 按功能拆分独立模块/组件，遵循**单一职责原则**（如UI与逻辑分离），降低耦合度。
2. **统一代码规范**
   - 使用ESLint+Prettier强制代码风格，制定命名规则（如`动词+名词`函数名），增强可读性。
3. **类型系统**
   - 引入TypeScript，明确接口类型与数据结构，减少隐式错误，提升重构信心。
4. **设计模式应用**
   - 常用模式：工厂模式（创建对象）、策略模式（算法替换）、观察者模式（事件通信），提升扩展性。
5. **文档与注释**
   - 关键逻辑添加注释，维护组件API文档（如Storybook），降低新人上手成本。
6. **自动化测试**
   - 核心逻辑覆盖单元测试（Jest），复杂交互补充E2E测试（Cypress），保障迭代安全。
7. **状态管理规范**
   - 使用Redux/Pinia集中管理全局状态，避免Props多层透传，逻辑更易追踪。
8. **工程化工具链**
   - 配置Alias简化导入路径，利用Webpack/Vite实现按需加载，优化构建流程。

## 列举一些常见的content-type

1. **`application/json`**：JSON 数据交互，如 REST API 请求/响应。
2. **`multipart/form-data`**：表单文件上传（支持二进制数据）。
3. **`application/x-www-form-urlencoded`**：普通表单提交（键值对 URL 编码）。
4. **`text/html`**：HTML 文档渲染。
5. **`text/plain`**：纯文本内容（如日志）。
6. **`text/css`** / **`text/javascript`**：CSS 或 JS 文件类型。
7. **`image/png`** / **`image/jpeg`**：图片资源格式。
8. **`application/octet-stream`**：二进制流（如文件下载）。
9. **`application/xml`**：XML 数据格式（传统接口）。

## CSS动画和JS实现的动画分别有哪些优缺点？

## AST语法树是什么？

## CSR和SSR(前端渲染与后端渲染)区别是什么？

## 你知道哪些图标处理方案?

## 常见的登录鉴权方式有哪些？

1. **Cookie + Session**

- **原理**：用户登录后，服务器创建一个 `Session`，将用户信息存储在服务器端，同时生成一个唯一的 `SessionID`，并将其以 `Cookie` 的形式发送给客户端。客户端之后的每次请求都携带该 `Cookie`，服务器用 `SessionID` 确认用户身份。
- **优点**：服务器管理会话状态，安全性较高；可以设置短期有效期，适合敏感信息。
- **缺点**：会消耗服务器内存，难以扩展；需跨域配置。

2. **JWT（JSON Web Token）**

- **原理**：登录成功后，服务器生成一个加密的 `JWT`，该令牌包含用户信息或标识，发送给客户端。之后的请求，客户端携带该 `JWT`，服务器通过验证 `JWT` 的签名来确认用户身份。
- **优点**：无状态、可跨域，适合分布式架构；可携带信息，支持用户角色验证。
- **缺点**：令牌较长，增加请求负担；一旦泄露容易被滥用。

3. **OAuth**

- **原理**：OAuth 是一种授权协议，用户通过第三方平台（如 Google、Facebook）登录，将权限授予该平台来访问某些资源。OAuth 2.0 使用 `Access Token` 访问受保护资源，`Refresh Token` 则用于获取新的 `Access Token`。
- **优点**：用户体验好，适用于第三方应用授权登录；支持多级权限。
- **缺点**：流程复杂，难以实现；`Token` 可能泄露或失效。

4. **SAML（Security Assertion Markup Language）**

- **原理**：SAML 是基于 XML 的单点登录协议，通常用于企业系统中。用户请求通过 SAML 协议在多个系统之间共享认证状态，允许用户在不重新登录的情况下访问其他应用。
- **优点**：适用于企业内部系统间的统一登录；支持跨域。
- **缺点**：复杂度高，基于 XML 的消息传递效率低。

5. **SSO（Single Sign-On）**

- **原理**：单点登录允许用户使用一个登录凭据访问多个应用或系统。常用的实现方案包括基于 OAuth、SAML 或 CAS（Central Authentication Service）。
- **优点**：提高用户体验，避免多次登录；适用于多系统集成。
- **缺点**：一旦账户泄露，多个系统都会受到威胁。

6. **基于短信或邮件的 OTP（一次性密码）**

- **原理**：用户登录时接收一个一次性密码（通常通过短信或邮件发送），有效期较短。用户输入正确的 OTP 后，即可完成登录。
- **优点**：安全性高，适合敏感操作的二次验证。
- **缺点**：需要借助短信或邮件服务，成本较高。

7. **指纹、面部识别等生物识别**

- **原理**：利用设备上的生物识别传感器进行身份认证，例如指纹、面部识别等。通常用于设备级别的解锁，或结合其他鉴权方式进行身份确认。
- **优点**：用户体验佳、难以复制；适合移动设备的安全验证。
- **缺点**：设备依赖性强；难以在 web 应用中普遍使用。
