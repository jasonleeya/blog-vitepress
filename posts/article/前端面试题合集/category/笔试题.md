---
category: 笔试题
order: 8
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 笔试题


## 实现交换两个变量

JavaScript交换两个变量的常用方法：

1. **临时变量法**（通用性强，推荐）：

   ```javascript
   let a = 1, b = 2;  
   let temp = a;  
   a = b;  
   b = temp;  
   console.log(a, b); // 输出 2 1  
   ```

2. **解构赋值法**（ES6+，简洁）：

   ```javascript
   [a, b] = [b, a]; // 直接交换  
   ```

3. **数学运算法**（仅限数值类型）：

   ```javascript
   a = a + b;  
   b = a - b;  
   a = a - b;  
   ```

4. **位运算异或法**（仅限整数）：

   ```javascript
   a = a ^ b;  
   b = a ^ b;  
   a = a ^ b; 
   ```

## 简单实现Promise

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending'; // 状态：pending/fulfilled/rejected
    this.value = undefined; // 成功值
    this.reason = undefined; // 失败原因
    this.onFulfilledCallbacks = []; // 成功回调队列
    this.onRejectedCallbacks = []; // 失败回调队列

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn()); // 执行异步回调
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn()); // 执行异步回调
      }
    };

    try {
      executor(resolve, reject); // 立即执行执行器函数
    } catch (err) {
      reject(err); // 捕获同步错误
    }
  }

  then(onFulfilled, onRejected) {
    // 处理值穿透（then() 无参数时传递值）
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err; };

    const promise2 = new MyPromise((resolve, reject) => {
      const handleFulfilled = () => {
        setTimeout(() => { // 确保异步执行
          try {
            const x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        }, 0);
      };

      const handleRejected = () => {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        }, 0);
      };

      if (this.state === 'fulfilled') {
        handleFulfilled();
      } else if (this.state === 'rejected') {
        handleRejected();
      } else { // pending 状态时存储回调
        this.onFulfilledCallbacks.push(handleFulfilled);
        this.onRejectedCallbacks.push(handleRejected);
      }
    });

    return promise2; // 返回新 Promise 实现链式调用
  }
}

// 处理 then 返回值的解析（支持返回 Promise 或普通值）
function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) { // 禁止循环引用
    return reject(new TypeError('Chaining cycle detected'));
  }
  if (x instanceof MyPromise) { // 递归解析 Promise
    x.then(resolve, reject);
  } else {
    resolve(x);
  }
}
```

## 如何用Promise实现超时控制？

**1. 基础实现：超时抛出错误**

```javascript
function timeoutPromise(promise, timeout) {  
  // 创建超时 Promise，到达时间后 reject  
  const timeoutP = new Promise((_, reject) => {  
    setTimeout(() => reject(new Error('请求超时')), timeout);  
  });  

  // 返回竞速结果  
  return Promise.race([promise, timeoutP]);  
}  

// 使用示例  
const fetchData = fetch('https://api.example.com');  
timeoutPromise(fetchData, 5000)  
  .then(res => console.log('成功:', res))  
  .catch(err => console.error('失败:', err));  
```

**2. 结合 AbortController 取消实际请求（如 fetch）**

```javascript
function fetchWithTimeout(url, timeout = 5000) {  
  const controller = new AbortController();  
  const timeoutId = setTimeout(() => controller.abort(), timeout);  

  return fetch(url, { signal: controller.signal })  
    .finally(() => clearTimeout(timeoutId)); // 清理定时器  
}  

// 使用：超时后自动取消请求  
fetchWithTimeout('https://api.example.com', 3000)  
  .catch(err => {  
    if (err.name === 'AbortError') console.log('请求超时');  
    else console.error('其他错误:', err);  
  });  
```

## 手写代码实现Promise.all

手写 `Promise.all` 的核心在于**并发执行所有Promise**，并**按顺序收集结果**，遇到失败立即终止。以下是实现代码及解析：

```javascript
function myPromiseAll(promises) {  
  return new Promise((resolve, reject) => {  
    // 1. 校验输入是否为可迭代对象  
    if (typeof promises?.[Symbol.iterator] !== 'function') {  
      return reject(new TypeError('Argument is not iterable'));  
    }  
    const results = [];  
    let count = 0;  
    // 2. 处理空数组直接返回  
    if (promises.length === 0) return resolve(results);  

    promises.forEach((item, index) => {  
      // 3. 统一转Promise处理非Promise值  
      Promise.resolve(item)  
        .then((value) => {  
          results[index] = value; // 按索引存储结果  
          if (++count === promises.length) resolve(results);  
        })  
        .catch(reject); // 4. 任意失败立即reject  
    });  
  });  
}  
```

**关键点解释**：

- **输入校验**：通过 `Symbol.iterator` 判断是否可迭代（如数组、Set）。
- **结果顺序**：利用闭包中的 `index` 确保结果顺序与输入一致。
- **并发执行**：`forEach` 立即启动所有Promise，无需等待前一个完成。
- **错误处理**：首个失败直接触发 `reject`，其他Promise继续执行但不处理结果。

**测试用例**：

```javascript
// 成功场景  
myPromiseAll([1, Promise.resolve(2), Promise.resolve(3)])  
  .then(console.log); // 输出 [1, 2, 3]  

// 失败场景  
myPromiseAll([Promise.reject('error'), Promise.resolve(2)])  
  .catch(console.log); // 输出 'error'  
```

**与原生的差异**：

- **行为一致**：所有Promise立即执行，无法取消。
- **边界处理**：对非Promise值的转换（`Promise.resolve`）逻辑相同。

## 手写代码实现Promise.race

手写 `Promise.race` 的核心在于**监听所有Promise，首个完成（无论成功/失败）的结果决定最终状态**。以下是实现代码及解析：

```javascript
function myPromiseRace(promises) {  
  return new Promise((resolve, reject) => {  
    // 1. 校验输入是否为可迭代对象  
    if (typeof promises?.[Symbol.iterator] !== 'function') {  
      return reject(new TypeError('Argument is not iterable'));  
    }  
    // 2. 遍历每个Promise，监听首个结果  
    for (const item of promises) {  
      // 3. 统一转Promise处理非Promise值  
      Promise.resolve(item)  
        .then(resolve)  // 首个resolve触发外层成功  
        .catch(reject); // 首个reject触发外层失败  
    }  
  });  
}  
```

**关键点解释**：

- **立即执行**：所有Promise同时启动，竞争执行。
- **首个完成优先**：无论是成功（`resolve`）还是失败（`reject`），首个完成的Promise直接决定最终状态。
- **非Promise处理**：通过 `Promise.resolve` 包装确保统一处理（如数值、普通对象）。

**测试用例**：

```javascript
// 成功场景（首个为数值）  
myPromiseRace([1, new Promise(res => setTimeout(res, 100, 2))])  
  .then(console.log); // 输出 1  

// 失败场景  
myPromiseRace([  
  new Promise((_, rej) => setTimeout(rej, 50, 'error1')),  
  new Promise((_, rej) => setTimeout(rej, 10, 'error2'))  
]).catch(console.log); // 输出 'error2'（更快完成）  

// 混合类型  
myPromiseRace([Promise.resolve('fast'), 42])  
  .then(console.log); // 输出 'fast'  
```

**与原生的差异**：

- **行为一致**：所有Promise立即执行且不可取消。
- **边界处理**：空输入直接返回 `pending` 状态的Promise（需调用方自行处理）。

**适用场景**：

- 接口超时控制（如与 `setTimeout` 结合）
- 竞速请求（取最快响应结果）

## 手写代码实现Promise.allSettled

以下是 `Promise.allSettled` 的手动实现，核心思路是 **收集所有 Promise 的结果（无论成功/失败）**，并在全部完成后返回结果数组：

```javascript
function promiseAllSettled(promises) {
  return new Promise((resolve) => {
    // 空数组直接返回
    if (promises.length === 0) {
      resolve([]);
      return;
    }

    const results = new Array(promises.length); // 结果数组，保持顺序
    let completed = 0; // 完成计数器

    promises.forEach((promise, index) => {
      // 处理非 Promise 值（如数字、普通对象）
      Promise.resolve(promise)
        .then(value => {
          results[index] = { status: 'fulfilled', value };
        })
        .catch(reason => {
          results[index] = { status: 'rejected', reason };
        })
        .finally(() => {
          completed++;
          // 全部完成时 resolve
          if (completed === promises.length) {
            resolve(results);
          }
        });
    });
  });
}
```

**实现解析**

1. **统一处理输入**：
   - 使用 `Promise.resolve()` 包装每个元素，确保处理的是 Promise 对象。
   - 支持混合类型输入（如 `[42, fetch('/data')]`）。
2. **保持结果顺序**：
   - 通过 `index` 将结果存入数组对应位置，与输入顺序一致。
3. **完成计数器**：
   - 每个 Promise 完成后（无论成功/失败）触发 `finally`，计数器累加。
   - 当计数器等于输入数组长度时，返回最终结果。

## 使用Promise实现一个限制并发数的函数

```javascript
function limitConcurrency(tasks, max) {  
  return new Promise(resolve => {  
    let index = 0, active = 0, completed = 0;  
    const results = [];  

    function next() {  
      // 所有任务完成  
      if (completed === tasks.length) return resolve(results);  

      // 启动新任务（不超过最大并发数）  
      while (active < max && index < tasks.length) {  
        const current = index++;  
        active++;  
        const task = tasks[current];  
        Promise.resolve(task())  
          .then(res => results[current] = res)  
          .catch(err => results[current] = err)  
          .finally(() => {  
            active--;  
            completed++;  
            next(); // 触发下一个任务  
          });  
      }  
    }  

    next(); // 初始调用  
  });  
} 
```

## async/await 原理， 手写 async 函数？

**一、核心原理**

1. **生成器函数（Generator）**：
   `async` 函数被转换为生成器函数，`await` 对应 `yield`，用于暂停执行。
2. **自动执行器**：
   递归调用生成器的 `next()`，自动处理 `yield` 返回的 `Promise`，实现异步流程控制。

**二、手写 `async` 函数实现**

```javascript
function myAsync(generatorFn) {
  return function (...args) {
    const gen = generatorFn.apply(this, args); // 初始化生成器

    // 返回Promise，支持链式调用
    return new Promise((resolve, reject) => {
      // 递归处理生成器的 yield
      function step(key, arg) {
        let result;
        try {
          result = gen[key](arg); // 执行 next 或 throw
        } catch (error) {
          return reject(error); // 捕获同步错误
        }

        const { value, done } = result;
        if (done) {
          return resolve(value); // 生成器执行完毕，返回最终结果
        } else {
          // 统一转为Promise处理（支持非Promise值）
          return Promise.resolve(value).then(
            val => step("next", val), // 异步成功，继续下一步
            err => step("throw", err) // 异步失败，抛出错误
          );
        }
      }

      step("next"); // 启动执行
    });
  };
}
```

**三、使用示例**

```javascript
// 定义生成器函数（模拟 async 函数）
const asyncFunc = myAsync(function* () {
  try {
    const data1 = yield fetchData1(); // 模拟 await
    const data2 = yield fetchData2(data1);
    return data2;
  } catch (error) {
    console.log("捕获错误:", error);
  }
});

// 执行手写的 async 函数
asyncFunc().then(result => console.log("结果:", result));
```

**四、原理解析**

1. **生成器控制流程**：
   - `yield` 暂停执行，返回 `Promise`。
   - `next()` 恢复执行，并传入异步结果。
2. **错误处理**：
   - 通过 `try/catch` 包裹生成器方法调用，捕获同步错误。
   - 异步错误通过 `Promise.catch` 触发生成器的 `throw` 方法。
3. **自动递归**：
   - `step` 函数递归调用自身，直到生成器完成（`done: true`）

## 实现深拷贝

[深拷贝浅拷贝的区别？如何实现一个深拷贝？](#deepClone)

## 实现防抖节流

[什么是防抖和节流？有什么区别？如何实现？](#throttled-and-debounce)

## 实现数组去重

[你知道哪些数组去重方法？](#uniqueArray)

## 手写发布-订阅模式

```javascript
class EventEmitter {  
  constructor() {  
    this.events = {}; // 存储事件及回调 { event: [callback1, callback2] }  
  }  

  // 订阅事件  
  on(event, listener) {  
    if (!this.events[event]) this.events[event] = [];  
    this.events[event].push(listener);  
    // 返回取消订阅的函数  
    return () => this.off(event, listener);  
  }  

  // 取消订阅  
  off(event, listener) {  
    if (!this.events[event]) return;  
    const index = this.events[event].indexOf(listener);  
    if (index > -1) this.events[event].splice(index, 1);  
  }  

  // 触发事件  
  emit(event, ...args) {  
    if (!this.events[event]) return;  
    // 复制数组，避免回调中修改数组导致遍历错乱  
    this.events[event].slice().forEach(listener => listener(...args));  
  }  

  // 单次订阅  
  once(event, listener) {  
    const onceWrapper = (...args) => {  
      listener(...args);  
      this.off(event, onceWrapper); // 执行后自动移除  
    };  
    this.on(event, onceWrapper);  
  }  
} 
```

使用：

```javascript
const emitter = new EventEmitter();  

// 订阅  
const unsub = emitter.on('message', (msg) => console.log('收到消息：', msg));  
emitter.emit('message', 'Hello!'); // 输出：收到消息：Hello!  

// 取消订阅  
unsub();  
emitter.emit('message', '不再接收'); // 无输出  

// 单次订阅  
emitter.once('alert', () => console.log('仅触发一次'));  
emitter.emit('alert'); // 输出：仅触发一次  
emitter.emit('alert'); // 无输出  
```



## 手写观察者模式

```javascript
// 主题（被观察者）  
class Subject {  
  constructor() {  
    this.observers = []; // 观察者列表  
  }  

  // 添加观察者  
  addObserver(observer) {  
    if (observer && typeof observer.update === 'function') {  
      this.observers.push(observer);  
    }  
  }  

  // 移除观察者  
  removeObserver(observer) {  
    const index = this.observers.indexOf(observer);  
    if (index > -1) this.observers.splice(index, 1);  
  }  

  // 通知所有观察者  
  notify(data) {  
    this.observers.forEach(observer => observer.update(data));  
  }  
}  

// 观察者  
class Observer {  
  constructor(name) {  
    this.name = name;  
  }  

  // 定义统一的更新接口  
  update(data) {  
    console.log(`${this.name} 收到数据：`, data);  
  }  
}  
```

使用：

```javascript
// 创建主题  
const subject = new Subject();  

// 创建观察者  
const observerA = new Observer('观察者A');  
const observerB = {  
  update: (data) => console.log('观察者B收到：', data)  
};  

// 添加观察者  
subject.addObserver(observerA);  
subject.addObserver(observerB);  

// 主题状态变化，触发通知  
subject.notify({ message: '状态更新' });  
// 输出：  
// 观察者A 收到数据： {message: '状态更新'}  
// 观察者B收到： {message: '状态更新'}  

// 移除观察者  
subject.removeObserver(observerB);  
subject.notify('第二次通知'); // 仅observerA接收  
```



## 实现一个 flatten 函数（数组扁平化）

[数组拍平](#flat)

## 如何实现数组的随机排序？

**方法 1：Fisher-Yates 洗牌算法**

```javascript
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1)); // 随机选取 0~i 的索引
    [array[i], array[j]] = [array[j], array[i]];    // 交换元素
  }
  return array;
}
```

**优点**：

- **均匀随机**：每个元素出现在每个位置的概率均等。
- **时间复杂度 O(n)**：高效，只需一次遍历。

**方法 2：Array.sort + Math.random（不推荐）**

```javascript
const shuffled = array.sort(() => Math.random() - 0.5);
```

**缺点**：

- **非均匀随机**：V8引擎的排序算法导致元素位置概率不均（如末尾元素更可能留在末尾）。
- **时间复杂度 O(n log n)**：性能较差。

## 实现获取文件扩展名

**方法1：split + pop（适合简单场景）**

```javascript
function getExtension(filename) {  
  // 处理无点或隐藏文件（如.gitignore）  
  const parts = filename.split('.');  
  return parts.length > 1 ? parts.pop() : '';  
}  

// 示例  
console.log(getExtension('image.jpg'));      // 'jpg'  
console.log(getExtension('archive.tar.gz')); // 'gz'  
console.log(getExtension('README'));         // ''  
console.log(getExtension('.env'));           // ''  
```

**方法2：正则表达式（精准高效）**

```javascript
function getExtension(filename) {  
  // 匹配最后一个点后的非点字符（直到字符串末尾）  
  const match = filename.match(/\.([^.]+)$/);  
  return match ? match[1] : '';  
}  

// 示例  
console.log(getExtension('file.min.js'));    // 'js'  
console.log(getExtension('image.JPEG'));     // 'JPEG'  
console.log(getExtension('no_extension'));   // ''  
```

## 为什么使用 setTimeout 实现 setInterval？怎么模拟？

**一、为什么用 `setTimeout` 替代 `setInterval`？**

1. **避免回调堆积**：
   - `setInterval` 会严格按间隔时间触发回调，若回调未完成，任务会堆积。
   - `setTimeout` 递归调用可确保下次回调在上次执行**完成后**再触发。
2. **动态调整间隔**：
   - 每次递归前可动态修改间隔（如网络请求失败时增加延迟）。
3. **精准控制启停**：
   - 通过闭包保存 `timer`，实现精准的取消逻辑。

**二、代码实现**

```javascript
function customInterval(callback, interval) {
  let timer = null;
  
  function execute() {
    callback();            // 执行回调
    timer = setTimeout(execute, interval); // 递归调用
  }
  
  timer = setTimeout(execute, interval);   // 首次触发
  return () => clearTimeout(timer);        // 返回清除函数
}

// 使用示例
const clear = customInterval(() => {
  console.log('执行任务');
}, 1000);

// 5秒后停止
setTimeout(() => clear(), 5000);
```

## 手写一个函数将 12345 格式化为货币形式（如 "12,345"）

**反向遍历法（手写循环）**

**原理**：从右往左每3位插入逗号

```javascript
function formatCurrency(num) {
  const str = num.toString();
  const [integerPart, decimalPart] = str.split('.');
  const decimal = decimalPart ? `.${decimalPart}` : ''; // 处理小数部分
  let sign = '';
  let integer = integerPart;

  // 处理负号
  if (integer.startsWith('-')) {
    sign = '-';
    integer = integer.slice(1);
  }

  let result = '';
  let count = 0;

  // 从右往左遍历整数部分，每三位插入逗号
  for (let i = integer.length - 1; i >= 0; i--) {
    result = integer[i] + result;
    count++;
    if (count % 3 === 0 && i !== 0) { // 避免在最左侧加逗号
      result = ',' + result;
    }
  }

  return sign + result + decimal;
}

// 测试用例
console.log(formatCurrency(12345));        // 输出 "12,345"
console.log(formatCurrency(123456789));    // 输出 "123,456,789"
console.log(formatCurrency(-12345.67));    // 输出 "-12,345.67"
console.log(formatCurrency(123));          // 输出 "123"
```

**正则表达式法（代码极简）**

**原理**：用正则匹配每三位数字前的位置

```javascript
function formatCurrency(num) {  
  return num.toString().replace(/-?\d+/g, m =>   
    m.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,')  
  );  
}  
// 示例：12345 → "12,345"，-123456 → "-123,456"  
```

**数组分割法（直观易懂）**

**原理**：将数字转为数组后反向插入逗号

```javascript
function formatCurrency(num) {  
  const str = Math.abs(num).toString().split('.');  
  const arr = str[0].split('').reverse();  
  for (let i = 3; i < arr.length; i += 4) {  
    arr.splice(i, 0, ',');  
  }  
  return (num < 0 ? '-' : '') +  
    arr.reverse().join('') +  
    (str[1] ? `.${str[1]}` : '');  
}  
```

**原生API法（生产推荐）**

**原理**：利用 `toLocaleString` 内置方法实现一个函数，将 hello-world 转换为驼峰命名（helloWorld）

```javascript
function formatCurrency(num) {  
  return num.toLocaleString('en-US');  
}  
// 示例：12345 → "12,345"，12345.67 → "12,345.67"  
```



## 如何实现一个无限累加的 add 函数？

```javascript
function add(n) {
  let sum = n;
  const fn = (m) => { sum += m; return fn; };
  fn.valueOf = () => sum;
  return fn;
}
add(1)(2)(3); // 输出 6
add(1)(2)(3)(4); // 输出 10
```

## 实现链式调用：设计一个对象支持 obj.add(1).subtract(2).getValue()

要实现链式调用，需确保每个方法返回对象本身（`this`），从而允许连续调用其他方法。以下是具体实现：

```javascript
class Calculator {
  constructor(initialValue = 0) {
    this.value = initialValue;
  }

  add(num) {
    this.value += num;
    return this; // 关键：返回实例以支持链式调用
  }

  subtract(num) {
    this.value -= num;
    return this;
  }

  getValue() {
    return this.value; // 终止链式调用，返回最终结果
  }
}

// 使用示例
const result = new Calculator()
  .add(1)    // 0 + 1 = 1
  .subtract(2) // 1 - 2 = -1
  .getValue(); // 返回 -1

console.log(result); // 输出: -1
```



## Vue项目中有封装过axios吗？怎么封装的？

**（1）创建Axios实例**

```js
// src/utils/request.js  
import axios from 'axios';  

const service = axios.create({  
  baseURL: process.env.VUE_APP_API_URL, // 环境变量配置  
  timeout: 10000  
});  
```

**（2）请求拦截器**

```js
service.interceptors.request.use(  
  config => {  
    // 添加Token、Content-Type等  
    config.headers.Authorization = localStorage.getItem('token');  
    return config;  
  },  
  error => Promise.reject(error)  
);  
```

**（3）响应拦截器**

```js
service.interceptors.response.use(  
  response => {  
    // 统一处理业务逻辑（如状态码判断）  
    const res = response.data;  
    if (res.code !== 200) {  
      alert(res.message);  
      return Promise.reject(res);  
    }  
    return res;  
  },  
  error => {  
    // 处理HTTP错误（如401跳登录）  
    if (error.response.status === 401) {  
      router.push('/login');  
    }  
    return Promise.reject(error);  
  }  
);  
```

**（4）封装请求方法**

```js
export const get = (url, params) => service.get(url, { params });  
export const post = (url, data) => service.post(url, data);  
// 导出其他方法（put、delete等）  
```

**3. 使用示例**

```js
// 组件中调用  
import { get, post } from '@/utils/request';  

get('/user', { id: 1 }).then(data => { ... });  
post('/login', { username, password }).then(...);  
```

## Vue3封装一个带缓存的 useFetch Hook（支持重复请求去重）

```javascript
import { ref, reactive } from 'vue';

type CacheItem = {
  data: any;
  timestamp: number;
};

type Options = {
  cacheTTL?: number; // 缓存有效时间（毫秒）
  immediate?: boolean; // 是否立即执行
};

const cache = reactive(new Map<string, CacheItem>());
const pendingRequests = new Map<string, Promise<any>>();

export function useFetch<T>(url: string, options: Options = {}) {
  const data = ref<T | null>(null);
  const error = ref<Error | null>(null);
  const loading = ref(false);
  const { cacheTTL = 60000, immediate = true } = options;

  // 生成唯一缓存键（可根据需求扩展参数哈希）
  const cacheKey = url; 

  // 核心请求方法
  const execute = async () => {
    // 重复请求去重逻辑
    if (pendingRequests.has(cacheKey)) {
      return pendingRequests.get(cacheKey);
    }

    // 缓存有效直接返回
    if (cache.has(cacheKey)) {
      const cached = cache.get(cacheKey)!;
      if (Date.now() - cached.timestamp < cacheTTL) {
        data.value = cached.data;
        return cached.data;
      }
    }

    try {
      loading.value = true;
      const request = fetch(url)
        .then(res => res.json())
        .then(res => {
          // 更新缓存
          cache.set(cacheKey, { 
            data: res, 
            timestamp: Date.now() 
          });
          data.value = res;
          return res;
        })
        .finally(() => {
          pendingRequests.delete(cacheKey);
          loading.value = false;
        });

      pendingRequests.set(cacheKey, request);
      return await request;
    } catch (err) {
      error.value = err as Error;
      cache.delete(cacheKey); // 失败时清除缓存
      throw err;
    }
  };

  // 立即执行
  if (immediate) execute();

  // 手动清除缓存方法
  const clearCache = () => cache.delete(cacheKey);

  return { data, error, loading, execute, clearCache };
}
```

使用：

```vue
<script setup>
import { useFetch } from './useFetch';

const { data, loading } = useFetch('/api/user', { 
  cacheTTL: 300000 // 缓存5分钟
});

// 手动触发请求（自动去重）
const refresh = () => execute();
</script>
```

**核心设计要点：**

1. **双重缓存策略**
   - **内存缓存**：`Map`存储已成功请求的数据
   - **请求中缓存**：`pendingRequests`避免重复发送相同请求
2. **自动缓存失效**
   通过`cacheTTL`控制缓存有效期，超时后自动重新请求
3. **智能去重机制**
   - 相同URL同时触发多次请求时，仅实际发送一次
   - 后续请求共享同一Promise结果
4. **灵活扩展点**
   - 可扩展`cacheKey`生成逻辑（如包含请求参数）
   - 可添加请求取消功能（结合`AbortController`）



## 实现一个JS 函数， 解析 url 参数， 返回一个对象

**方案 1：纯字符串分割（基础版**）

```javascript
function parseUrlParams(url) {
  const params = {};
  const query = url.split('?')[1] || '';
  query.split('&').forEach(pair => {
    const [key, val] = pair.split('=');
    if (key) {
      params[decodeURIComponent(key)] = decodeURIComponent(val || '');
    }
  });
  return params;
}
// 示例：'?name=John&age=30' → { name: 'John', age: '30' }
```

**优点**：代码简单，兼容性好
**缺点**：未处理数组参数（如 `?key=1&key=2`）



**方案 2：正则表达式（支持数组参数）**

```javascript
function parseUrlParams(url) {
  const params = {};
  url.replace(/[?&]([^=&#]+)=([^&#]*)/g, (_, key, val) => {
    key = decodeURIComponent(key);
    val = decodeURIComponent(val || '');
    params[key] = params[key] ? [].concat(params[key], val) : val;
  });
  return params;
}
// 示例：'?key=1&key=2' → { key: ['1', '2'] }
```

**优点**：支持重复键转为数组
**缺点**：正则复杂度高，需理解分组匹配



**方案 3：URLSearchParams API（现代浏览器**）

```javascript
function parseUrlParams(url) {
  const params = {};
  const searchParams = new URL(url).searchParams;
  searchParams.forEach((val, key) => {
    params[key] = searchParams.getAll(key).length > 1 
      ? searchParams.getAll(key) 
      : val;
  });
  return params;
}
// 示例：自动处理编码（如空格转为%20）
```

**优点**：原生 API 简洁，自动解码
**缺点**：需兼容性处理（IE 不支持）

## 实现日期格式化 format 函数

**1. 原生拼接法（手动补零）**

```javascript
function formatDate(date, format = 'yyyy-MM-dd HH:mm:ss') {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  const hours = date.getHours().toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  const seconds = date.getSeconds().toString().padStart(2, '0');
  
  return format
    .replace('yyyy', year)
    .replace('MM', month)
    .replace('dd', day)
    .replace('HH', hours)
    .replace('mm', minutes)
    .replace('ss', seconds);
}

// 使用示例
console.log(formatDate(new Date(), 'yyyy/MM/dd')); // 输出 "2023/09/28"
```

**2. Intl.DateTimeFormat（本地化支持）**

```JavaScript
function formatDate(date, locale = 'zh-CN', options = {}) {
  return new Intl.DateTimeFormat(locale, {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    ...options
  }).format(date);
}

// 使用示例
console.log(formatDate(new Date())); // 输出 "2023/09/28 14:30:45"（中文环境）
console.log(formatDate(new Date(), 'en-US')); // "9/28/2023, 2:30:45 PM"
```

**3. 正则替换法（灵活自定义）**

```JavaScript
function formatDate(date, format = 'yyyy-MM-dd') {
  const map = {
    'y+': date.getFullYear(),                // 年
    'M+': date.getMonth() + 1,               // 月
    'd+': date.getDate(),                    // 日
    'H+': date.getHours(),                   // 时（24小时制）
    'm+': date.getMinutes(),                 // 分
    's+': date.getSeconds(),                 // 秒
    'S': date.getMilliseconds()              // 毫秒
  };

  for (const [key, value] of Object.entries(map)) {
    const regex = new RegExp(`(${key})`);
    if (regex.test(format)) {
      const str = value.toString().padStart(2, '0');
      format = format.replace(regex, str);
    }
  }
  return format;
}

// 使用示例
console.log(formatDate(new Date(), 'yyyy年MM月dd日 HH时mm分')); 
// 输出 "2023年09月28日 14时30分"
```

## 实现版本号排序

```javascript
function sortVersionsEnhanced(versions) {
  return versions.sort((a, b) => {
    const splitPart = (part) => 
      part.split(/(\d+)/) // 拆分数字和非数字部分
          .filter(Boolean)
          .map(s => isNaN(s) ? s : parseInt(s));

    const aParts = splitPart(a);
    const bParts = splitPart(b);

    const maxLength = Math.max(aParts.length, bParts.length);
    
    for (let i = 0; i < maxLength; i++) {
      const aVal = i < aParts.length ? aParts[i] : null;
      const bVal = i < bParts.length ? bParts[i] : null;

      if (aVal === bVal) continue;
      
      // 数字优先于非数字
      if (typeof aVal === 'number' && typeof bVal !== 'number') return -1;
      if (typeof bVal === 'number' && typeof aVal !== 'number') return 1;
      
      // 比较实际值
      return (aVal < bVal) ? -1 : 1;
    }
    return 0;
  });
}
```

