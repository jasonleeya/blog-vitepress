---
category: 笔试题
order: 9
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 笔试题


## 实现交换两个变量

JavaScript交换两个变量的常用方法：

1. **临时变量法**（通用性强，推荐）：

   ```javascript
   let a = 1, b = 2;  
   let temp = a;  
   a = b;  
   b = temp;  
   console.log(a, b); // 输出 2 1  
   ```

2. **解构赋值法**（ES6+，简洁）：

   ```javascript
   [a, b] = [b, a]; // 直接交换  
   ```

3. **数学运算法**（仅限数值类型）：

   ```javascript
   a = a + b;  
   b = a - b;  
   a = a - b;  
   ```

4. **位运算异或法**（仅限整数）：

   ```javascript
   a = a ^ b;  
   b = a ^ b;  
   a = a ^ b; 
   ```

## 简单实现 Promise

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending'; // 状态：pending/fulfilled/rejected
    this.value = undefined; // 成功值
    this.reason = undefined; // 失败原因
    this.onFulfilledCallbacks = []; // 成功回调队列
    this.onRejectedCallbacks = []; // 失败回调队列

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn()); // 执行异步回调
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn()); // 执行异步回调
      }
    };

    try {
      executor(resolve, reject); // 立即执行执行器函数
    } catch (err) {
      reject(err); // 捕获同步错误
    }
  }

  then(onFulfilled, onRejected) {
    // 处理值穿透（then() 无参数时传递值）
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err; };

    const promise2 = new MyPromise((resolve, reject) => {
      const handleFulfilled = () => {
        setTimeout(() => { // 确保异步执行
          try {
            const x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        }, 0);
      };

      const handleRejected = () => {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        }, 0);
      };

      if (this.state === 'fulfilled') {
        handleFulfilled();
      } else if (this.state === 'rejected') {
        handleRejected();
      } else { // pending 状态时存储回调
        this.onFulfilledCallbacks.push(handleFulfilled);
        this.onRejectedCallbacks.push(handleRejected);
      }
    });

    return promise2; // 返回新 Promise 实现链式调用
  }
}

// 处理 then 返回值的解析（支持返回 Promise 或普通值）
function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) { // 禁止循环引用
    return reject(new TypeError('Chaining cycle detected'));
  }
  if (x instanceof MyPromise) { // 递归解析 Promise
    x.then(resolve, reject);
  } else {
    resolve(x);
  }
}
```

## 如何用 Promise 实现超时控制？

**1. 基础实现：超时抛出错误**

```javascript
function timeoutPromise(promise, timeout) {  
  // 创建超时 Promise，到达时间后 reject  
  const timeoutP = new Promise((_, reject) => {  
    setTimeout(() => reject(new Error('请求超时')), timeout);  
  });  

  // 返回竞速结果  
  return Promise.race([promise, timeoutP]);  
}  

// 使用示例  
const fetchData = fetch('https://api.example.com');  
timeoutPromise(fetchData, 5000)  
  .then(res => console.log('成功:', res))  
  .catch(err => console.error('失败:', err));  
```

**2. 结合 AbortController 取消实际请求（如 fetch）**

```javascript
function fetchWithTimeout(url, timeout = 5000) {  
  const controller = new AbortController();  
  const timeoutId = setTimeout(() => controller.abort(), timeout);  

  return fetch(url, { signal: controller.signal })  
    .finally(() => clearTimeout(timeoutId)); // 清理定时器  
}  

// 使用：超时后自动取消请求  
fetchWithTimeout('https://api.example.com', 3000)  
  .catch(err => {  
    if (err.name === 'AbortError') console.log('请求超时');  
    else console.error('其他错误:', err);  
  });  
```

## 手写代码实现 Promise.all

手写 `Promise.all` 的核心在于**并发执行所有Promise**，并**按顺序收集结果**，遇到失败立即终止。以下是实现代码及解析：

```javascript
function myPromiseAll(promises) {  
  return new Promise((resolve, reject) => {  
    // 1. 校验输入是否为可迭代对象  
    if (typeof promises?.[Symbol.iterator] !== 'function') {  
      return reject(new TypeError('Argument is not iterable'));  
    }  
    const results = [];  
    let count = 0;  
    // 2. 处理空数组直接返回  
    if (promises.length === 0) return resolve(results);  

    promises.forEach((item, index) => {  
      // 3. 统一转Promise处理非Promise值  
      Promise.resolve(item)  
        .then((value) => {  
          results[index] = value; // 按索引存储结果  
          if (++count === promises.length) resolve(results);  
        })  
        .catch(reject); // 4. 任意失败立即reject  
    });  
  });  
}  
```

**关键点解释**：

- **输入校验**：通过 `Symbol.iterator` 判断是否可迭代（如数组、Set）。
- **结果顺序**：利用闭包中的 `index` 确保结果顺序与输入一致。
- **并发执行**：`forEach` 立即启动所有Promise，无需等待前一个完成。
- **错误处理**：首个失败直接触发 `reject`，其他Promise继续执行但不处理结果。

**测试用例**：

```javascript
// 成功场景  
myPromiseAll([1, Promise.resolve(2), Promise.resolve(3)])  
  .then(console.log); // 输出 [1, 2, 3]  

// 失败场景  
myPromiseAll([Promise.reject('error'), Promise.resolve(2)])  
  .catch(console.log); // 输出 'error'  
```

**与原生的差异**：

- **行为一致**：所有Promise立即执行，无法取消。
- **边界处理**：对非Promise值的转换（`Promise.resolve`）逻辑相同。

## 手写代码实现 Promise.race

手写 `Promise.race` 的核心在于**监听所有Promise，首个完成（无论成功/失败）的结果决定最终状态**。以下是实现代码及解析：

```javascript
function myPromiseRace(promises) {  
  return new Promise((resolve, reject) => {  
    // 1. 校验输入是否为可迭代对象  
    if (typeof promises?.[Symbol.iterator] !== 'function') {  
      return reject(new TypeError('Argument is not iterable'));  
    }  
    // 2. 遍历每个Promise，监听首个结果  
    for (const item of promises) {  
      // 3. 统一转Promise处理非Promise值  
      Promise.resolve(item)  
        .then(resolve)  // 首个resolve触发外层成功  
        .catch(reject); // 首个reject触发外层失败  
    }  
  });  
}  
```

**关键点解释**：

- **立即执行**：所有Promise同时启动，竞争执行。
- **首个完成优先**：无论是成功（`resolve`）还是失败（`reject`），首个完成的Promise直接决定最终状态。
- **非Promise处理**：通过 `Promise.resolve` 包装确保统一处理（如数值、普通对象）。

**测试用例**：

```javascript
// 成功场景（首个为数值）  
myPromiseRace([1, new Promise(res => setTimeout(res, 100, 2))])  
  .then(console.log); // 输出 1  

// 失败场景  
myPromiseRace([  
  new Promise((_, rej) => setTimeout(rej, 50, 'error1')),  
  new Promise((_, rej) => setTimeout(rej, 10, 'error2'))  
]).catch(console.log); // 输出 'error2'（更快完成）  

// 混合类型  
myPromiseRace([Promise.resolve('fast'), 42])  
  .then(console.log); // 输出 'fast'  
```

**与原生的差异**：

- **行为一致**：所有Promise立即执行且不可取消。
- **边界处理**：空输入直接返回 `pending` 状态的Promise（需调用方自行处理）。

**适用场景**：

- 接口超时控制（如与 `setTimeout` 结合）
- 竞速请求（取最快响应结果）

## 手写代码实现 Promise.allSettled

以下是 `Promise.allSettled` 的手动实现，核心思路是 **收集所有 Promise 的结果（无论成功/失败）**，并在全部完成后返回结果数组：

```javascript
function promiseAllSettled(promises) {
  return new Promise((resolve) => {
    // 空数组直接返回
    if (promises.length === 0) {
      resolve([]);
      return;
    }

    const results = new Array(promises.length); // 结果数组，保持顺序
    let completed = 0; // 完成计数器

    promises.forEach((promise, index) => {
      // 处理非 Promise 值（如数字、普通对象）
      Promise.resolve(promise)
        .then(value => {
          results[index] = { status: 'fulfilled', value };
        })
        .catch(reason => {
          results[index] = { status: 'rejected', reason };
        })
        .finally(() => {
          completed++;
          // 全部完成时 resolve
          if (completed === promises.length) {
            resolve(results);
          }
        });
    });
  });
}
```

**实现解析**

1. **统一处理输入**：
   - 使用 `Promise.resolve()` 包装每个元素，确保处理的是 Promise 对象。
   - 支持混合类型输入（如 `[42, fetch('/data')]`）。
2. **保持结果顺序**：
   - 通过 `index` 将结果存入数组对应位置，与输入顺序一致。
3. **完成计数器**：
   - 每个 Promise 完成后（无论成功/失败）触发 `finally`，计数器累加。
   - 当计数器等于输入数组长度时，返回最终结果。

## 实现 Promise 的 then 方法

实现 `then` 方法需要返回一个新的 Promise，并根据前一个 Promise 的状态调用 `onFulfilled` 或 `onRejected`。关键步骤：

1. **返回新 Promise**：支持链式调用。
2. **处理异步结果**：用 `setTimeout` 或微任务模拟事件循环。
3. **穿透值/错误**：若 `onFulfilled`/`onRejected` 不是函数，默认透传结果。
4. **处理回调返回值**：递归解析返回值是否为 Promise（例如 `resolvePromise` 函数）。

**示例核心代码：**

```javascript
then(onFulfilled, onRejected) {
  const newPromise = new MyPromise((resolve, reject) => {
    const handle = (callback, value) => {
      queueMicrotask(() => {
        try {
          const res = typeof callback === 'function' ? callback(value) : value;
          resolvePromise(newPromise, res, resolve, reject);
        } catch (err) {
          reject(err);
        }
      });
    };
    if (this.state === FULFILLED) handle(onFulfilled, this.value);
    else if (this.state === REJECTED) handle(onRejected, this.reason);
    else { /* 处理 pending 状态 */ }
  });
  return newPromise;
}
```





## 使用 Promise 实现一个限制并发数的函数

```javascript
function limitConcurrency(tasks, max) {  
  return new Promise(resolve => {  
    let index = 0, active = 0, completed = 0;  
    const results = [];  

    function next() {  
      // 所有任务完成  
      if (completed === tasks.length) return resolve(results);  

      // 启动新任务（不超过最大并发数）  
      while (active < max && index < tasks.length) {  
        const current = index++;  
        active++;  
        const task = tasks[current];  
        Promise.resolve(task())  
          .then(res => results[current] = res)  
          .catch(err => results[current] = err)  
          .finally(() => {  
            active--;  
            completed++;  
            next(); // 触发下一个任务  
          });  
      }  
    }  

    next(); // 初始调用  
  });  
} 
```

## async/await 原理， 手写 async 函数？

**一、核心原理**

1. **生成器函数（Generator）**：
   `async` 函数被转换为生成器函数，`await` 对应 `yield`，用于暂停执行。
2. **自动执行器**：
   递归调用生成器的 `next()`，自动处理 `yield` 返回的 `Promise`，实现异步流程控制。

**二、手写 `async` 函数实现**

```javascript
function myAsync(generatorFn) {
  return function (...args) {
    const gen = generatorFn.apply(this, args); // 初始化生成器

    // 返回Promise，支持链式调用
    return new Promise((resolve, reject) => {
      // 递归处理生成器的 yield
      function step(key, arg) {
        let result;
        try {
          result = gen[key](arg); // 执行 next 或 throw
        } catch (error) {
          return reject(error); // 捕获同步错误
        }

        const { value, done } = result;
        if (done) {
          return resolve(value); // 生成器执行完毕，返回最终结果
        } else {
          // 统一转为Promise处理（支持非Promise值）
          return Promise.resolve(value).then(
            val => step("next", val), // 异步成功，继续下一步
            err => step("throw", err) // 异步失败，抛出错误
          );
        }
      }

      step("next"); // 启动执行
    });
  };
}
```

**三、使用示例**

```javascript
// 定义生成器函数（模拟 async 函数）
const asyncFunc = myAsync(function* () {
  try {
    const data1 = yield fetchData1(); // 模拟 await
    const data2 = yield fetchData2(data1);
    return data2;
  } catch (error) {
    console.log("捕获错误:", error);
  }
});

// 执行手写的 async 函数
asyncFunc().then(result => console.log("结果:", result));
```

**四、原理解析**

1. **生成器控制流程**：
   - `yield` 暂停执行，返回 `Promise`。
   - `next()` 恢复执行，并传入异步结果。
2. **错误处理**：
   - 通过 `try/catch` 包裹生成器方法调用，捕获同步错误。
   - 异步错误通过 `Promise.catch` 触发生成器的 `throw` 方法。
3. **自动递归**：
   - `step` 函数递归调用自身，直到生成器完成（`done: true`）

## 实现深拷贝

实现深拷贝需递归遍历对象属性，处理循环引用和不同数据类型。关键步骤：

1. **基础类型直接返回**
2. **引用类型递归拷贝**
   - 区分数组和对象
   - 用 `WeakMap` 缓存已拷贝对象，解决循环引用
3. **处理特殊对象**（如 `Date`、`RegExp`，需单独处理）

**示例代码：**

```javascript
function deepClone(target, map = new WeakMap()) {
  if (typeof target !== 'object' || target === null) return target;
  if (map.has(target)) return map.get(target);

  // 处理特殊对象
  if (target instanceof Date) return new Date(target);
  if (target instanceof RegExp) return new RegExp(target);
  
  // 处理 Map
  if (target instanceof Map) {
    const clone = new Map();
    map.set(target, clone);
    target.forEach((v, k) => clone.set(deepClone(k, map), deepClone(v, map)));
    return clone;
  }

  // 处理 Set
  if (target instanceof Set) {
    const clone = new Set();
    map.set(target, clone);
    target.forEach(v => clone.add(deepClone(v, map)));
    return clone;
  }

  // 处理对象/数组（含 Symbol 属性）
  const clone = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  map.set(target, clone);
  Reflect.ownKeys(target).forEach(key => {
    clone[key] = deepClone(target[key], map);
  });

  return clone;
}
```



## 实现防抖节流

**一、防抖（Debounce）**

**防抖**是指在一定时间内，只有最后一次调用函数才会被执行。实现思路是使用定时器延迟执行，若期间再次调用则重置定时器。

**代码实现**：

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 使用示例：搜索框输入联想
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce(handleSearch, 300));
```

**二、节流（Throttle）**

**节流**是指在一定时间内，函数只能被调用一次。实现思路是通过时间戳或定时器控制函数执行频率。

**代码实现（时间戳版）**：

```javascript
function throttle(fn, limit) {
  let lastExecTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastExecTime >= limit) {
      fn.apply(this, args);
      lastExecTime = now;
    }
  };
}

// 使用示例：滚动加载更多
window.addEventListener('scroll', throttle(loadMoreData, 500));
```

**代码实现（定时器版）**：

```javascript
function throttle(fn, limit) {
  let timer = null;
  return function(...args) {
    if (!timer) {
      fn.apply(this, args);
      timer = setTimeout(() => (timer = null), limit);
    }
  };
}
```

## 手写 bind, call, apply 函数

**实现 `call` 方法**

`call` 方法允许指定函数的 `this` 上下文并立即执行。

```javascript
Function.prototype.myCall = function(context = window, ...args) {
  const fnSymbol = Symbol();
  context[fnSymbol] = this; // 将函数挂载到上下文对象
  const result = context[fnSymbol](...args); // 执行函数
  delete context[fnSymbol]; // 移除临时属性
  return result;
};
```

**实现 `apply` 方法**

`apply` 与 `call` 类似，但参数以数组形式传递。

```javascript
Function.prototype.myApply = function(context = window, args = []) {
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};
```

**实现 `bind` 方法**

`bind` 方法创建一个新函数，在调用时设置 `this` 上下文并预设参数。

```javascript
Function.prototype.myBind = function(context = window, ...args) {
  const self = this;
  return function(...newArgs) {
    return self.apply(context, [...args, ...newArgs]);
  };
};
```

**关键点解释**

1. **`call`/`apply`**：
   - 通过 `Symbol` 创建唯一属性名，避免覆盖上下文原有属性。
   - 利用对象方法的 `this` 指向对象本身的特性调用函数。
2. **`bind`**：
   - 返回一个新函数，支持柯里化（预设参数）。
   - 使用 `apply` 绑定 `this` 并合并参数。

## 实现数组去重

1. **利用 Set 数据结构**：
   **总结**：利用 Set 数据结构中元素的唯一性来实现数组去重，简单高效。
   **具体描述**：将数组转换为 Set 集合，由于 Set 中不能有重复元素，再将 Set 转换回数组。
   **代码实现**：

    ```javascript
    const arr = [1, 2, 3, 2, 1];
    const uniqueArr = Array.from(new Set(arr));
    console.log(uniqueArr);
    ```

2. **双重循环遍历**：
   **总结**：通过双重循环，内层循环检查元素是否重复，外层循环遍历数组，移除重复元素。
   **具体描述**：外层循环从第一个元素开始，内层循环从外层循环的下一个元素开始，比较元素是否相等，若相等则移除内层循环的元素。
   **代码实现**：

   ```javascript
   const arr = [1, 2, 3, 2, 1];
   for (let i = 0; i < arr.length; i++) {
       for (let j = i + 1; j < arr.length; j++) {
           if (arr[i] === arr[j]) {
               arr.splice(j, 1);
               j--;
           }
       }
   }
   console.log(arr);
   ```

3. **利用 `indexOf` 方法**：
   **总结**：遍历数组，使用 `indexOf` 方法判断元素在新数组中的位置，若 `indexOf` 返回 -1 则说明元素不重复，添加到新数组。
   **具体描述**：创建一个空数组，遍历原数组，对于每个元素，检查它在新数组中的 `indexOf` 是否为 -1 ，如果是则将其添加到新数组。
   **代码实现**：

   ```javascript
   const arr = [1, 2, 3, 2, 1];
   const newArr = [];
   for (let i = 0; i < arr.length; i++) {
       if (newArr.indexOf(arr[i]) === -1) {
           newArr.push(arr[i]);
       }
   }
   console.log(newArr);
   ```

   

4. **利用 `filter` 方法和 `indexOf`**：
   **总结**：使用 `filter` 方法结合 `indexOf` 来过滤掉重复元素。
   **具体描述**：`filter` 方法会对数组的每个元素执行回调函数，在回调函数中通过 `indexOf` 判断元素在原数组中的索引和当前索引是否相同，相同则保留该元素。
   **代码实现**：

   ```javascript
   const arr = [1, 2, 3, 2, 1];
   const unique = arr.filter((item, index) => arr.indexOf(item) === index);
   console.log(unique);
   ```

   

## 实现数组扁平化

- Array.prototype.flat(depth)

```javascript
  let newArray = arr.flat(Infinity)
```

- 迭代

```javascript
function flatten(array) {
  const result = [];
  const stack = [array];
  while (stack.length > 0) {
    const item = stack.pop();
    if (Array.isArray(item)) {
      for (let i = item.length - 1; i >= 0; i--) {
        stack.push(item[i]);
      }
    } else {
      result.push(item);
    }
  }
  return result.reverse();
}
```

- 递归

```javascript
function arrayFlat(arr) {
  let result = []
  arr.forEach(item => {
    if (item instanceof Array) {
      result = result.concat(arrayFlat(item))
    } else {
      result.push(item)
    }
  })
  return result
}

function arrayFlat2(arr) {
  return arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? arrayFlat2(cur) : cur), [])
}
```

- 简单情况toString

```javascript
function arrayFlat(arr) {
  return arr.toString().split(',').map(item=>parseInt(item))
}
```

## 手写发布-订阅模式

```javascript
class EventEmitter {  
  constructor() {  
    this.events = {}; // 存储事件及回调 { event: [callback1, callback2] }  
  }  

  // 订阅事件  
  on(event, listener) {  
    if (!this.events[event]) this.events[event] = [];  
    this.events[event].push(listener);  
    // 返回取消订阅的函数  
    return () => this.off(event, listener);  
  }  

  // 取消订阅  
  off(event, listener) {  
    if (!this.events[event]) return;  
    const index = this.events[event].indexOf(listener);  
    if (index > -1) this.events[event].splice(index, 1);  
  }  

  // 触发事件  
  emit(event, ...args) {  
    if (!this.events[event]) return;  
    // 复制数组，避免回调中修改数组导致遍历错乱  
    this.events[event].slice().forEach(listener => listener(...args));  
  }  

  // 单次订阅  
  once(event, listener) {  
    const onceWrapper = (...args) => {  
      listener(...args);  
      this.off(event, onceWrapper); // 执行后自动移除  
    };  
    this.on(event, onceWrapper);  
  }  
} 
```

使用：

```javascript
const emitter = new EventEmitter();  

// 订阅  
const unsub = emitter.on('message', (msg) => console.log('收到消息：', msg));  
emitter.emit('message', 'Hello!'); // 输出：收到消息：Hello!  

// 取消订阅  
unsub();  
emitter.emit('message', '不再接收'); // 无输出  

// 单次订阅  
emitter.once('alert', () => console.log('仅触发一次'));  
emitter.emit('alert'); // 输出：仅触发一次  
emitter.emit('alert'); // 无输出  
```



## 手写观察者模式

```javascript
// 主题（被观察者）  
class Subject {  
  constructor() {  
    this.observers = []; // 观察者列表  
  }  

  // 添加观察者  
  addObserver(observer) {  
    if (observer && typeof observer.update === 'function') {  
      this.observers.push(observer);  
    }  
  }  

  // 移除观察者  
  removeObserver(observer) {  
    const index = this.observers.indexOf(observer);  
    if (index > -1) this.observers.splice(index, 1);  
  }  

  // 通知所有观察者  
  notify(data) {  
    this.observers.forEach(observer => observer.update(data));  
  }  
}  

// 观察者  
class Observer {  
  constructor(name) {  
    this.name = name;  
  }  

  // 定义统一的更新接口  
  update(data) {  
    console.log(`${this.name} 收到数据：`, data);  
  }  
}  
```

使用：

```javascript
// 创建主题  
const subject = new Subject();  

// 创建观察者  
const observerA = new Observer('观察者A');  
const observerB = {  
  update: (data) => console.log('观察者B收到：', data)  
};  

// 添加观察者  
subject.addObserver(observerA);  
subject.addObserver(observerB);  

// 主题状态变化，触发通知  
subject.notify({ message: '状态更新' });  
// 输出：  
// 观察者A 收到数据： {message: '状态更新'}  
// 观察者B收到： {message: '状态更新'}  

// 移除观察者  
subject.removeObserver(observerB);  
subject.notify('第二次通知'); // 仅observerA接收  
```



## 手写一个响应式数据系统

基于 **Object.defineProperty** 和 **发布 - 订阅模式**：

```javascript
// 存储依赖的全局容器
const targetMap = new WeakMap();
let activeEffect = null;

// 1. 依赖收集函数
function track(target, key) {
  if (activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = new Set()));
    }
    dep.add(activeEffect); // 将当前副作用函数添加到依赖集合
  }
}

// 2. 触发更新函数
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const dep = depsMap.get(key);
  if (dep) {
    dep.forEach(effect => effect()); // 执行所有依赖的副作用函数
  }
}

// 3. 响应式对象创建函数
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver);
      track(target, key); // 读取属性时收集依赖
      return result;
    },
    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);
      if (oldValue !== value) {
        trigger(target, key); // 值变化时触发更新
      }
      return result;
    }
  });
}

// 4. 副作用函数注册
function effect(fn) {
  activeEffect = fn;
  fn(); // 执行副作用函数，触发依赖收集
  activeEffect = null;
}

// 使用示例
const state = reactive({ count: 0 });

effect(() => {
  console.log('Count changed:', state.count);
});

state.count++; // 输出: Count changed: 1
state.count = 10; // 输出: Count changed: 10
```

**关键点解释**

1. **依赖收集机制**：
   - 使用 `WeakMap` 存储对象与依赖的映射关系
   - 每个属性对应一个 `Set` 集合，存储依赖的副作用函数
2. **Proxy 代理**：
   - 通过 `get` 拦截读取操作，调用 `track()` 收集依赖
   - 通过 `set` 拦截写入操作，调用 `trigger()` 触发更新
3. **副作用函数**：
   - `effect()` 注册需要响应式执行的函数
   - 执行时会将当前函数设为 `activeEffect`，从而被依赖收集
4. **发布 - 订阅模式**：
   - 当属性值变化时，通知所有依赖的副作用函数重新执行

**进阶实现（Vue 3 风格）**

如果需要更接近 Vue 3 的实现，可以增加 `ref` 和 `computed` 支持：

```javascript
// ref 实现
function ref(initialValue) {
  return reactive({ value: initialValue });
}

// computed 实现
function computed(getter) {
  const result = ref();
  effect(() => {
    result.value = getter();
  });
  return result;
}

// 使用示例
const count = ref(0);
const double = computed(() => count.value * 2);

effect(() => {
  console.log('Double:', double.value);
});

count.value++; // 输出: Double: 2
```



这个简化版展示了响应式系统的核心原理，实际框架中还需处理嵌套对象、数组变异方法、异步更新队列等复杂场景。

## 手写一个简易模板引擎

**一、基础版本（正则替换）**

```javascript
function render(template, data) {
  // 匹配 {{variable}} 格式的占位符
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return data[key] !== undefined ? data[key] : '';
  });
}

// 使用示例
const template = 'Hello, {{name}}! You are {{age}} years old.';
const data = { name: 'Alice', age: 30 };
console.log(render(template, data)); 
// 输出: "Hello, Alice! You are 30 years old."
```

**二、进阶版本（支持简单表达式）**

增加对简单表达式（如三元运算符）的支持：

```javascript
function render(template, data) {
  // 匹配 {{expression}} 格式的占位符
  return template.replace(/\{\{([^}]+)\}\}/g, (match, expr) => {
    try {
      // 使用 with 语句将数据注入作用域
      return new Function('data', `with(data) { return ${expr} }`)(data);
    } catch (e) {
      return ''; // 表达式错误时返回空字符串
    }
  });
}

// 使用示例
const template = 'Hello, {{name || "Guest"}}! You are {{age >= 18 ? "adult" : "minor"}}.';
const data = { name: 'Bob', age: 25 };
console.log(render(template, data)); 
// 输出: "Hello, Bob! You are adult."
```

**三、高级版本（预编译函数）**

将模板编译为 JavaScript 函数，提高性能：

```javascript
function compile(template) {
  // 将模板转换为函数体字符串
  const body = `with(data) { 
    return \`${template
      .replace(/`/g, '\\`') // 转义反引号
      .replace(/\{\{([^}]+)\}\}/g, '${$1}') // 替换占位符为 ES6 模板字符串语法
    }\`; 
  }`;

  return new Function('data', body); // 返回编译后的函数
}

// 使用示例
const template = 'Hello, {{name}}! You have {{messages.length}} messages.';
const render = compile(template);
const data = { name: 'Charlie', messages: ['Hi', 'Hello'] };
console.log(render(data)); 
// 输出: "Hello, Charlie! You have 2 messages."
```

**四、关键点解释**

1. **正则匹配**：
   - 使用 `/\{\{(\w+)\}\}/g` 匹配简单变量
   - 使用 `/\{\{([^}]+)\}\}/g` 匹配复杂表达式
2. **作用域注入**：
   - 通过 `with(data) {...}` 将数据对象注入函数作用域
   - 允许直接在表达式中访问数据属性
3. **预编译优化**：
   - 将模板转换为 JavaScript 函数体
   - 利用 ES6 模板字符串简化替换逻辑
4. **安全考虑**：
   - 实际生产环境中需对用户输入进行转义，防止 XSS 攻击
   - 复杂场景建议使用成熟库（如 Mustache、Handlebars）

**五、扩展功能**

1. **过滤器支持**：

   ```javascript
   // 模板中使用 {{name | uppercase}}
   const filters = {
     uppercase: str => str.toUpperCase()
   };
   
   // 在 render 函数中处理过滤器逻辑
   ```

2. **循环结构**：

   ```javascript
   // 模板语法示例
   const template = `
     <ul>
       {{#each items}}
         <li>{{this.name}}</li>
       {{/each}}
     </ul>
   `;
   ```

3. **条件判断**：

   ```javascript
   // 模板语法示例
   {{#if isLoggedIn}}
     Welcome back!
   {{else}}
     Please log in.
   {{/if}}
   ```

## 虚拟 DOM 原理是什么，手写一个简单的虚拟 DOM 实现

以下是一个简易模板引擎的实现，核心原理是通过正则匹配模板中的变量占位符，并替换为实际数据：

**一、基础版本（正则替换）**

```javascript
function render(template, data) {
  // 匹配 {{variable}} 格式的占位符
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return data[key] !== undefined ? data[key] : '';
  });
}

// 使用示例
const template = 'Hello, {{name}}! You are {{age}} years old.';
const data = { name: 'Alice', age: 30 };
console.log(render(template, data)); 
// 输出: "Hello, Alice! You are 30 years old."
```

**二、进阶版本（支持简单表达式）**

增加对简单表达式（如三元运算符）的支持：

```javascript
function render(template, data) {
  // 匹配 {{expression}} 格式的占位符
  return template.replace(/\{\{([^}]+)\}\}/g, (match, expr) => {
    try {
      // 使用 with 语句将数据注入作用域
      return new Function('data', `with(data) { return ${expr} }`)(data);
    } catch (e) {
      return ''; // 表达式错误时返回空字符串
    }
  });
}

// 使用示例
const template = 'Hello, {{name || "Guest"}}! You are {{age >= 18 ? "adult" : "minor"}}.';
const data = { name: 'Bob', age: 25 };
console.log(render(template, data)); 
// 输出: "Hello, Bob! You are adult."
```

**三、高级版本（预编译函数）**

将模板编译为 JavaScript 函数，提高性能：

```javascript
function compile(template) {
  // 将模板转换为函数体字符串
  const body = `with(data) { 
    return \`${template
      .replace(/`/g, '\\`') // 转义反引号
      .replace(/\{\{([^}]+)\}\}/g, '${$1}') // 替换占位符为 ES6 模板字符串语法
    }\`; 
  }`;

  return new Function('data', body); // 返回编译后的函数
}

// 使用示例
const template = 'Hello, {{name}}! You have {{messages.length}} messages.';
const render = compile(template);
const data = { name: 'Charlie', messages: ['Hi', 'Hello'] };
console.log(render(data)); 
// 输出: "Hello, Charlie! You have 2 messages."
```

**四、关键点解释**

1. **正则匹配**：
   - 使用 `/\{\{(\w+)\}\}/g` 匹配简单变量
   - 使用 `/\{\{([^}]+)\}\}/g` 匹配复杂表达式
2. **作用域注入**：
   - 通过 `with(data) {...}` 将数据对象注入函数作用域
   - 允许直接在表达式中访问数据属性
3. **预编译优化**：
   - 将模板转换为 JavaScript 函数体
   - 利用 ES6 模板字符串简化替换逻辑
4. **安全考虑**：
   - 实际生产环境中需对用户输入进行转义，防止 XSS 攻击
   - 复杂场景建议使用成熟库（如 Mustache、Handlebars）

**五、扩展功能**

1. **过滤器支持**：

   ```javascript
   // 模板中使用 {{name | uppercase}}
   const filters = {
     uppercase: str => str.toUpperCase()
   };
   
   // 在 render 函数中处理过滤器逻辑
   ```

2. **循环结构**：

   ```javascript
   // 模板语法示例
   const template = `
     <ul>
       {{#each items}}
         <li>{{this.name}}</li>
       {{/each}}
     </ul>
   `;
   ```

3. **条件判断**：

   ```javascript
   // 模板语法示例
   {{#if isLoggedIn}}
     Welcome back!
   {{else}}
     Please log in.
   {{/if}}
   ```

   

这个简易实现展示了模板引擎的核心原理，实际框架（如 Vue、React）的模板编译系统会更复杂，涉及虚拟 DOM、响应式更新等机制。

## 获取页面中所有标签的种类和数量

```html
<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-style=1.0">
  <title>获取页面中所有标签的种类和数量</title>
</head>

<body>
  <div id="app">
    <p>这是一个段落</p>
    <span>这是一个 span</span>
    <div>这是一个 div</div>
    <p>另一个段落</p>
  </div>
  <script>
    // 获取页面中所有元素
    const allElements = document.querySelectorAll('*');
    const tagCount = {};

    // 遍历所有元素，统计标签种类和数量
    allElements.forEach((element) => {
      const tagName = element.tagName;
      tagCount[tagName] = (tagCount[tagName] || 0) + 1;
    });

    // 输出结果
    for (const tag in tagCount) {
      console.log(`标签 ${tag} 的数量: ${tagCount[tag]}`);
    }
  </script>
</body>

</html>
```

## 实现一个只能输入金额的输入框

**通过输入校验、正则过滤及交互提示，限制金额格式（如两位小数、千分位）。**  

**具体实现过程：**  

1. **输入限制**：  
   - 设置 `input` 类型为 `text`，通过 `pattern` 或 `onInput` 事件拦截非法字符（非数字/小数点）。  
   - 示例正则：`/^\d*\.?\d{0,2}$/` 限制最多两位小数。  

2. **格式化处理**：  
   - 输入时自动补全格式（如 `12.3` → `12.30`），失焦后添加千分位（`1234.5` → `1,234.50`）。  
   - 使用库（如 `currency.js`）简化处理。  

3. **防错处理**：  
   - 禁止多个小数点（如输入第二个小数点时自动删除）。  
   - 开头输入 `0` 后自动处理（如 `012` → `12`，`0.` 保留）。  

**示例代码（React）：**  
```jsx  
const [value, setValue] = useState("");  

const handleChange = (e) => {  
  let val = e.target.value.replace(/[^\d.]/g, ""); // 去除非数字和小数点  
  val = val.replace(/\.{2,}/g, "."); // 禁止多个小数点  
  const parts = val.split(".");  
  if (parts.length > 1) {  
    val = `${parts[0]}.${parts[1].slice(0, 2)}`; // 限制两位小数  
  }  
  setValue(val);  
};  

// 失焦时格式化千分位  
const handleBlur = () => {  
  const num = parseFloat(value);  
  if (!isNaN(num)) {  
    setValue(num.toLocaleString(undefined, {  
      minimumFractionDigits: 2,  
      maximumFractionDigits: 2  
    }));  
  }  
};  

return (  
  <input   
    value={value}  
    onChange={handleChange}  
    onBlur={handleBlur}  
    placeholder="0.00"  
  />  
);  
```

**优化点**：  
- 支持快捷键（如粘贴时自动过滤）。  
- 移动端适配数字键盘（`inputmode="decimal"`）。  
- 错误提示（如输入字母时 toast 提示）。

## 实现图片懒加载

**通过监听图片进入视口动态加载，减少首次请求压力。**  

**实现过程：**  

1. **占位与属性替换**  
   - 用 `data-src` 代替 `src` 存储真实图片地址：  
     ```html  
     <img data-src="real-image.jpg" class="lazyload" />  
     ```
   - 初始加载占位图（可选）：  
     ```html  
     <img src="placeholder.jpg" data-src="real-image.jpg" />  
     ```

2. **视口检测（两种方案）**  
   **方案一：Intersection Observer（推荐）**  
   ```javascript  
   const observer = new IntersectionObserver((entries) => {  
     entries.forEach(entry => {  
       if (entry.isIntersecting) {  
         const img = entry.target;  
         img.src = img.dataset.src;  
         observer.unobserve(img); // 加载后停止观察  
       }  
     });  
   }, { rootMargin: "0px 0px 200px 0px" }); // 提前200px加载  
   
   document.querySelectorAll('.lazyload').forEach(img => observer.observe(img));  
   ```

   **方案二：scroll 事件 + 计算位置**  
   ```javascript  
   function checkLazyLoad() {  
     const imgs = document.querySelectorAll('.lazyload');  
     imgs.forEach(img => {  
       const rect = img.getBoundingClientRect();  
       if (rect.top < window.innerHeight + 200) {  
         img.src = img.dataset.src;  
         img.classList.remove('lazyload'); // 移除标记  
       }  
     });  
   }  
   
   // 使用节流优化  
   window.addEventListener('scroll', throttle(checkLazyLoad, 200));  
   window.addEventListener('load', checkLazyLoad);  
   ```

3. **优化扩展**  
   - **兼容性**：为旧浏览器添加 Intersection Observer polyfill  
   - **错误处理**：添加 `onerror` 事件统一处理加载失败  
   - **Native LazyLoad**：直接使用 `loading="lazy"` 属性（需注意浏览器兼容性）  
     ```html  
     <img src="image.jpg" loading="lazy" />  
     ```

**效果优先级**：  
原生 `loading="lazy"` > Intersection Observer > 滚动计算

## 实现一个轮播图组件

**通过动态切换内容与定时器控制，实现自动轮播及手动交互功能。**  

**实现过程：**  
1. **基础结构与样式**  
   - **HTML 布局**：  
     ```html  
     <div class="carousel-container">  
       <div class="carousel-track">  
         <!-- 图片列表 -->  
         <img src="img1.jpg" class="slide active" />  
         <img src="img2.jpg" class="slide" />  
         <img src="img3.jpg" class="slide" />  
       </div>  
       <!-- 指示点 -->  
       <div class="dots">  
         <span class="dot active"></span>  
         <span class="dot"></span>  
         <span class="dot"></span>  
       </div>  
       <!-- 左右按钮 -->  
       <button class="prev-btn">←</button>  
       <button class="next-btn">→</button>  
     </div>  
     ```
   - **CSS 关键样式**：  
     ```css  
     .carousel-container {  
       position: relative;  
       overflow: hidden;  
     }  
     .carousel-track {  
       display: flex;  
       transition: transform 0.5s ease-in-out; /* 滑动动画 */  
     }  
     .slide {  
       width: 100%;  
       flex-shrink: 0; /* 禁止压缩 */  
     }  
     .dots { /* 指示点定位 */  
       position: absolute;  
       bottom: 20px;  
       left: 50%;  
       transform: translateX(-50%);  
     }  
     ```

2. **核心交互逻辑（JavaScript）**  
   - **自动轮播**：  
     ```javascript  
     let currentIndex = 0;  
     const slides = document.querySelectorAll(".slide");  
     const track = document.querySelector(".carousel-track");  
     
     function autoPlay() {  
       setInterval(() => {  
         currentIndex = (currentIndex + 1) % slides.length;  
         updateSlide();  
       }, 3000);  
     }  
     ```

   - **手动切换（按钮/指示点）**：  
     ```javascript  
     function updateSlide() {  
       track.style.transform = `translateX(-${currentIndex * 100}%)`;  
       // 同步指示点状态  
       document.querySelectorAll(".dot").forEach((dot, index) => {  
         dot.classList.toggle("active", index === currentIndex);  
       });  
     }  
     
     // 按钮事件  
     document.querySelector(".next-btn").addEventListener("click", () => {  
       currentIndex = (currentIndex + 1) % slides.length;  
       updateSlide();  
     });  
     // 同理处理 prev-btn 和 dots 点击事件  
     ```

3. **优化扩展**  
   - **无限循环**：克隆首尾图片实现无缝衔接  
   - **暂停逻辑**：鼠标悬停时清除定时器  
     ```javascript  
     let timer;  
     function autoPlay() {  
       timer = setInterval(/*...*/);  
     }  
     carouselContainer.addEventListener("mouseenter", () => clearInterval(timer));  
     carouselContainer.addEventListener("mouseleave", autoPlay);  
     ```
   - **触摸滑动**：通过 `touchstart` 和 `touchend` 计算滑动方向  



**最终效果**：  
- 自动播放 + 手动切换（按钮/指示点）  
- 平滑过渡动画 + 悬停暂停  
- 支持响应式布局（CSS 媒体查询调整尺寸）


## 手写一个 Jsonp

**通过动态创建 script 标签绕过跨域限制，利用回调函数处理返回数据。**

**实现过程：**  
1. **定义全局回调函数**  
   ```javascript  
   function jsonp(url, params, callbackName = 'jsonpCallback') {  
     // 生成唯一回调函数名（防止冲突）  
     const uniqueName = `${callbackName}_${Date.now()}`;  
     window[uniqueName] = function(data) {  
       // 数据返回后的处理逻辑  
       callback(data);  
       // 清理资源  
       document.body.removeChild(script);  
       delete window[uniqueName];  
     };  
   
     // 拼接参数到URL  
     const query = new URLSearchParams({  
       ...params,  
       callback: uniqueName  // 约定后端接收的回调参数名（如callback）  
     }).toString();  
   
     // 创建并插入 script 标签  
     const script = document.createElement('script');  
     script.src = `${url}?${query}`;  
     document.body.appendChild(script);  
   
     // 错误处理（如请求失败）  
     script.onerror = () => {  
       callback(null, new Error('JSONP request failed'));  
       cleanup();  
     };  
   
     // 超时处理  
     const timeoutId = setTimeout(() => {  
       callback(null, new Error('Timeout'));  
       cleanup();  
     }, 5000);  
   
     // 清理函数  
     function cleanup() {  
       clearTimeout(timeoutId);  
       document.body.removeChild(script);  
       delete window[uniqueName];  
     }  
   }  
   ```

2. **调用示例**  
   ```javascript  
   jsonp(  
     'https://api.example.com/data',  
     { id: 123 },  
     (data, error) => {  
       if (error) console.error('Error:', error);  
       else console.log('Data:', data);  
     }  
   );  
   ```

**关键点说明：**  
- **跨域原理**：利用 `<script>` 标签的 `src` 无跨域限制特性  
- **服务端要求**：需返回类似 `jsonpCallback_1620000000000({...})` 的 JS 代码  
- **超时兜底**：避免因服务未响应导致内存泄漏  
- **兼容性**：支持所有浏览器，但只限 GET 请求  

**注意事项：**  
- 确保服务端支持 JSONP（动态拼接回调函数名）  
- 生产环境建议使用 Promise 封装+TS 类型校验  
- 安全性：仅限可信源，防止 XSS 攻击

## 封装一个 JavaScript 的类型判断函数

**简单实现**

```JavaScript
function getType(value) {  
  // 处理特殊类型：undefined 和 null  
  if (value === undefined) return 'undefined';  
  if (value === null) return 'null';  

  // 处理 NaN（需特殊判断）  
  if (typeof value === 'number' && Number.isNaN(value)) return 'nan';  

  // 通用类型判断（提取 [object Xxx] 中的 Xxx 并转小写）  
  const typeStr = Object.prototype.toString.call(value).slice(8, -1).toLowerCase();  

  // 兼容处理：Promise 等特殊对象  
  if (typeof value.then === 'function' && typeof value.catch === 'function') {  
    return 'promise';  
  }  

  return typeStr;  
}  

// 测试用例：  
getType({})             // -> "object"  
getType([])             // -> "array"  
getType(() => {})       // -> "function"  
getType(new Date())     // -> "date"  
getType(/regex/)        // -> "regexp"  
getType(Symbol())       // -> "symbol"  
getType(Promise.resolve()) // -> "promise"  
```

**完整封装，实现对更改`[Symbol.toStringTag]`后的判断（` Object.prototype.toString.call(value)`会输出更改后的字符串）**

```javascript
const TypeUtils = {
  // 基础类型判断（不受 Symbol.toStringTag 影响）
  isArray: (value) => Array.isArray(value),
  isDate: (value) => value instanceof Date,
  isRegExp: (value) => value instanceof RegExp,
  isPromise: (value) => value instanceof Promise || (value && typeof value.then === 'function'),
  isError: (value) => value instanceof Error || (value.message && value.stack),
  
  // 自定义类型检测（考虑 Symbol.toStringTag）
  getRealType: (value) => {
    if (value === null) return 'null';
    if (value === undefined) return 'undefined';
    if (typeof value !== 'object') return typeof value;
    
    // 内置对象检测（基于构造函数）
    if (TypeUtils.isArray(value)) return 'array';
    if (TypeUtils.isDate(value)) return 'date';
    if (TypeUtils.isRegExp(value)) return 'regexp';
    if (TypeUtils.isPromise(value)) return 'promise';
    if (TypeUtils.isError(value)) return 'error';
    if (value instanceof Map) return 'map';
    if (value instanceof Set) return 'set';
    
    // 自定义类实例
    if (value.constructor && value.constructor.name !== 'Object') {
      return value.constructor.name;
    }
    
    // 检查 Symbol.toStringTag
    const tag = value[Symbol.toStringTag];
    if (tag) return tag.toLowerCase();
    
    // 回退到默认检测
    return Object.prototype.toString.call(value)
      .match(/^\[object (\w+)\]$/)[1]
      .toLowerCase();
  },
  
  // 安全的类型比较（考虑原型链）
  isSameType: (a, b) => {
    const typeA = TypeUtils.getRealType(a);
    const typeB = TypeUtils.getRealType(b);
    return typeA === typeB;
  },
  
  // 防御性检测：忽略自定义 Symbol.toStringTag
  getConstructorType: (value) => {
    if (value === null || value === undefined) return String(value);
    if (typeof value !== 'object') return typeof value;
    
    // 通过构造函数获取类型（忽略 toStringTag）
    if (value.constructor) {
      return value.constructor.name || 'Object';
    }
    
    // 回退到默认
    return Object.prototype.toString.call(value)
      .match(/^\[object (\w+)\]$/)[1];
  }
};

```



## 实现一个 flatten 函数（数组扁平化）

1. **递归解法（默认完全展开）**  
   ```javascript  
   function flatten(arr, depth = Infinity) {  
     return arr.reduce((result, item) => {  
       // 当前深度未达到限制且是数组时继续递归  
       if (depth > 0 && Array.isArray(item)) {  
         return result.concat(flatten(item, depth - 1));  
       }  
       return result.concat(item);  
     }, []);  
   }  
   ```

2. **迭代解法（栈模拟递归，避免堆栈溢出）**  
   ```javascript  
   function flatten(arr, depth = Infinity) {  
     const stack = arr.map(item => ({ value: item, depth }));  
     const result = [];  
   
     while (stack.length) {  
       const { value, depth: currentDepth } = stack.pop();  
       if (Array.isArray(value) && currentDepth > 0) {  
         // 反向入栈保持顺序（用push+reverse或正向循环）  
         stack.push(...value.map(item => ({  
           value: item,  
           depth: currentDepth - 1  
         })).reverse();  
       } else {  
         result.unshift(value); // 从头部插入保持顺序  
       }  
     }  
     return result;  
   }  
   ```

3. **测试用例**  
   ```javascript  
   flatten([1, [2, [3, [4]], 5])   
   // 默认输出 [1, 2, 3, 4, 5]  
   
   flatten([1, [2, [3, [4]], 5], 1)  
   // 输出 [1, 2, [3, [4]], 5]  
   ```

**关键点说明：**  
- **深度控制**：通过参数 `depth` 支持按层展开  
- **顺序保留**：迭代解法中通过 `unshift` + `reverse` 维持原顺序  
- **性能对比**：  
  - 递归：代码简洁，但深度过大会堆栈溢出  
  - 迭代：适合大数据量，无堆栈限制  

**扩展优化：**  
- 支持类数组对象（如 `arguments`）  
- 添加循环引用检测（防止无限嵌套）


## 封装 WebSocket,实现心跳，断线重连等功能

```javascript  
class WS {  
  constructor(url, options = {}) {  
    this.url = url;  
    this.reconnectLimit = options.reconnectLimit || 3; // 最大重连次数  
    this.reconnectInterval = options.reconnectInterval || 5000; // 重连间隔  
    this.heartbeatInterval = options.heartbeatInterval || 30000; // 心跳间隔  
    this.heartbeatMsg = options.heartbeatMsg || '{"type":"ping"}';  
    this.messageQueue = []; // 待发送消息队列  
    this.reconnectCount = 0;  
    this.isManualClose = false; // 是否手动关闭  

    this.init();  
  }  

  // 初始化连接  
  init() {  
    this.ws = new WebSocket(this.url);  
    this.bindEvents();  
  }  

  // 绑定事件  
  bindEvents() {  
    this.ws.onopen = () => {  
      this.reconnectCount = 0; // 重置重连计数  
      this.startHeartbeat();  
      this.emit('open');  
      this.flushQueue(); // 发送队列中的消息  
    };  

    this.ws.onmessage = (e) => {  
      this.emit('message', e.data);  
      this.resetHeartbeat(); // 收到消息重置心跳  
    };  

    this.ws.onclose = (e) => {  
      if (!this.isManualClose && this.reconnectCount < this.reconnectLimit) {  
        setTimeout(() => this.reconnect(), this.reconnectInterval);  
      }  
      this.emit('close', e);  
    };  

    this.ws.onerror = (e) => {  
      this.emit('error', e);  
    };  
  }  

  // 自动重连  
  reconnect() {  
    this.reconnectCount++;  
    this.init();  
  }  

  // 心跳检测  
  startHeartbeat() {  
    this.heartbeatTimer = setInterval(() => {  
      this.send(this.heartbeatMsg);  
    }, this.heartbeatInterval);  
  }  

  resetHeartbeat() {  
    clearInterval(this.heartbeatTimer);  
    this.startHeartbeat();  
  }  

  // 发送消息（支持队列缓存）  
  send(data) {  
    if (this.ws.readyState === WebSocket.OPEN) {  
      this.ws.send(data);  
    } else {  
      this.messageQueue.push(data);  
    }  
  }  

  // 清空消息队列  
  flushQueue() {  
    while (this.messageQueue.length > 0) {  
      this.send(this.messageQueue.shift());  
    }  
  }  

  // 关闭连接（手动关闭不重连）  
  close() {  
    this.isManualClose = true;  
    this.ws.close();  
  }  

  // 事件监听（仿 EventEmitter）  
  on(event, callback) {  
    this._handlers = this._handlers || {};  
    (this._handlers[event] || (this._handlers[event] = [])).push(callback);  
    return this;  
  }  

  emit(event, ...args) {  
    (this._handlers[event] || []).forEach(fn => fn(...args));  
  }  
}  
```

**测试用例：**  
```javascript  
const ws = new WS('wss://echo.websocket.org', {  
  heartbeatInterval: 10000  
});  

ws.on('open', () => console.log('Connected!'))  
  .on('message', data => console.log('Received:', data))  
  .on('close', () => console.log('Disconnected!'));  

// 发送消息  
ws.send('Hello World');  

// 手动关闭  
setTimeout(() => ws.close, 10000);  
```


## 如何实现数组的随机排序？

**方法 1：Fisher-Yates 洗牌算法**

```javascript
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1)); // 随机选取 0~i 的索引
    [array[i], array[j]] = [array[j], array[i]];    // 交换元素
  }
  return array;
}
```

**优点**：

- **均匀随机**：每个元素出现在每个位置的概率均等。
- **时间复杂度 O(n)**：高效，只需一次遍历。

**方法 2：Array.sort + Math.random（不推荐）**

```javascript
const shuffled = array.sort(() => Math.random() - 0.5);
```

**缺点**：

- **非均匀随机**：V8引擎的排序算法导致元素位置概率不均（如末尾元素更可能留在末尾）。
- **时间复杂度 O(n log n)**：性能较差。

## 实现获取文件扩展名

**方法1：split + pop（适合简单场景）**

```javascript
function getExtension(filename) {  
  // 处理无点或隐藏文件（如.gitignore）  
  const parts = filename.split('.');  
  return parts.length > 1 ? parts.pop() : '';  
}  

// 示例  
console.log(getExtension('image.jpg'));      // 'jpg'  
console.log(getExtension('archive.tar.gz')); // 'gz'  
console.log(getExtension('README'));         // ''  
console.log(getExtension('.env'));           // ''  
```

**方法2：正则表达式（精准高效）**

```javascript
function getExtension(filename) {  
  // 匹配最后一个点后的非点字符（直到字符串末尾）  
  const match = filename.match(/\.([^.]+)$/);  
  return match ? match[1] : '';  
}  

// 示例  
console.log(getExtension('file.min.js'));    // 'js'  
console.log(getExtension('image.JPEG'));     // 'JPEG'  
console.log(getExtension('no_extension'));   // ''  
```

## 为什么使用 setTimeout 实现 setInterval？怎么模拟？

**一、为什么用 `setTimeout` 替代 `setInterval`？**

1. **避免回调堆积**：
   - `setInterval` 会严格按间隔时间触发回调，若回调未完成，任务会堆积。
   - `setTimeout` 递归调用可确保下次回调在上次执行**完成后**再触发。
2. **动态调整间隔**：
   - 每次递归前可动态修改间隔（如网络请求失败时增加延迟）。
3. **精准控制启停**：
   - 通过闭包保存 `timer`，实现精准的取消逻辑。

**二、代码实现**

```javascript
function customInterval(callback, interval) {
  let timer = null;
  
  function execute() {
    callback();            // 执行回调
    timer = setTimeout(execute, interval); // 递归调用
  }
  
  timer = setTimeout(execute, interval);   // 首次触发
  return () => clearTimeout(timer);        // 返回清除函数
}

// 使用示例
const clear = customInterval(() => {
  console.log('执行任务');
}, 1000);

// 5秒后停止
setTimeout(() => clear(), 5000);
```

## 手写一个函数将 12345 格式化为货币形式（如 "12,345"）

**反向遍历法（手写循环）**

**原理**：从右往左每3位插入逗号

```javascript
function formatCurrency(num) {
  const str = num.toString();
  const [integerPart, decimalPart] = str.split('.');
  const decimal = decimalPart ? `.${decimalPart}` : ''; // 处理小数部分
  let sign = '';
  let integer = integerPart;

  // 处理负号
  if (integer.startsWith('-')) {
    sign = '-';
    integer = integer.slice(1);
  }

  let result = '';
  let count = 0;

  // 从右往左遍历整数部分，每三位插入逗号
  for (let i = integer.length - 1; i >= 0; i--) {
    result = integer[i] + result;
    count++;
    if (count % 3 === 0 && i !== 0) { // 避免在最左侧加逗号
      result = ',' + result;
    }
  }

  return sign + result + decimal;
}

// 测试用例
console.log(formatCurrency(12345));        // 输出 "12,345"
console.log(formatCurrency(123456789));    // 输出 "123,456,789"
console.log(formatCurrency(-12345.67));    // 输出 "-12,345.67"
console.log(formatCurrency(123));          // 输出 "123"
```

**正则表达式法（代码极简）**

**原理**：用正则匹配每三位数字前的位置

```javascript
function formatCurrency(num) {  
  return num.toString().replace(/-?\d+/g, m =>   
    m.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,')  
  );  
}  
// 示例：12345 → "12,345"，-123456 → "-123,456"  
```

**数组分割法（直观易懂）**

**原理**：将数字转为数组后反向插入逗号

```javascript
function formatCurrency(num) {  
  const str = Math.abs(num).toString().split('.');  
  const arr = str[0].split('').reverse();  
  for (let i = 3; i < arr.length; i += 4) {  
    arr.splice(i, 0, ',');  
  }  
  return (num < 0 ? '-' : '') +  
    arr.reverse().join('') +  
    (str[1] ? `.${str[1]}` : '');  
}  
```

**原生API法（生产推荐）**

**原理**：利用 `toLocaleString` 内置方法实现一个函数，将 hello-world 转换为驼峰命名（helloWorld）

```javascript
function formatCurrency(num) {  
  return num.toLocaleString('en-US');  
}  
// 示例：12345 → "12,345"，12345.67 → "12,345.67"  
```

## 实现函数柯里化

```javascript
function curry(fn, ...args) {  
  // 获取原函数所需参数个数  
  const length = fn.length;  

  return function curried(...newArgs) {  
    // 合并已传入参数（支持占位符逻辑）  
    const combinedArgs = args.map(arg =>  
      arg === curry.placeholder && newArgs.length ? newArgs.shift() : arg  
    ).concat(newArgs);  

    // 计算有效参数数量（过滤占位符）  
    const validArgs = combinedArgs.filter(arg => arg !== curry.placeholder);  

    // 参数足够则执行，否则继续柯里化  
    if (validArgs.length >= length) {  
      return fn.apply(this, combinedArgs.slice(0, length));  
    } else {  
      return curry.call(this, fn, ...combinedArgs);  
    }  
  };  
}  

// 占位符定义（可选功能）  
curry.placeholder = Symbol();  

// 示例用法：  
const add = (a, b, c) => a + b + c;  
const curriedAdd = curry(add);  
curriedAdd(1)(2)(3); // 6  
curriedAdd(1, curry.placeholder)(2)(3); // 6（占位符场景）  
```



## 如何实现一个无限累加的 add 函数？

**利用闭包保存累加值，结合函数链式调用与隐式转换（toString/valueOf），实现无限累加。**  

**实现过程：**  

```javascript  
function add(initial) {  
  let sum = initial;  

  const adder = function (num) {  
    sum += num;  
    return adder; // 返回自身以支持链式调用  
  };  

  // 隐式转换触发时返回当前累加值  
  adder.toString = () => sum;  
  adder.valueOf = () => sum;  

  return adder;  
}  

// 测试示例  
console.log(add(1)(2)(3));         // 输出：6  
console.log(add(1)(2)(3)(4));      // 输出：10  
console.log(add(5)(-1)(3) + 10);   // 输出：17  
```

**关键点说明：**  
1. **闭包保存累加值**：通过 `sum` 变量持续累积每次调用传入的值。  
2. **链式调用**：每次调用返回函数自身（`adder`），支持无限链式调用。  
3. **隐式转换**：  
   - **`toString`**：在字符串上下文（如 `console.log`）中自动调用。  
   - **`valueOf`**：在数值运算（如 `+`、`-`）中自动调用。  

**扩展优化：**  
- **初始参数校验**：确保首个参数为数字（如 `if (typeof initial !== 'number') throw...`）。  
- **支持空调用**：若需允许 `add()(1)(2)` 形式，可设置默认初始值（如 `initial = 0`）。  
- **冻结最终值**：调用 `.done()` 方法返回最终结果（防止后续意外修改）。  
  ```javascript  
  adder.done = () => sum;  
  console.log(add(1)(2).done()); // 输出：3  
  ```

**适用场景**：简化链式累加逻辑，如动态计算总价、统计分步操作结果等。

## 实现链式调用：设计一个对象支持 obj.add(1).subtract(2).getValue()

要实现链式调用，需确保每个方法返回对象本身（`this`），从而允许连续调用其他方法。以下是具体实现：

```javascript
class Calculator {
  constructor(initialValue = 0) {
    this.value = initialValue;
  }

  add(num) {
    this.value += num;
    return this; // 关键：返回实例以支持链式调用
  }

  subtract(num) {
    this.value -= num;
    return this;
  }

  getValue() {
    return this.value; // 终止链式调用，返回最终结果
  }
}

// 使用示例
const result = new Calculator()
  .add(1)    // 0 + 1 = 1
  .subtract(2) // 1 - 2 = -1
  .getValue(); // 返回 -1

console.log(result); // 输出: -1
```



## Vue项目中有封装过 axios 吗？怎么封装的？

**（1）创建Axios实例**

```js
// src/utils/request.js  
import axios from 'axios';  

const service = axios.create({  
  baseURL: process.env.VUE_APP_API_URL, // 环境变量配置  
  timeout: 10000  
});  
```

**（2）请求拦截器**

```js
service.interceptors.request.use(  
  config => {  
    // 添加Token、Content-Type等  
    config.headers.Authorization = localStorage.getItem('token');  
    return config;  
  },  
  error => Promise.reject(error)  
);  
```

**（3）响应拦截器**

```js
service.interceptors.response.use(  
  response => {  
    // 统一处理业务逻辑（如状态码判断）  
    const res = response.data;  
    if (res.code !== 200) {  
      alert(res.message);  
      return Promise.reject(res);  
    }  
    return res;  
  },  
  error => {  
    // 处理HTTP错误（如401跳登录）  
    if (error.response.status === 401) {  
      router.push('/login');  
    }  
    return Promise.reject(error);  
  }  
);  
```

**（4）封装请求方法**

```js
export const get = (url, params) => service.get(url, { params });  
export const post = (url, data) => service.post(url, data);  
// 导出其他方法（put、delete等）  
```

**3. 使用示例**

```js
// 组件中调用  
import { get, post } from '@/utils/request';  

get('/user', { id: 1 }).then(data => { ... });  
post('/login', { username, password }).then(...);  
```

## Vue3封装一个带缓存的 useFetch Hook（支持重复请求去重）

```javascript
import { ref, reactive } from 'vue';

type CacheItem = {
  data: any;
  timestamp: number;
};

type Options = {
  cacheTTL?: number; // 缓存有效时间（毫秒）
  immediate?: boolean; // 是否立即执行
};

const cache = reactive(new Map<string, CacheItem>());
const pendingRequests = new Map<string, Promise<any>>();

export function useFetch<T>(url: string, options: Options = {}) {
  const data = ref<T | null>(null);
  const error = ref<Error | null>(null);
  const loading = ref(false);
  const { cacheTTL = 60000, immediate = true } = options;

  // 生成唯一缓存键（可根据需求扩展参数哈希）
  const cacheKey = url; 

  // 核心请求方法
  const execute = async () => {
    // 重复请求去重逻辑
    if (pendingRequests.has(cacheKey)) {
      return pendingRequests.get(cacheKey);
    }

    // 缓存有效直接返回
    if (cache.has(cacheKey)) {
      const cached = cache.get(cacheKey)!;
      if (Date.now() - cached.timestamp < cacheTTL) {
        data.value = cached.data;
        return cached.data;
      }
    }

    try {
      loading.value = true;
      const request = fetch(url)
        .then(res => res.json())
        .then(res => {
          // 更新缓存
          cache.set(cacheKey, { 
            data: res, 
            timestamp: Date.now() 
          });
          data.value = res;
          return res;
        })
        .finally(() => {
          pendingRequests.delete(cacheKey);
          loading.value = false;
        });

      pendingRequests.set(cacheKey, request);
      return await request;
    } catch (err) {
      error.value = err as Error;
      cache.delete(cacheKey); // 失败时清除缓存
      throw err;
    }
  };

  // 立即执行
  if (immediate) execute();

  // 手动清除缓存方法
  const clearCache = () => cache.delete(cacheKey);

  return { data, error, loading, execute, clearCache };
}
```

使用：

```vue
<script setup>
import { useFetch } from './useFetch';

const { data, loading } = useFetch('/api/user', { 
  cacheTTL: 300000 // 缓存5分钟
});

// 手动触发请求（自动去重）
const refresh = () => execute();
</script>
```

**核心设计要点：**

1. **双重缓存策略**
   - **内存缓存**：`Map`存储已成功请求的数据
   - **请求中缓存**：`pendingRequests`避免重复发送相同请求
2. **自动缓存失效**
   通过`cacheTTL`控制缓存有效期，超时后自动重新请求
3. **智能去重机制**
   - 相同URL同时触发多次请求时，仅实际发送一次
   - 后续请求共享同一Promise结果
4. **灵活扩展点**
   - 可扩展`cacheKey`生成逻辑（如包含请求参数）
   - 可添加请求取消功能（结合`AbortController`）



## 实现一个函数， 解析 URL 参数， 返回一个对象

**方案 1：纯字符串分割（基础版**）

```javascript
function parseUrlParams(url) {
  const params = {};
  const query = url.split('?')[1] || '';
  query.split('&').forEach(pair => {
    const [key, val] = pair.split('=');
    if (key) {
      params[decodeURIComponent(key)] = decodeURIComponent(val || '');
    }
  });
  return params;
}
// 示例：'?name=John&age=30' → { name: 'John', age: '30' }
```

**优点**：代码简单，兼容性好
**缺点**：未处理数组参数（如 `?key=1&key=2`）



**方案 2：正则表达式（支持数组参数）**

```javascript
function parseUrlParams(url) {
  const params = {};
  url.replace(/[?&]([^=&#]+)=([^&#]*)/g, (_, key, val) => {
    key = decodeURIComponent(key);
    val = decodeURIComponent(val || '');
    params[key] = params[key] ? [].concat(params[key], val) : val;
  });
  return params;
}
// 示例：'?key=1&key=2' → { key: ['1', '2'] }
```

**优点**：支持重复键转为数组
**缺点**：正则复杂度高，需理解分组匹配



**方案 3：URLSearchParams API（现代浏览器**）

```javascript
function parseUrlParams(url) {
  const params = {};
  const searchParams = new URL(url).searchParams;
  searchParams.forEach((val, key) => {
    params[key] = searchParams.getAll(key).length > 1 
      ? searchParams.getAll(key) 
      : val;
  });
  return params;
}
// 示例：自动处理编码（如空格转为%20）
```

**优点**：原生 API 简洁，自动解码
**缺点**：需兼容性处理（IE 不支持）

## 将对象转换为 URL 的字符串形式

**方案一：基础实现（不含编码）**

```javascript
function objectToQueryString(obj) {
  return Object.entries(obj)
    .map(([key, value]) => `${key}=${value}`)
    .join('&');
}

// 使用示例
const params = { name: 'John', age: 30, isMember: true };
console.log(objectToQueryString(params)); // "name=John&age=30&isMember=true"
```

**方案二：带编码的完整实现**

```javascript
function objectToQueryString(obj) {
  return Object.entries(obj)
    .filter(([_, value]) => value !== undefined && value !== null) // 过滤 undefined/null
    .map(([key, value]) => {
      // 处理数组
      if (Array.isArray(value)) {
        return value
          .map(v => `${encodeURIComponent(key)}[]=${encodeURIComponent(v)}`)
          .join('&');
      }
      
      // 处理普通值
      return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
    })
    .join('&');
}

// 使用示例
const params = {
  name: 'John Doe',
  age: 30,
  hobbies: ['coding', 'reading'],
  address: { city: 'New York' }, // 对象会被转为 "[object Object]"
  specialChars: '!@#$%^&*()'
};

console.log(objectToQueryString(params));
// 输出: "name=John%20Doe&age=30&hobbies[]=coding&hobbies[]=reading&address=[object%20Object]&specialChars=%21%40%23%24%25%5E%26%2A%28%29"
```

**方案三：支持嵌套对象（递归处理）**

```javascript
function objectToQueryString(obj, parentKey = '') {
  return Object.entries(obj)
    .filter(([_, value]) => value !== undefined && value !== null)
    .map(([key, value]) => {
      const fullKey = parentKey 
        ? `${parentKey}[${key}]` 
        : key;
      
      if (typeof value === 'object' && value !== null) {
        return objectToQueryString(value, fullKey); // 递归处理嵌套对象
      }
      
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value)}`;
    })
    .join('&');
}

// 使用示例
const params = {
  name: 'John',
  age: 30,
  address: {
    city: 'New York',
    zip: '10001'
  },
  hobbies: ['coding', 'reading']
};

console.log(objectToQueryString(params));
// 输出: "name=John&age=30&address[city]=New%20York&address[zip]=10001&hobbies[0]=coding&hobbies[1]=reading"
```



**方案四：使用 URLSearchParams（现代浏览器）**

```javascript
function objectToQueryString(obj) {
  const searchParams = new URLSearchParams();
  
  Object.entries(obj).forEach(([key, value]) => {
    if (value === undefined || value === null) return;
    
    // 处理数组
    if (Array.isArray(value)) {
      value.forEach(v => searchParams.append(key, v));
      return;
    }
    
    // 处理普通值
    searchParams.append(key, value);
  });
  
  return searchParams.toString();
}

// 使用示例
const params = {
  name: 'John',
  age: 30,
  hobbies: ['coding', 'reading']
};

console.log(objectToQueryString(params));
// 输出: "name=John&age=30&hobbies=coding&hobbies=reading"
```

## 实现一个产生随机数的函数，范围是 [min,max)

**方案一：基础随机整数（[min, max)）**

```javascript
function randomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min;
}

// 使用示例
console.log(randomInt(1, 5)); // 可能输出 1, 2, 3, 4
```

**方案二：安全随机整数（使用 Crypto API）**

```javascript
function secureRandomInt(min, max) {
  const range = max - min;
  const bytesNeeded = Math.ceil(Math.log2(range) / 8);
  const maxNum = Math.pow(256, bytesNeeded);
  
  const array = new Uint8Array(bytesNeeded);
  
  do {
    window.crypto.getRandomValues(array);
    let value = 0;
    
    for (let i = 0; i < bytesNeeded; i++) {
      value = (value << 8) + array[i];
    }
    
    if (value < maxNum - (maxNum % range)) {
      return min + (value % range);
    }
  } while (true);
}

// 使用示例
console.log(secureRandomInt(1, 100)); // 安全生成 1-99 的整数
```

**方案三：随机浮点数（[min, max)）**

```javascript
function randomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

// 使用示例
console.log(randomFloat(1.5, 3.5)); // 可能输出 1.5-3.5 之间的任意浮点数
```

**方案四：带精度控制的随机浮点数**

```javascript
function randomFloat(min, max, precision = 2) {
  const factor = Math.pow(10, precision);
  const random = Math.random() * (max - min) + min;
  return Math.round(random * factor) / factor;
}

// 使用示例
console.log(randomFloat(1, 5, 3)); // 可能输出 1.000-4.999 之间的三位小数
```

**关键点解释**

1. **区间控制**：
   - `Math.random()` 生成 [0, 1) 的随机小数。
   - 通过 `(max - min) + min` 调整到目标区间 [min, max)。
2. **整数生成**：
   - `Math.floor()` 向下取整确保结果为整数。
   - 区间左闭右开（`[min, max)`）需注意边界处理。
3. **安全随机**：
   - `window.crypto.getRandomValues()` 提供密码学安全的随机数，适用于安全敏感场景。
4. **精度控制**：
   - 通过乘以 / 除以精度因子（如 `Math.pow(10, 2)` 对应两位小数）实现精度控制。

**注意事项**

- **性能考虑**：安全随机（Crypto API）比 `Math.random()` 慢，非安全场景优先使用前者。
- **区间边界**：确保理解区间是左闭右开（`[min, max)`）还是闭区间（`[min, max]`）。
- **分布均匀性**：`Math.random()` 在现代浏览器中分布均匀，但某些旧环境可能存在偏差。

## 实现日期格式化 format 函数

**1. 原生拼接法（手动补零）**

```javascript
function formatDate(date, format = 'yyyy-MM-dd HH:mm:ss') {
  const year = date.getFullYear();
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  const hours = date.getHours().toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  const seconds = date.getSeconds().toString().padStart(2, '0');
  
  return format
    .replace('yyyy', year)
    .replace('MM', month)
    .replace('dd', day)
    .replace('HH', hours)
    .replace('mm', minutes)
    .replace('ss', seconds);
}

// 使用示例
console.log(formatDate(new Date(), 'yyyy/MM/dd')); // 输出 "2023/09/28"
```

**2. Intl.DateTimeFormat（本地化支持）**

```JavaScript
function formatDate(date, locale = 'zh-CN', options = {}) {
  return new Intl.DateTimeFormat(locale, {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    ...options
  }).format(date);
}

// 使用示例
console.log(formatDate(new Date())); // 输出 "2023/09/28 14:30:45"（中文环境）
console.log(formatDate(new Date(), 'en-US')); // "9/28/2023, 2:30:45 PM"
```

**3. 正则替换法（灵活自定义）**

```JavaScript
function formatDate(date, format = 'yyyy-MM-dd') {
  const map = {
    'y+': date.getFullYear(),                // 年
    'M+': date.getMonth() + 1,               // 月
    'd+': date.getDate(),                    // 日
    'H+': date.getHours(),                   // 时（24小时制）
    'm+': date.getMinutes(),                 // 分
    's+': date.getSeconds(),                 // 秒
    'S': date.getMilliseconds()              // 毫秒
  };

  for (const [key, value] of Object.entries(map)) {
    const regex = new RegExp(`(${key})`);
    if (regex.test(format)) {
      const str = value.toString().padStart(2, '0');
      format = format.replace(regex, str);
    }
  }
  return format;
}

// 使用示例
console.log(formatDate(new Date(), 'yyyy年MM月dd日 HH时mm分')); 
// 输出 "2023年09月28日 14时30分"
```

## 实现版本号排序

```javascript
function sortVersionsEnhanced(versions) {
  return versions.sort((a, b) => {
    const splitPart = (part) => 
      part.split(/(\d+)/) // 拆分数字和非数字部分
          .filter(Boolean)
          .map(s => isNaN(s) ? s : parseInt(s));

    const aParts = splitPart(a);
    const bParts = splitPart(b);

    const maxLength = Math.max(aParts.length, bParts.length);
    
    for (let i = 0; i < maxLength; i++) {
      const aVal = i < aParts.length ? aParts[i] : null;
      const bVal = i < bParts.length ? bParts[i] : null;

      if (aVal === bVal) continue;
      
      // 数字优先于非数字
      if (typeof aVal === 'number' && typeof bVal !== 'number') return -1;
      if (typeof bVal === 'number' && typeof aVal !== 'number') return 1;
      
      // 比较实际值
      return (aVal < bVal) ? -1 : 1;
    }
    return 0;
  });
}
```

## 实现手机号脱敏

**方案一：中间四位替换为星号（常用方式）**

```javascript
function maskPhone(phone) {
  if (!phone) return '';
  return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
}

// 使用示例
console.log(maskPhone('13812345678')); // "138****5678"
```

**方案二：自定义脱敏位数和符号**

```javascript
function maskPhone(phone, options = {}) {
  if (!phone) return '';
  
  const {
    start = 3,      // 保留前几位
    end = 4,        // 保留后几位
    maskChar = '*', // 替换字符
    maskLength = 4  // 替换长度
  } = options;
  
  const totalLength = phone.length;
  const maskStart = Math.min(start, totalLength);
  const maskEnd = Math.max(totalLength - end, maskStart);
  
  // 生成掩码字符串
  const mask = maskChar.repeat(Math.min(maskLength, maskEnd - maskStart));
  
  return phone.substring(0, maskStart) + mask + phone.substring(maskEnd);
}

// 使用示例
console.log(maskPhone('13812345678', { start: 3, end: 4 })); // "138****5678"
console.log(maskPhone('13812345678', { maskChar: '#', maskLength: 6 })); // "138######78"
```

**方案三：灵活的脱敏策略（支持多种格式）**

```javascript
function maskPhone(phone, strategy = 'middle') {
  if (!phone) return '';
  
  // 移除非数字字符
  const cleanPhone = phone.replace(/\D/g, '');
  
  switch (strategy) {
    case 'middle': // 中间脱敏
      return cleanPhone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
      
    case 'end': // 末尾脱敏
      return cleanPhone.replace(/(\d{7})\d+/, '$1****');
      
    case 'custom': // 自定义脱敏
      return cleanPhone.replace(/(\d{2})(\d{6})(\d+)/, '$1******$3');
      
    default:
      return cleanPhone;
  }
}

// 使用示例
console.log(maskPhone('138-1234-5678')); // "138****5678"
console.log(maskPhone('+8613812345678', 'end')); // "1381234****"
console.log(maskPhone('13812345678', 'custom')); // "13******78"
```

**方案四：保留格式的脱敏（适用于带分隔符的号码）**

```javascript
function maskPhone(phone) {
  if (!phone) return '';
  
  // 先提取数字部分进行脱敏
  const digits = phone.replace(/\D/g, '');
  const maskedDigits = digits.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  
  // 再还原格式
  let result = '';
  let digitIndex = 0;
  
  for (let char of phone) {
    if (/^\d$/.test(char) && digitIndex < maskedDigits.length) {
      result += maskedDigits[digitIndex];
      digitIndex++;
    } else {
      result += char; // 保留非数字字符
    }
  }
  
  return result;
}

// 使用示例
console.log(maskPhone('138-1234-5678')); // "138-****-5678"
console.log(maskPhone('(138) 123-4567')); // "(138) ****-4567"
```

**关键点解释**

1. **正则表达式**：
   - 使用 `(\d{3})\d{4}(\d{4})` 匹配前 3 位和后 4 位，中间 4 位替换为星号。
2. **格式保留**：
   - 方案四通过遍历原字符串，逐个替换数字字符，保留非数字分隔符。
3. **灵活性**：
   - 支持自定义脱敏位置、长度和替换字符，适应不同业务需求。

**注意事项**

- **数据验证**：
  - 建议在脱敏前验证手机号格式（如长度是否为 11 位）。
- **国际化支持**：
  - 上述方案主要针对中国大陆 11 位手机号，国际号码需调整正则表达式。
- **隐私合规**：
  - 脱敏策略需符合业务隐私政策（如金融行业可能要求更高安全级别）。

## 计算两个日期之间相差的天数，例如 '2024-01-01' 和 '2024-01-10'

```javascript
function calculateDaysBetweenDates(date1, date2) {
    // 创建Date对象
    const startDate = new Date(date1);
    const endDate = new Date(date2);

    // 确保startDate在endDate之前
    if (startDate > endDate) {
        [startDate, endDate] = [endDate, startDate];
    }

    // 计算时间差（毫秒）
    const timeDiff = endDate - startDate;

    // 转换为天数
    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));

    return daysDiff;
}

// 示例使用
const date1 = '2024-01-01';
const date2 = '2024-01-10';
const days = calculateDaysBetweenDates(date1, date2);
console.log(`两个日期之间相差 ${days} 天`);
```



## 将驼峰命名法字符串 'helloWorld' 转换为下划线命名法 'hello_world'

**方案一：基础正则实现**

```javascript
function camelToSnake(str) {
  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
}

// 使用示例
console.log(camelToSnake('helloWorld')); // "hello_world"
console.log(camelToSnake('userID')); // "user_i_d"（存在问题）
```

**方案二：优化正则处理（正确处理连续大写字母）**

```javascript
function camelToSnake(str) {
  return str
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
    .replace(/([a-z\d])([A-Z])/g, '$1_$2')
    .toLowerCase();
}

// 使用示例
console.log(camelToSnake('helloWorld')); // "hello_world"
console.log(camelToSnake('userIDCard')); // "user_id_card"
console.log(camelToSnake('HTTPResponseCode')); // "http_response_code"
```

**方案三：使用 Unicode 处理特殊字符**

```javascript
function camelToSnake(str) {
  return str
    .replace(/([\p{Lu}\d]+)([\p{Lu}][\p{Ll}])/gu, '$1_$2')
    .replace(/([\p{Ll}\d])([\p{Lu}])/gu, '$1_$2')
    .toLowerCase();
}

// 使用示例
console.log(camelToSnake('helloWorld')); // "hello_world"
console.log(camelToSnake('userID')); // "user_id"
console.log(camelToSnake('IDCardNumber')); // "id_card_number"
console.log(camelToSnake('👋HelloWorld')); // "👋_hello_world"
```

**方案四：支持自定义分隔符**

```javascript
function camelToDelimiter(str, delimiter = '_') {
  return str
    .replace(/([\p{Lu}\d]+)([\p{Lu}][\p{Ll}])/gu, `$1${delimiter}$2`)
    .replace(/([\p{Ll}\d])([\p{Lu}])/gu, `$1${delimiter}$2`)
    .toLowerCase();
}

// 使用示例
console.log(camelToDelimiter('helloWorld', '-')); // "hello-world"
console.log(camelToDelimiter('userIDCard', '.')); // "user.id.card"
```

## 判断括号字符串是否有效（如 "()[]{}"）

```javascript
function isValid(s) {
    const stack = [];
    const map = {
        ')': '(',
        ']': '[',
        '}': '{'
    };

    for (const char of s) {
        if (map[char]) {
            if (stack.length === 0 || stack.pop() !== map[char]) {
                return false;
            }
        } else {
            stack.push(char);
        }
    }

    return stack.length === 0;
}

// 示例使用
const str1 = "()[]{}";
const str2 = "(]";
const str3 = "{[]}";

console.log(isValid(str1)); // true
console.log(isValid(str2)); // false
console.log(isValid(str3)); // true
```



## 判断一个字符串 'racecar' 是否为回文

```javascript
function isPalindrome(s) {
    return s === s.split('').reverse().join('');
}

// 示例使用
const str1 = "racecar";
const str2 = "hello";

console.log(isPalindrome(str1)); // true
console.log(isPalindrome(str2)); // false
```



## 生成随机十六进制颜色值

**方案一：标准 6 位颜色（#RRGGBB）**



```javascript
function randomColor() {
  return '#' + Math.floor(Math.random() * 0xFFFFFF)
    .toString(16)
    .padStart(6, '0')
    .toUpperCase();
}

// 使用示例
console.log(randomColor()); // 例如 "#FF00FF"
```

**方案二：带透明度的 8 位颜色（#RRGGBBAA）**

```javascript
function randomColorWithAlpha() {
  const rgb = Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
  const alpha = Math.floor(Math.random() * 256).toString(16).padStart(2, '0');
  return `#${rgb}${alpha}`.toUpperCase();
}

// 使用示例
console.log(randomColorWithAlpha()); // 例如 "#FF00FF80"（50% 透明度）
```

**方案三：自定义长度和前缀**

```javascript
function randomHexColor(length = 6, prefix = '#') {
  const chars = '0123456789ABCDEF';
  let result = '';
  
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  
  return prefix + result;
}

// 使用示例
console.log(randomHexColor()); // "#ABCDEF"
console.log(randomHexColor(8, '0x')); // "0x12345678"
```

**方案四：安全随机（使用 Crypto API）**

```javascript
function secureRandomColor() {
  const array = new Uint8Array(3);
  window.crypto.getRandomValues(array);
  
  return '#' + array.reduce(
    (acc, byte) => acc + byte.toString(16).padStart(2, '0'), 
    ''
  ).toUpperCase();
}

// 使用示例
console.log(secureRandomColor()); // 密码学安全的随机颜色
```

## 给定两个数组，写一个方法来计算它们的交集？

**方案一：使用 Set（适合基本类型，O (n+m)）**

```javascript
function intersection(arr1, arr2) {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  return [...set1].filter(x => set2.has(x));
}

// 使用示例
console.log(intersection([1, 2, 3], [2, 3, 4])); // [2, 3]
```

**方案二：排序 + 双指针（适合已排序数组，O (n log n)）**

```javascript
function intersection(arr1, arr2) {
  // 先排序（如果未排序）
  arr1.sort((a, b) => a - b);
  arr2.sort((a, b) => a - b);
  
  const result = [];
  let i = 0, j = 0;
  
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] < arr2[j]) {
      i++;
    } else {
      j++;
    }
  }
  
  return result;
}

// 使用示例
console.log(intersection([1, 4, 2], [2, 3, 4])); // [2, 4]
```

**方案三：哈希表（适合对象数组，自定义相等逻辑）**

```javascript
function intersection(arr1, arr2, keyFn = x => x) {
  const map = new Map();
  const result = [];
  
  // 将 arr1 的元素存入哈希表
  for (const item of arr1) {
    const key = keyFn(item);
    map.set(key, item);
  }
  
  // 检查 arr2 的元素是否存在于哈希表
  for (const item of arr2) {
    const key = keyFn(item);
    if (map.has(key)) {
      result.push(item);
      map.delete(key); // 避免重复
    }
  }
  
  return result;
}

// 使用示例（对象数组）
const arr1 = [{ id: 1 }, { id: 2 }];
const arr2 = [{ id: 2 }, { id: 3 }];
console.log(intersection(arr1, arr2, item => item.id)); // [{ id: 2 }]
```

**方案四：过滤 + includes（简单但低效，O (n\*m)）**

```javascript
function intersection(arr1, arr2) {
  return arr1.filter(x => arr2.includes(x));
}

// 使用示例
console.log(intersection([1, 2, 3], [2, 3, 4])); // [2, 3]
```

**关键点解释**

1. **Set 方法**：
   - 利用 Set 的 O (1) 查找效率，适合快速去重和交集计算。
2. **双指针法**：
   - 要求数组有序，通过比较指针位置逐步移动，空间复杂度 O (1)。
3. **哈希表自定义相等**：
   - 通过 `keyFn` 自定义对象的唯一标识（如 ID），适用于复杂对象。
4. **性能对比**：
   - Set 方案平均时间复杂度最优（O (n+m)），过滤 + includes 最差（O (n*m)）。

## 实现管道函数

管道函数（Pipeline）允许将多个函数按顺序组合，前一个函数的输出作为后一个函数的输入。以下是几种实现方案：

**方案一：基础实现（从左到右执行）**

```javascript
function pipe(...fns) {
  return (initialValue) => 
    fns.reduce((value, fn) => fn(value), initialValue);
}

// 使用示例
const add1 = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const pipeline = pipe(add1, double, square);
console.log(pipeline(3)); // 执行步骤：(3+1)*2=8 → 8²=64 → 输出 64
```

**方案二：支持异步函数（Promise 链式调用）**

```javascript
async function asyncPipe(...fns) {
  return async (initialValue) => 
    fns.reduce(async (valuePromise, fn) => 
      fn(await valuePromise), 
      Promise.resolve(initialValue)
    );
}

// 使用示例
const fetchData = async () => 3;
const add1 = async x => x + 1;
const double = async x => x * 2;

const asyncPipeline = await asyncPipe(fetchData, add1, double);
console.log(await asyncPipeline()); // 执行步骤：3+1=4 → 4*2=8 → 输出 8
```

**方案三：支持上下文传递（类似 Koa 中间件）**

```javascript
function pipeWithCtx(...fns) {
  return (initialValue) => {
    const ctx = { value: initialValue };
    const dispatch = (index) => {
      if (index === fns.length) return ctx;
      const fn = fns[index];
      return fn(ctx, () => dispatch(index + 1));
    };
    return dispatch(0);
  };
}

// 使用示例
const addCtx = (ctx, next) => { ctx.value += 1; return next(); };
const doubleCtx = (ctx, next) => { ctx.value *= 2; return next(); };

const ctxPipeline = pipeWithCtx(addCtx, doubleCtx);
console.log(ctxPipeline(3)); // { value: 8 }
```

**方案四：Ramda 风格的 curry 化管道**

```javascript
const pipe = (...fns) => 
  initialValue => 
    fns.reduce((value, fn) => fn(value), initialValue);

// 使用示例
const pipeline = pipe(
  x => x + 1,
  x => x * 2,
  x => x.toString()
);

console.log(pipeline(5)); // "12"
```

**关键点解释**

1. **函数组合**：
   - 使用 `Array.reduce` 依次执行函数，前一个结果作为后一个的输入。
2. **异步处理**：
   - 通过 `async/await` 和 `Promise` 处理异步函数，保持调用链连续性。
3. **上下文传递**：
   - 创建共享上下文对象，允许中间函数修改数据或添加元信息。
4. **curry 化**：
   - 允许部分应用，灵活构建复杂管道。

## 实现数组的乱序输出

**方案一：Fisher-Yates 算法（原地修改）**

```javascript
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1)); // 生成 0 到 i 之间的随机索引
    [array[i], array[j]] = [array[j], array[i]]; // 交换元素
  }
  return array;
}

// 使用示例
const arr = [1, 2, 3, 4, 5];
console.log(shuffle(arr)); // 例如 [3, 1, 5, 4, 2]
```

**方案二：安全随机版本（使用 Crypto API）**

```javascript
function secureShuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    // 使用安全随机数生成器
    const arrayBuffer = new Uint32Array(1);
    window.crypto.getRandomValues(arrayBuffer);
    const randomIndex = Math.floor((arrayBuffer[0] / 0xFFFFFFFF) * (i + 1));
    
    [array[i], array[randomIndex]] = [array[randomIndex], array[i]];
  }
  return array;
}

// 使用示例
const secureArr = [1, 2, 3];
console.log(secureShuffle(secureArr)); // 例如 [3, 1, 2]
```

**方案三：返回新数组（不修改原数组）**

```javascript
function shuffleCopy(array) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

// 使用示例
const original = [1, 2, 3];
const shuffled = shuffleCopy(original);
console.log(shuffled); // 例如 [2, 3, 1]
console.log(original); // 保持不变 [1, 2, 3]
```

**关键点解释**

1. **算法原理**：
   - 从最后一个元素开始，依次向前遍历，为每个位置随机选择一个尚未处理的元素进行交换。
   - 时间复杂度 O (n)，空间复杂度 O (1)（原地修改）。
2. **随机性保证**：
   - 每个元素在每个位置出现的概率为 1/n，确保均匀分布。
3. **安全随机**：
   - `window.crypto.getRandomValues()` 提供密码学安全的随机数，适用于需要高安全性的场景（如游戏、抽奖）。

**常见错误避免**

❌ 错误实现：使用 sort + 随机比较函数

```javascript
// 错误示例（分布不均匀）
array.sort(() => Math.random() - 0.5);
```

- **问题**：不同浏览器对 `sort` 的实现不同，可能导致分布不均匀。某些元素对的交换次数会显著多于其他元素对。

## 实现一个随机不重复数组生成器

**通过范围生成与洗牌算法，或动态查重填充，确保数组元素随机且唯一。**
**方案一：洗牌算法（高效，适合连续范围）**  

1. **生成顺序数组**：根据范围 `[min, max]` 生成连续数列。  
2. **Fisher-Yates 洗牌**：从后向前遍历，随机交换位置打乱顺序。  
3. **截取所需长度**：返回前 `length` 个元素。  

```javascript  
function generateUniqueArray(min, max, length) {  
  if (length > max - min + 1) throw new Error("范围不足无法生成不重复数组");  

  // 生成连续数组  
  const arr = Array.from({ length: max - min + 1 }, (_, i) => i + min);  

  // Fisher-Yates 洗牌  
  for (let i = arr.length - 1; i > 0; i--) {  
    const j = Math.floor(Math.random() * (i + 1));  
    [arr[i], arr[j]] = [arr[j], arr[i]];  
  }  

  // 截取前 length 项  
  return arr.slice(0, length);  
}  

// 示例：生成 5 个 1~10 的不重复随机数  
console.log(generateUniqueArray(1, 10, 5)); // 如 [3,7,2,9,5]  
```

**方案二：动态查重（适合稀疏或大范围）**  
1. **使用 Set 存储唯一值**：每次生成随机数并检查是否已存在。  
2. **循环填充至达标**：重复生成直到 Set 大小达到目标长度。  

```javascript  
function generateUniqueArray(min, max, length) {  
  if (length > max - min + 1) throw new Error("范围不足");  
  const set = new Set();  

  while (set.size < length) {  
    const num = Math.floor(Math.random() * (max - min + 1)) + min;  
    set.add(num);  
  }  

  return Array.from(set);  
}  
```

**优化点：**  
- **参数校验**：处理 `min > max` 或 `length ≤ 0` 等非法输入。  
- **性能平衡**：当 `length` 接近范围大小时用方案一，否则用方案二。  
- **自定义随机源**：允许传入随机函数（如加密安全的 `crypto.getRandomValues`）。  

**测试用例：**  
```javascript  
// 边界情况：范围=5~5，length=1 → [5]  
console.log(generateUniqueArray(5, 5, 1));  

// 大范围：生成 1000 个 1~100000 的不重复数  
console.log(generateUniqueArray(1, 100000, 1000).length); // 1000  
```

## 实现一个大数相加函数

**通过逐位相加与进位处理，模拟手动计算过程，解决超出数字精度的大数相加问题。**

**实现过程：**  

```javascript  
function addBigNumbers(a, b) {  
  let i = a.length - 1;    // 从末位开始（个位）  
  let j = b.length - 1;  
  let carry = 0;           // 进位值  
  let result = "";  

  // 任意一位未遍历完或仍有进位时继续  
  while (i >= 0 || j >= 0 || carry > 0) {  
    // 当前位数字（若已遍历完则补0）  
    const numA = i >= 0 ? parseInt(a[i--], 10) : 0;  
    const numB = j >= 0 ? parseInt(b[j--], 10) : 0;  

    // 计算当前位总和及进位  
    const sum = numA + numB + carry;  
    const currentDigit = sum % 10;  
    carry = Math.floor(sum / 10);  

    // 拼接当前位结果（顺序为高位到低位，无需反转）  
    result = currentDigit + result;  
  }  

  // 去除前导零（若全零则保留一个）  
  return result.replace(/^0+/, "") || "0";  
}  

// 测试用例  
console.log(addBigNumbers("999", "1"));         // "1000"  
console.log(addBigNumbers("123", "456"));       // "579"  
console.log(addBigNumbers("0", "0"));           // "0"  
console.log(addBigNumbers("1000", "2000"));     // "3000"  
```

**关键点说明：**  
1. **逆向遍历**：从字符串末尾（个位）开始逐位相加，模拟手动计算。  
2. **补零处理**：当某一数字遍历完后，默认其高位为0。  
3. **进位传递**：通过 `carry` 变量记录进位值，并参与下一位计算。  
4. **前导零清理**：使用正则表达式去除结果中的前导零，确保结果符合常规书写格式。  

**性能优化：**  
- **时间复杂度**：O(max(N, M))，其中 N 和 M 为输入字符串长度。  
- **空间复杂度**：O(max(N, M))，结果字符串长度最多为 max(N, M) + 1。  

**扩展场景：**  
- **支持负数**：可扩展符号判断与减法逻辑。  
- **小数相加**：拆分整数与小数部分分别处理，最后合并。  
- **超长字符串优化**：分块处理（如每15位一段）避免内存溢出。

## 实现一个函数参数记忆化

**通过缓存函数参数与结果映射，避免重复计算，提升重复调用性能。**  

**实现过程：**  
```javascript  
function memoize(fn) {  
  const cache = new Map(); // 使用Map存储缓存（支持对象等复杂键）  
  // 生成唯一缓存键（解决参数顺序、引用类型等问题）  
  const generateKey = (args) => {  
    return args.map(arg => {  
      if (typeof arg === 'object' && arg !== null) {  
        // 稳定序列化对象（按键排序）  
        return JSON.stringify(arg, Object.keys(arg).sort());  
      }  
      return JSON.stringify(arg);  
    }).join('|');  
  };  

  return function(...args) {  
    const key = generateKey(args);  
    if (cache.has(key)) {  
      console.log('命中缓存:', key);  
      return cache.get(key);  
    }  
    // 执行原函数并缓存结果（绑定this）  
    const result = fn.apply(this, args);  
    cache.set(key, result);  
    return result;  
  };  
}  

// 示例：计算斐波那契数列  
const fibonacci = memoize((n) => {  
  if (n <= 1) return n;  
  return fibonacci(n - 1) + fibonacci(n - 2);  
});  

console.log(fibonacci(10)); // 第10项：55（仅计算必要节点）  
```

**关键优化点：**  
1. **复杂参数处理**：对对象参数按键名排序后序列化，避免 `{a:1,b:2}` 与 `{b:2,a:1}` 生成不同键  
2. **缓存数据结构**：使用 `Map` 替代普通对象，支持任意类型键  
3. **递归兼容**：在递归函数（如斐波那契）中仍可复用缓存  

**适用场景：**  
- 纯函数（同样输入必定同样输出）  
- 高计算成本函数（如数学计算、数据解析）  

**扩展能力：**  
- **缓存淘汰策略**：可添加LRU（最近最少使用）逻辑限制内存占用  
- **异步支持**：缓存Promise，避免重复请求  
- **自定义序列化**：允许传入`hash`函数处理特殊参数类型

## 实现一个可以用 for...of 遍历的对象

在 JavaScript 中，要实现一个可以用 `for...of` 遍历的对象，需要使该对象实现可迭代协议，即具有 `Symbol.iterator` 属性，该属性的值是一个返回迭代器对象的函数。迭代器对象需要具有 `next` 方法，`next` 方法返回一个包含 `value` 和 `done` 属性的对象，`value` 是当前迭代的值，`done` 是一个布尔值，表示是否迭代结束。

以下是一个简单的示例，展示如何实现一个可迭代对象：

```javascript
// 定义一个可迭代对象
const iterableObject = {
    data: [1, 2, 3, 4, 5],
    [Symbol.iterator]() {
        let index = 0;
        const self = this;
        return {
            next() {
                if (index < self.data.length) {
                    return {
                        value: self.data[index++],
                        done: false
                    };
                } else {
                    return {
                        value: undefined,
                        done: true
                    };
                }
            }
        };
    }
};

// 使用 for...of 遍历可迭代对象
for (const element of iterableObject) {
    console.log(element);
}
```

在上述代码中：

1. 定义了一个对象 `iterableObject`，它有一个属性 `data`，值为一个数组。
2. 为 `iterableObject` 添加了 `Symbol.iterator` 方法，该方法返回一个迭代器对象。
3. 迭代器对象的 `next` 方法用于逐个返回数组中的元素，当遍历完所有元素时，`done` 属性为 `true`。
4. 最后，使用 `for...of` 循环遍历 `iterableObject`，输出数组中的每个元素。

## 实现一个函数， 通过 id 来查找 tree 数据结构对应的节点

**方案一：深度优先搜索（递归）**

```javascript
function findNodeById(tree, id) {
  if (!tree) return null;
  if (tree.id === id) return tree;
  
  // 处理子节点（支持 children 或其他属性名）
  if (tree.children && Array.isArray(tree.children)) {
    for (const child of tree.children) {
      const found = findNodeById(child, id);
      if (found) return found;
    }
  }
  
  return null;
}

// 使用示例
const tree = {
  id: 1,
  children: [
    { id: 2, children: [{ id: 4 }] },
    { id: 3 }
  ]
};

console.log(findNodeById(tree, 4)); // { id: 4 }
```

**方案二：广度优先搜索（队列实现）**

```javascript
function findNodeById(tree, id) {
  if (!tree) return null;
  const queue = [tree];
  
  while (queue.length > 0) {
    const current = queue.shift();
    
    if (current.id === id) {
      return current;
    }
    
    if (current.children && Array.isArray(current.children)) {
      queue.push(...current.children);
    }
  }
  
  return null;
}

// 使用示例
const tree = {
  id: 1,
  children: [
    { id: 2, children: [{ id: 4 }] },
    { id: 3 }
  ]
};

console.log(findNodeById(tree, 3)); // { id: 3 }
```

**方案三：支持自定义子节点属性**

```javascript
function findNodeById(tree, id, options = {}) {
  const { childrenKey = 'children' } = options;
  if (!tree) return null;
  if (tree.id === id) return tree;
  
  const children = tree[childrenKey];
  if (Array.isArray(children)) {
    for (const child of children) {
      const found = findNodeById(child, id, options);
      if (found) return found;
    }
  }
  
  return null;
}

// 使用示例
const tree = {
  id: 1,
  nodes: [
    { id: 2, nodes: [{ id: 4 }] },
    { id: 3 }
  ]
};

console.log(findNodeById(tree, 4, { childrenKey: 'nodes' })); // { id: 4 }
```

**方案四：使用迭代器（ES6+）**

```javascript
function* iterateTree(tree, options = {}) {
  const { childrenKey = 'children' } = options;
  if (!tree) return;
  
  yield tree;
  
  const children = tree[childrenKey];
  if (Array.isArray(children)) {
    for (const child of children) {
      yield* iterateTree(child, options);
    }
  }
}

function findNodeById(tree, id, options = {}) {
  for (const node of iterateTree(tree, options)) {
    if (node.id === id) {
      return node;
    }
  }
  return null;
}

// 使用示例
const tree = {
  id: 1,
  children: [
    { id: 2, children: [{ id: 4 }] },
    { id: 3 }
  ]
};

console.log(findNodeById(tree, 3)); // { id: 3 }
```

**关键点解释**

1. **递归 vs 迭代**：
   - 递归（方案一）实现简洁，但可能导致栈溢出（处理极深树时）。
   - 迭代（方案二）使用队列避免栈溢出，适合大型树结构。
2. **遍历顺序**：
   - 深度优先（DFS）优先访问子树，适合查找层级较深的节点。
   - 广度优先（BFS）逐层遍历，适合查找接近根节点的元素。
3. **灵活性**：
   - 方案三通过 `childrenKey` 参数支持不同属性名（如 `nodes`、`subItems`）。
   - 方案四使用生成器函数，支持更灵活的遍历控制。

**注意事项**

1. **性能考虑**：
   - 最坏情况下时间复杂度为 O (n)，需遍历所有节点。
2. **循环引用**：
   - 若树结构存在循环引用，需添加访问标记避免无限循环。
3. **ID 唯一性**：
   - 若存在重复 ID，函数将返回第一个找到的节点。

## 实现类似 ChatGPT 中，文案一个个输出的打字机效果

**简单版本**

```html
<div id="output"></div>
<style>
  /* 光标闪烁效果 */
  #output::after {
    content: "|";
    animation: blink 1s infinite;
  }
  @keyframes blink { 50% { opacity: 0; } }
</style>

<script>
function typeWriter(el, text, speed = 100) {
  let index = 0;
  el.innerHTML = ''; // 清空初始内容
  
  const timer = setInterval(() => {
    if (index >= text.length) return clearInterval(timer);
    el.innerHTML = text.slice(0, ++index); // 逐个字符追加
  }, speed);
}

// 使用示例
const outputEl = document.getElementById('output');
typeWriter(outputEl, 'Hello, 这是打字机效果！', 80);
</script>
```

**deepseek自答版**

DeepSeek 网页版的打字机效果主要通过 **流式文本处理 + CSS 光标动画** 实现，核心步骤和优化点如下：

**1. 核心实现**

```
// 示例代码（简化版）
class TypeWriter {
  constructor(element) {
    this.el = element;
    this.queue = [];
    this.isWriting = false;
    this.cursorBlink();
  }

  // 流式追加文本
  write(text, speed = 30) {
    this.queue.push(...text.split(''));
    if (!this.isWriting) this.loop();
  }

  // 逐字渲染循环
  async loop() {
    this.isWriting = true;
    while (this.queue.length > 0) {
      await new Promise(r => setTimeout(r, this.speed));
      this.el.textContent += this.queue.shift();
      this.keepCursorVisible(); // 保持光标在视口中
    }
    this.isWriting = false;
  }

  // 光标闪烁动画
  cursorBlink() {
    const cursor = document.createElement('span');
    cursor.className = 'cursor';
    this.el.appendChild(cursor);
  }
}
```

**2. 关键优化技术**

- **分段加载**
  长文本拆分为 `chunks`，优先渲染可视区域内容，通过 `Intersection Observer` 监听滚动触发后续加载：

  ```
  const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) loadNextChunk();
  });
  ```

- **高性能渲染**

  - 使用 `DocumentFragment` 批量更新 DOM
  - 动态调整 `requestAnimationFrame` 与 `setTimeout` 的调用平衡帧率和流畅度

- **Markdown 流式解析**

  ```
  // 边接收边解析（伪代码）
  socket.on('stream', (markdownChunk) => {
    const htmlChunk = marked.parse(markdownChunk);
    typeWriter.write(htmlChunk);
  });
  ```

- **防阻塞中断**
  通过 `AbortController` 支持用户中断输出：

  ```
  const controller = new AbortController();
  writeStream(content, { signal: controller.signal });
  // 用户点击停止时调用 controller.abort()
  ```

**3. 样式处理**

```
/* 光标动画 */
.cursor {
  display: inline-block;
  width: 1ch;
  background: currentColor;
  animation: 
    blink 1s step-end infinite,
    type 0.1s step-end infinite;
}

@keyframes blink { 50% { opacity: 0; } }
@keyframes type { from { width: 0; } } /* 模拟打字宽度变化 */
```

**4. 实时性优化**

- **WebSocket 增量更新**
  后端分片流式返回数据，前端逐片渲染：

  ```
  const ws = new WebSocket('wss://api.deepseek.com/stream');
  ws.onmessage = (event) => {
    typeWriter.write(event.data);
  };
  ```

- **语法高亮延迟处理**
  代码块完全输出后触发高亮：

  ```
  const highlightQueue = [];
  function scheduleHighlight(codeBlock) {
    highlightQueue.push(codeBlock);
    if (!isRendering) requestIdleCallback(doHighlight);
  }
  ```

**5. 性能监控**

```
// 通过 Performance API 监控渲染耗时
const perfMarkStart = 'typing_start';
performance.mark(perfMarkStart);

requestAnimationFrame(() => {
  performance.measure('typing_duration', perfMarkStart);
  const metrics = performance.getEntriesByName('typing_duration')[0];
  if (metrics.duration > 100) throttleSpeed(); // 自动降速
});
```

**效果对比传统方案的优势**：

- 首屏渲染速度提升 **40%+**（通过分片加载）
- CPU 占用减少 **30%**（基于 `requestIdleCallback` 调度）
- 内存占用稳定（通过循环队列而非递归）



## 实现有序数组原地去重

**方案一：基础双指针法（保留一个重复元素）**

```javascript
function removeDuplicates(nums) {
  if (nums.length === 0) return 0;
  
  let slow = 0; // 慢指针，指向当前不重复元素的位置
  
  for (let fast = 1; fast < nums.length; fast++) {
    if (nums[fast] !== nums[slow]) {
      slow++;
      nums[slow] = nums[fast]; // 将不重复元素移动到慢指针位置
    }
  }
  
  return slow + 1; // 返回新数组长度
}

// 使用示例
const nums = [1, 1, 2, 2, 3, 4, 4, 4, 5];
const newLength = removeDuplicates(nums);
console.log(nums.slice(0, newLength)); // [1, 2, 3, 4, 5]
```

**方案二：允许最多保留 k 个重复元素**

```javascript
function removeDuplicates(nums, k = 1) {
  if (nums.length <= k) return nums.length;
  
  let slow = k; // 慢指针从 k 开始
  
  for (let fast = k; fast < nums.length; fast++) {
    // 检查当前元素是否与前 k 个位置的元素不同
    if (nums[fast] !== nums[slow - k]) {
      nums[slow] = nums[fast];
      slow++;
    }
  }
  
  return slow;
}

// 使用示例（允许最多两个重复元素）
const nums = [1, 1, 1, 2, 2, 3, 3, 3, 3];
const newLength = removeDuplicates(nums, 2);
console.log(nums.slice(0, newLength)); // [1, 1, 2, 2, 3, 3]
```

**方案三：严格去重（不保留任何重复元素）**

```javascript
function removeDuplicates(nums) {
  if (nums.length === 0) return 0;
  
  let slow = 0;
  let count = 1; // 记录当前元素的重复次数
  
  for (let fast = 1; fast < nums.length; fast++) {
    if (nums[fast] === nums[fast - 1]) {
      count++;
    } else {
      // 如果前一个元素只出现一次，则保留
      if (count === 1) {
        nums[slow] = nums[fast - 1];
        slow++;
      }
      count = 1; // 重置计数器
    }
  }
  
  // 处理最后一个元素
  if (count === 1) {
    nums[slow] = nums[nums.length - 1];
    slow++;
  }
  
  return slow;
}

// 使用示例
const nums = [1, 2, 2, 3, 4, 4, 5];
const newLength = removeDuplicates(nums);
console.log(nums.slice(0, newLength)); // [1, 3, 5]
```

## 删除链表的一个节点

**方案一：已知节点值，删除第一个匹配节点（需遍历链表）**

```javascript
function deleteNode(head, val) {
  // 处理头节点就是目标节点的情况
  if (head && head.val === val) {
    return head.next;
  }
  
  let current = head;
  // 遍历寻找目标节点
  while (current && current.next) {
    if (current.next.val === val) {
      current.next = current.next.next; // 删除节点
      return head;
    }
    current = current.next;
  }
  
  return head; // 未找到目标节点，返回原链表
}
```

**方案二：已知节点引用，直接删除该节点（无需遍历链表）**

```javascript
function deleteNode(node) {
  // 将下一个节点的值复制到当前节点
  node.val = node.next.val;
  // 跳过下一个节点，相当于删除当前节点
  node.next = node.next.next;
}
```



**注意**：此方法仅适用于待删除节点不是尾节点的情况，因为无法访问前一个节点。

**方案三：递归删除所有值匹配的节点**

```javascript
function deleteNode(head, val) {
  if (!head) return null;
  
  // 递归处理后续节点
  head.next = deleteNode(head.next, val);
  
  // 如果当前节点是目标节点，返回下一个节点；否则返回当前节点
  return head.val === val ? head.next : head;
}
```

## 实现列表转树

**方案一：基础递归法**

```javascript
function listToTree(list, parentId = null) {
  return list
    .filter(item => item.parentId === parentId)
    .map(item => ({
      ...item,
      children: listToTree(list, item.id)
    }));
}

// 使用示例
const list = [
  { id: 1, parentId: null },
  { id: 2, parentId: 1 },
  { id: 3, parentId: 1 },
  { id: 4, parentId: 2 }
];

console.log(listToTree(list));
// 输出:
// [
//   {
//     id: 1,
//     parentId: null,
//     children: [
//       { id: 2, parentId: 1, children: [{ id: 4, parentId: 2, children: [] }] },
//       { id: 3, parentId: 1, children: [] }
//     ]
//   }
// ]
```

**方案二：哈希表优化（O (n) 时间复杂度）**

```javascript
function listToTree(list) {
  const map = {};
  const roots = [];
  
  // 第一次遍历：将每个节点存入哈希表
  list.forEach(item => {
    map[item.id] = { ...item, children: [] };
  });
  
  // 第二次遍历：构建树结构
  list.forEach(item => {
    const node = map[item.id];
    if (item.parentId === null) {
      roots.push(node); // 根节点
    } else {
      if (map[item.parentId]) {
        map[item.parentId].children.push(node); // 添加到父节点的子节点列表
      }
    }
  });
  
  return roots;
}

// 使用示例（同上）
console.log(listToTree(list));
```

**方案三：支持自定义 ID 字段**

```javascript
function listToTree(list, options = {}) {
  const {
    idKey = 'id',
    parentKey = 'parentId',
    childrenKey = 'children',
    rootValue = null
  } = options;
  
  const map = {};
  const roots = [];
  
  list.forEach(item => {
    map[item[idKey]] = { ...item, [childrenKey]: [] };
  });
  
  list.forEach(item => {
    const node = map[item[idKey]];
    const parentId = item[parentKey];
    
    if (parentId === rootValue) {
      roots.push(node);
    } else {
      if (map[parentId]) {
        map[parentId][childrenKey].push(node);
      }
    }
  });
  
  return roots;
}

// 使用示例
const customList = [
  { uid: 1, pid: null },
  { uid: 2, pid: 1 },
  { uid: 3, pid: 2 }
];

console.log(listToTree(customList, {
  idKey: 'uid',
  parentKey: 'pid',
  childrenKey: 'subItems'
}));
```

## 实现树转列表

**方案一：深度优先遍历（递归）**

```javascript
function treeToList(tree, parentId = null, level = 0) {
  let list = [];
  
  tree.forEach(node => {
    // 复制节点并添加父节点信息
    const item = {
      ...node,
      parentId,
      level
    };
    
    list.push(item);
    
    // 递归处理子节点
    if (node.children && node.children.length > 0) {
      list = list.concat(
        treeToList(node.children, node.id, level + 1)
      );
    }
  });
  
  return list;
}

// 使用示例
const tree = [
  {
    id: 1,
    children: [
      { id: 2, children: [{ id: 4 }] },
      { id: 3 }
    ]
  }
];

console.log(treeToList(tree));
// 输出:
// [
//   { id: 1, parentId: null, level: 0 },
//   { id: 2, parentId: 1, level: 1 },
//   { id: 4, parentId: 2, level: 2 },
//   { id: 3, parentId: 1, level: 1 }
// ]
```

**方案二：广度优先遍历（队列实现）**

```javascript
function treeToList(tree) {
  const list = [];
  const queue = [];
  
  // 初始化队列
  tree.forEach(node => {
    queue.push({
      ...node,
      parentId: null,
      level: 0
    });
  });
  
  while (queue.length > 0) {
    const current = queue.shift();
    list.push(current);
    
    // 将子节点加入队列
    if (current.children && current.children.length > 0) {
      current.children.forEach(child => {
        queue.push({
          ...child,
          parentId: current.id,
          level: current.level + 1
        });
      });
    }
  }
  
  return list;
}

// 使用示例（同上）
console.log(treeToList(tree));
```

**方案三：自定义字段和处理函数**

```javascript
function treeToList(tree, options = {}) {
  const {
    childrenKey = 'children',
    processNode = node => node
  } = options;
  
  const list = [];
  
  function traverse(nodes, parentId = null, level = 0) {
    nodes.forEach(node => {
      // 处理节点数据
      const processedNode = processNode({
        ...node,
        parentId,
        level
      });
      
      list.push(processedNode);
      
      // 递归处理子节点
      const children = node[childrenKey] || [];
      traverse(children, node.id, level + 1);
    });
  }
  
  traverse(tree);
  return list;
}

// 使用示例
const customTree = [
  {
    uid: 1,
    subItems: [
      { uid: 2, subItems: [{ uid: 3 }] }
    ]
  }
];

console.log(treeToList(customTree, {
  childrenKey: 'subItems',
  processNode: node => ({
    id: node.uid,
    parent: node.parentId,
    depth: node.level
  })
}));
```

##  实现数组的 filter 方法

```javascript
// 注意：不建议直接修改原生原型
Array.prototype.customFilter = function(callback, thisArg) {
  const result = [];
  
  for (let i = 0; i < this.length; i++) {
    if (this.hasOwnProperty(i) && callback.call(thisArg, this[i], i, this)) {
      result.push(this[i]);
    }
  }
  
  return result;
};

// 使用示例
const numbers = [1, 2, 3];
const greaterThanTwo = numbers.customFilter(num => num > 2);
console.log(greaterThanTwo); // [3]
```



## 实现数组的 map 方法

```javascript
// 注意：不建议直接修改原生原型
Array.prototype.customMap = function(callback, thisArg) {
  const result = new Array(this.length);
  
  for (let i = 0; i < this.length; i++) {
    if (this.hasOwnProperty(i)) {
      result[i] = callback.call(thisArg, this[i], i, this);
    }
  }
  
  return result;
};

// 使用示例
const numbers = [1, 2, 3];
const squared = numbers.customMap(num => num ** 2);
console.log(squared); // [1, 4, 9]
```



## 实现 Object.create 方法

```javascript
function create(proto, propertiesObject = undefined) {
  if (typeof proto !== 'object' && typeof proto !== 'function') {
    throw new TypeError('Object prototype may only be an Object or null');
  }
  
  // 创建一个临时构造函数
  function F() {}
  F.prototype = proto; // 设置原型
  
  // 创建实例
  const obj = new F();
  
  // 处理属性描述符（如果有）
  if (propertiesObject !== undefined) {
    Object.defineProperties(obj, propertiesObject);
  }
  
  return obj;
}

// 使用示例
const person = { name: 'Default' };
const me = create(person, { age: { value: 30 } });
console.log(me.name); // 'Default'（继承自原型）
console.log(me.age);  // 30（自身属性）
```



## 模拟实现 instanceof 操作符

**方案一：标准实现（遍历原型链）**

```javascript
function myInstanceOf(obj, constructor) {
  // 处理基本类型（直接返回 false）
  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {
    return false;
  }
  
  // 获取对象的原型
  let proto = Object.getPrototypeOf(obj);
  
  // 遍历原型链
  while (proto !== null) {
    if (proto === constructor.prototype) {
      return true; // 找到匹配的原型
    }
    proto = Object.getPrototypeOf(proto); // 继续向上查找
  }
  
  return false; // 遍历完整个原型链仍未找到
}

// 使用示例
const arr = [];
console.log(myInstanceOf(arr, Array)); // true
console.log(myInstanceOf(arr, Object)); // true（所有对象都继承自 Object）
console.log(myInstanceOf(42, Number)); // false（基本类型）
```

**方案二：支持 Symbol.hasInstance**

```javascript
function myInstanceOf(obj, constructor) {
  // 处理基本类型
  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {
    return false;
  }
  
  // 检查构造函数是否有 Symbol.hasInstance 方法
  if (typeof constructor[Symbol.hasInstance] === 'function') {
    return constructor[Symbol.hasInstance](obj);
  }
  
  // 标准原型链检查
  let proto = Object.getPrototypeOf(obj);
  while (proto !== null) {
    if (proto === constructor.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  
  return false;
}

// 使用示例
class MyClass {
  static [Symbol.hasInstance](obj) {
    return obj instanceof Array; // 自定义 instanceof 行为
  }
}

console.log(myInstanceOf([], MyClass)); // true
```

## 模拟实现 new 操作符

**方案一：标准实现**

```javascript
function myNew(constructor, ...args) {
  // 1. 创建一个新对象
  const obj = {};
  
  // 2. 将新对象的原型设置为构造函数的 prototype
  Object.setPrototypeOf(obj, constructor.prototype);
  
  // 3. 执行构造函数并绑定 this
  const result = constructor.apply(obj, args);
  
  // 4. 如果构造函数返回对象，则返回该对象；否则返回新创建的对象
  return typeof result === 'object' && result !== null ? result : obj;
}

// 使用示例
function Person(name) {
  this.name = name;
}

const person = myNew(Person, 'Alice');
console.log(person.name); // 'Alice'
console.log(person instanceof Person); // true
```

**方案二：使用构造函数调用**

```javascript
function myNew(constructor, ...args) {
  // 创建一个临时构造函数
  function F() {}
  F.prototype = constructor.prototype;
  
  // 创建实例
  const obj = new F();
  
  // 执行构造函数
  const result = constructor.apply(obj, args);
  
  // 返回结果
  return typeof result === 'object' && result !== null ? result : obj;
}

// 使用示例
function Car(make) {
  this.make = make;
}

const car = myNew(Car, 'Toyota');
console.log(car.make); // 'Toyota'
```

**方案三：处理类和箭头函数**

```javascript
function myNew(constructor, ...args) {
  // 验证 constructor 是否为函数
  if (typeof constructor !== 'function') {
    throw new TypeError('Constructor must be a function');
  }
  
  // 创建对象并设置原型
  const obj = Object.create(constructor.prototype);
  
  // 执行构造函数
  const result = constructor.apply(obj, args);
  
  // 返回结果
  return typeof result === 'object' && result !== null ? result : obj;
}

// 使用示例
class Animal {
  constructor(name) {
    this.name = name;
  }
}

const animal = myNew(Animal, 'Dog');
console.log(animal.name); // 'Dog'
```

## 将数字转换成汉语的输出

```javascript
function convertToChinaNum(num) {
var arr1 = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
var arr2 = ['', '十', '百', '千', '万', '十', '百', '千', '亿', '十', '百', '千', '万', '十', '百', '千', '亿'];

if (!num || isNaN(num)) {
return "零";
}

var english = num.toString().split("");
var result = "";

for (var i = 0; i < english.length; i++) {
var des_i = english.length - 1 - i;
result = arr2[i] + result;
var arr1_index = english[des_i];
result = arr1[arr1_index] + result;
}

result = result.replace(/零(千|百|十)/g, '零').replace(/十零/g, '十');
result = result.replace(/零+/g, '零');
result = result.replace(/零亿/g, '亿').replace(/零万/g, '万');
result = result.replace(/亿万/g, '亿');
result = result.replace(/零+$/, '');
result = result.replace(/^一十/g, '十');

return result;
}
```



## 实现一个批量请求函数，要求能够限制并发量

```javascript
/**
 * 批量请求函数（限制并发量）
 * @param {Array<Function>} requests 请求函数数组，每个函数返回 Promise
 * @param {number} concurrency 最大并发量（默认 5）
 * @returns {Promise<Array>} 按顺序排列的结果数组（成功或错误）
 */
async function batchRequest(requests, concurrency = 5) {
  // 初始化结果数组（保持原始顺序）
  const results = new Array(requests.length);
  // 将请求包装为带索引的任务（确保结果顺序正确）
  const queue = requests.map((fn, index) => ({ fn, index }));

  // 工作线程：循环处理队列中的任务
  const worker = async () => {
    while (queue.length > 0) {
      // 取出队列头部的任务（FIFO）
      const { fn, index } = queue.shift();
      try {
        // 执行请求并记录结果
        const result = await fn();
        results[index] = { status: 'fulfilled', value: result };
      } catch (error) {
        // 捕获错误并记录
        results[index] = { status: 'rejected', reason: error };
      }
    }
  };

  // 启动工作线程（不超过并发量或队列长度）
  const workers = [];
  const maxWorkers = Math.min(concurrency, queue.length);
  for (let i = 0; i < maxWorkers; i++) {
    workers.push(worker());
  }

  // 等待所有工作线程完成，返回结果数组
  await Promise.all(workers);
  return results;
}
```



## 实现一个方法从路径获取文件名

**实现思路**

1. **统一路径分隔符**：将所有反斜杠（`\`）替换为斜杠（`/`），兼容 Windows 和 Unix 路径。
2. **清理末尾分隔符**：去除路径末尾的斜杠（如 `/user/doc/` → `/user/doc`）。
3. **分割路径部分**：按斜杠分割路径，提取最后一个非空片段（即文件名候选）。
4. **过滤查询 / 哈希**：从候选文件名中截断 `?` 或 `#` 后的内容（如 `file.txt?ver=1` → `file.txt`）。

**完整代码实现**

```javascript
function getFileName(path) {
  if (typeof path !== 'string' || path.length === 0) return '';

  // 1. 统一替换反斜杠为斜杠（兼容 Windows 路径）
  const normalized = path.replace(/\\/g, '/');

  // 2. 去除末尾的斜杠（如 "/user/doc/" → "/user/doc"）
  const trimmed = normalized.replace(/\/$/, '');

  // 3. 按斜杠分割路径，取最后一个非空片段
  const parts = trimmed.split('/').filter(part => part !== '');
  const fileNameWithParams = parts.length > 0 ? parts[parts.length - 1] : '';

  // 4. 截断查询（?）和哈希（#）部分（如 "file.txt?ver=1" → "file.txt"）
  const fileName = fileNameWithParams.split(/[?#]/)[0];

  return fileName;
}
```

## 实现一个下划线驼峰相互转换的函数

**实现思路**

1. 下划线转驼峰：
   - 合并连续下划线（如 `user__name` → `user_name`）。
   - 按下划线分割字符串，将后续部分首字母大写（小驼峰首字母小写，大驼峰首字母大写）。
2. 驼峰转下划线：
   - 在大写字母前插入下划线（如 `userName` → `user_name`）。
   - 统一转为小写，合并连续下划线。

**完整代码实现**

```javascript

function snakeCamelConvert(str, options) {
  if (typeof str !== 'string' || str.length === 0) return '';

  const { direction, camelCase = 'camel' } = options;

  if (direction === 'toCamel') {
    // 下划线转驼峰
    // 1. 合并连续下划线，分割为数组
    const parts = str
      .replace(/_+/g, '_') // 合并连续下划线
      .split('_')
      .filter(part => part !== ''); // 过滤空片段

    if (parts.length === 0) return '';

    // 2. 处理首字母（小驼峰小写，大驼峰大写）
    const firstPart = camelCase === 'pascal' 
      ? capitalize(parts[0]) 
      : parts[0].toLowerCase();

    // 3. 后续部分首字母大写
    const restParts = parts.slice(1).map(part => 
      capitalize(part.toLowerCase())
    );

    return [firstPart, ...restParts].join('');

  } else if (direction === 'toSnake') {
    // 驼峰转下划线
    // 1. 在大写字母前插入下划线（处理连续大写）
    let snakeStr = str
      .replace(/([a-z])([A-Z])/g, '$1_$2') // 小写后接大写 → 插入下划线
      .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2'); // 大写后接大写下接小写 → 插入下划线

    // 2. 统一转小写，合并连续下划线
    return snakeStr
      .toLowerCase()
      .replace(/_+/g, '_'); // 合并连续下划线

  } else {
    throw new Error('无效的转换方向，请使用 "toCamel" 或 "toSnake"');
  }
}

// 辅助函数：首字母大写
function capitalize(str) {
  if (str.length === 0) return '';
  return str[0].toUpperCase() + str.slice(1);
}
```

## 如下代码所示，实现一个 find 函数链式调用
```javascript
const data = [
 {userId: 0, name: ''},
 {userId: 1, name: '哈哈哈'},
 {userId: 2, name: '啦啦啦1'},
 {userId: 3, name: null},
 {userId: 3, name: '哦哦哦23'},
]
const result = find(data)
.where({
 title:/\d$/
})
.orderBy('userId','desc')
```

---

**通过链式方法累积条件，最终执行过滤与排序返回结果。**  

**实现过程：**  
```javascript  
function find(data) {  
  class Query {  
    constructor(data) {  
      this.data = data;  
      this.filters = [];  
      this.sortField = null;  
      this.sortOrder = 'asc';  
    }  

    // 添加过滤条件（支持正则、函数、值匹配）  
    where(conditions) {  
      const filters = Object.entries(conditions).map(([field, condition]) => {  
        if (condition instanceof RegExp) {  
          return (item) => {  
            const value = item[field];  
            return value != null && condition.test(String(value));  
          };  
        } else if (typeof condition === 'function') {  
          return (item) => condition(item[field]);  
        } else {  
          return (item) => item[field] === condition;  
        }  
      });  
      this.filters.push(...filters);  
      return this;  
    }  

    // 执行排序并返回结果  
    orderBy(field, order = 'asc') {  
      this.sortField = field;  
      this.sortOrder = order;  

      // 应用过滤  
      let result = this.data.filter(item =>  
        this.filters.every(filter => filter(item))  
      );  

      // 排序  
      result.sort((a, b) => {  
        const valA = a[field], valB = b[field];  
        const compare = typeof valA === 'number' ? valA - valB : String(valA).localeCompare(String(valB));  
        return order === 'desc' ? -compare : compare;  
      });  

      return result;  
    }  
  }  
  return new Query(data);  
}  

// 测试用例  
const data = [  
  {userId: 0, name: ''},  
  {userId: 1, name: '哈哈哈'},  
  {userId: 2, name: '啦啦啦1'},  
  {userId: 3, name: null},  
  {userId: 3, name: '哦哦哦23'},  
];  
const result = find(data)  
  .where({ name: /\d$/ }) // 过滤 name 以数字结尾的项  
  .orderBy('userId', 'desc'); // 按 userId 降序  

console.log(result);  
// 输出：[  
//   {userId:3, name: '哦哦哦23'},  
//   {userId:2, name: '啦啦啦1'}  
// ]  
```

**关键点说明：**  
1. **链式调用结构**：`where` 和 `orderBy` 返回 `this` 或结果，支持链式语法  
2. **灵活过滤**：支持正则（如 `/\d$/`）、函数、值匹配  
3. **空值处理**：`null`/`undefined` 字段自动过滤  
4. **排序兼容性**：支持数字与字符串混合排序  

**扩展方向：**  
- 添加 `limit`/`skip` 分页方法  
- 支持多字段排序（如 `orderBy('field1', 'desc').orderBy('field2')`）  
- 增加 `orWhere` 逻辑扩展条件

## 下面代码会输出什么？如何更正问题？

```javascript
for (var i = 0; i < 5; i++) {
 setTimeout(function() {
     console.log(i);
 }, 1000);
}
```

---

**输出**：5,5,5,5,5

**解决方法**：

- 闭包

```javascript
for (var i = 0; i < 5; i++) {
  (function (j) {
    setTimeout(() => console.log(j), 1000);
  })(i);
}
```

- **`let` 块级作用域**：

```javascript
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 1000);
}
```

## 版本号排序

有一组版本号如下['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5']。现在需要对其进行排序，排序的结果为 ['4.3.5','4.3.4.5','2.3.3','0.302.1','0.1.1']

---

```javascript
function versionSort(arr) {
  return arr.sort((a,b)=>{
    const arr1 = a.split('.')
    const arr2 = b.split('.')
    while(arr1.length || arr2.length){
      const a1 = arr1.shift()
      const b1 = arr2.shift()
      if(!a1)return -1
      if(!b1)return 1
      if(a1!==b1){
        return a1 - b1
      }
    }
  })
}
```

## 如何使对象 iterable 化， 使其可以支持 for...of 迭代

**通过实现 `Symbol.iterator` 迭代器协议，定义对象属性的遍历规则。**

**实现过程：**  
```javascript  
// 方案一：对象直接实现迭代器协议  
class MyIterable {  
  constructor(data) {  
    this.data = data;  
  }  

  // 定义迭代规则（遍历对象的属性值）  
  [Symbol.iterator]() {  
    const entries = Object.entries(this.data);  
    let index = 0;  
    return {  
      next: () => {  
        if (index < entries.length) {  
          const [key, value] = entries[index++];  
          return { value: value, done: false }; // 迭代值  
        }  
        return { done: true }; // 终止迭代  
      }  
    };  
  }  
}  

// 使用示例  
const obj = new MyIterable({ a: 1, b: 2, c: 3 });  
for (const val of obj) {  
  console.log(val); // 输出：1, 2, 3  
}  

// ---------------  
// 方案二：更简洁的生成器函数写法  
class MyIterableGenerator {  
  constructor(data) {  
    this.data = data;  
  }  

  // 生成器自动实现迭代器  
  *[Symbol.iterator]() {  
    for (const key in this.data) {  
      yield this.data[key]; // 按需调整迭代内容（如 yield [key, value]）  
    }  
  }  
}  

// 使用示例  
const obj2 = new MyIterableGenerator({ x: 10, y: 20 });  
for (const val of obj2) {  
  console.log(val); // 输出：10, 20  
}  
```

**关键点说明：**  
1. **迭代协议要求**：  
   - 对象必须包含 `[Symbol.iterator]` 方法  
   - 该方法返回一个带有 `next()` 方法的迭代器对象  
   - `next()` 返回 `{ value: any, done: boolean }`  

2. **遍历内容控制**：  
   - 若需迭代键值对，修改为 `yield [key, value]`  
   - 若需过滤属性，可在生成器中添加条件（如 `if (key !== 'id')`）  

3. **支持复杂结构**：  
   ```javascript  
   // 示例：嵌套对象平铺迭代  
   *[Symbol.iterator]() {  
     for (const key in this.data) {  
       if (typeof this.data[key] === 'object') {  
         yield* this.data[key]; // 递归迭代  
       } else {  
         yield this.data[key];  
       }  
     }  
   }  
   ```

**扩展场景：**  
- **兼容普通对象**：直接为对象添加迭代器  
  ```javascript  
  const obj = { a: 1, b: 2 };  
  obj[Symbol.iterator] = function* () {  
    for (const key in this) {  
      if (this.hasOwnProperty(key)) yield this[key];  
    }  
  };  
  ```
- **反向迭代**：调整遍历顺序（如 `Object.keys(this.data).reverse()`）


## 实现一个 HTML 模板转义函数

```javascript
/**
 * HTML 转义函数（防止 XSS 攻击）
 * @param {string} str 要转义的字符串
 * @returns {string} 转义后的字符串
 */
function htmlEscape(str) {
  // 处理非字符串输入（如 null/undefined）
  if (typeof str !== 'string') return '';

  // 预定义转义映射（键为特殊字符，值为 HTML 实体）
  const escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  // 使用正则全局匹配特殊字符，替换为对应的实体
  return str.replace(/[&<>"']/g, (char) => escapeMap[char]);
}
```



## 实现一个文件监控工具

**通过文件系统监听库（如 `chokidar`）实现跨平台监控，结合事件驱动与过滤配置，提供实时变化通知。**

**实现过程：**  
1. **依赖安装**：使用 `chokidar`（高效跨平台监听库）  
   ```bash  
   npm install chokidar  
   ```

2. **核心监控类实现**：  
   ```javascript  
   const chokidar = require('chokidar');  
   const path = require('path');  
   
   class FileWatcher {  
     constructor(targetPath, options = {}) {  
       this.targetPath = targetPath;  
       this.options = {  
         ignored: /(^|[\/\\])\../, // 默认忽略隐藏文件  
         persistent: true,          // 持续监听  
         ignoreInitial: true,       // 忽略初始化扫描  
         ...options  
       };  
       this.watcher = null;  
     }  
   
     // 启动监听  
     start() {  
       this.watcher = chokidar.watch(this.targetPath, this.options);  
   
       // 绑定事件监听  
       this.watcher  
         .on('add', (filePath) => this._handleEvent('add', filePath))  
         .on('change', (filePath) => this._handleEvent('change', filePath))  
         .on('unlink', (filePath) => this._handleEvent('delete', filePath))  
         .on('error', (error) => console.error(`Watcher error: ${error}`));  
   
       console.log(`开始监控: ${this.targetPath}`);  
     }  
   
     // 处理事件（可扩展自定义逻辑）  
     _handleEvent(eventType, filePath) {  
       const filename = path.basename(filePath);  
       console.log(`[${eventType}] ${filename} | 路径: ${filePath}`);  
     }  
   
     // 停止监听  
     stop() {  
       if (this.watcher) {  
         this.watcher.close();  
         console.log('监控已停止');  
       }  
     }  
   }  
   ```

3. **使用示例**：  
   ```javascript  
   // 监控当前目录下的.js文件，忽略node_modules  
   const watcher = new FileWatcher('./**/*.js', {  
     ignored: '**/node_modules/**'  
   });  
   
   watcher.start();  
   
   // 30秒后停止（演示用）  
   setTimeout(() => watcher.stop(), 30000);  
   ```

**扩展功能：**  
- **自定义过滤**：通过 `options.ignored` 配置正则/函数  
  ```javascript  
  // 忽略所有.jpg文件和build目录  
  ignored: (filePath) =>  
    filePath.endsWith('.jpg') || filePath.includes('/build/')  
  ```
- **实时响应**：结合 WebSocket 推送前端页面更新  
- **日志记录**：将文件变动写入日志文件（如 `fs.appendFile`）  
- **性能优化**：调整 `interval`（轮询间隔，默认100ms）  

**执行效果：**  
```  
开始监控: ./**/*.js  
[add] index.js | 路径: /project/src/index.js  
[change] utils.js | 路径: /project/src/utils.js  
[delete] old.js | 路径: /project/src/old.js  
```

**关键优势：**  

- **跨平台**：基于 `chokidar` 自动适配 Windows/macOS/Linux  
- **高效低开销**：使用原生文件系统事件（非轮询）  
- **易扩展**：支持自定义事件处理器与过滤规则

## 实现一个简单的状态管理库

**通过订阅者模式维护状态变更，提供状态获取、更新及监听能力。**

**实现过程：**  
```javascript  
class SimpleStore {  
  constructor(initialState = {}) {  
    this.state = initialState;  
    this.subscribers = new Set(); // 使用 Set 避免重复订阅  
  }  

  // 获取当前状态  
  getState() {  
    return { ...this.state }; // 返回浅拷贝防止外部直接修改  
  }  

  // 更新状态（支持对象或函数形式）  
  setState(updater) {  
    const prevState = this.state;  
    this.state = typeof updater === 'function'  
      ? { ...prevState, ...updater(prevState) }  
      : { ...prevState, ...updater };  

    this._notify(prevState);  
  }  

  // 订阅状态变化  
  subscribe(listener) {  
    this.subscribers.add(listener);  
    return () => this.unsubscribe(listener); // 返回取消订阅函数  
  }  

  // 取消订阅  
  unsubscribe(listener) {  
    this.subscribers.delete(listener);  
  }  

  // 私有方法：通知所有订阅者  
  _notify(prevState) {  
    // 使用 Array.from 创建副本防止遍历时修改 Set  
    Array.from(this.subscribers).forEach(listener => {  
      listener(this.getState(), prevState);  
    });  
  }  
}  
```

**使用示例：**  
```javascript  
// 初始化  
const store = new SimpleStore({ count: 0, user: null });  

// 订阅变化  
const unsubscribe = store.subscribe((newState, oldState) => {  
  console.log('状态变更:', oldState, '→', newState);  
});  

// 更新状态  
store.setState({ count: 1 });  
// 输出：状态变更: {count:0, user:null} → {count:1, user:null}  

store.setState(prev => ({ count: prev.count + 1 }));  
// 输出：状态变更: {count:1, user:null} → {count:2, user:null}  

// 取消订阅  
unsubscribe();  
store.setState({ user: 'Alice' }); // 无输出  
```

**核心机制说明：**  
1. **不可变状态**：每次更新生成新对象，确保引用变化可追踪  
2. **安全更新**：通过函数式更新避免依赖过时状态  
3. **高效通知**：使用 `Set` 管理订阅者，自动去重  

**扩展能力：**  
- **中间件支持**：在 `setState` 前后插入钩子（如日志记录）  
  ```javascript  
  applyMiddleware(...middlewares) {  
    middlewares.forEach(middleware => {  
      const originalSetState = this.setState;  
      this.setState = (updater) => {  
        middleware(prevState => originalSetState(updater), this.getState);  
      };  
    });  
  }  
  ```
- **持久化**：结合 `localStorage` 自动保存/恢复状态  
- **异步操作**：封装 `setState` 支持 Promise  
  ```javascript  
  async setStateAsync(asyncUpdater) {  
    const newState = await asyncUpdater(this.getState());  
    this.setState(newState);  
  }  
  ```

## 实现一个全局事件总线

**通过发布-订阅模式管理事件监听与触发，支持全局通信、多事件处理及一次性监听。**

**实现过程：**  
```javascript  
class EventBus {  
  constructor() {  
    this.events = new Map();  // 使用 Map 存储事件与回调关系  
  }  

  // 订阅事件  
  on(event, callback) {  
    if (!this.events.has(event)) {  
      this.events.set(event, new Set());  
    }  
    this.events.get(event).add(callback);  
  }  

  // 取消订阅  
  off(event, callback) {  
    if (!this.events.has(event)) return;  
    const callbacks = this.events.get(event);  
    callbacks.delete(callback);  
    if (callbacks.size === 0) this.events.delete(event);  
  }  

  // 触发事件（同步执行，复制回调列表避免迭代中修改）  
  emit(event, ...args) {  
    if (!this.events.has(event)) return;  
    const callbacks = [...this.events.get(event)]; // 复制数组  
    for (const cb of callbacks) {  
      try {  
        cb(...args);  
      } catch (e) {  
        console.error(`事件 ${event} 的回调执行失败:`, e);  
      }  
    }  
  }  

  // 一次性订阅  
  once(event, callback) {  
    const onceWrapper = (...args) => {  
      callback(...args);  
      this.off(event, onceWrapper);  
    };  
    this.on(event, onceWrapper);  
  }  
}  

// 创建全局单例  
const eventBus = new EventBus();  
export default eventBus;  
```



**使用示例：**  
```javascript  
// 订阅事件  
const handleClick = (data) => console.log('点击事件:', data);  
eventBus.on('click', handleClick);  

// 触发事件  
eventBus.emit('click', { x: 100, y: 200 }); // 输出：点击事件: {x:100, y:200}  

// 取消订阅  
eventBus.off('click', handleClick);  

// 一次性订阅  
eventBus.once('load', () => console.log('资源加载完成！'));  
eventBus.emit('load'); // 输出：资源加载完成！  
eventBus.emit('load'); // 无输出  
```

**关键机制说明：**  
1. **数据结构优化**：  
   - 使用 `Map` 存储事件，`Set` 存储回调，提升查询与去重效率  
2. **执行安全**：  
   - `emit` 时复制回调列表，防止执行过程中修改原数组导致错误  
   - `try/catch` 捕获异常，避免单个回调阻塞整体流程  
3. **内存管理**：  
   - 无回调的事件自动清理（`off` 中检查 `size === 0` 时删除键）  

**扩展功能：**  
- **异步触发**：支持 `emitAsync`（返回 Promise.all 执行）  
  ```javascript  
  async emitAsync(event, ...args) {  
    if (!this.events.has(event)) return [];  
    const callbacks = [...this.events.get(event)];  
    return Promise.all(callbacks.map(cb => cb(...args)));  
  }  
  ```
- **通配符监听**：支持 `*` 监听所有事件  
  ```javascript  
  on('*', (event, data) => console.log('全局事件:', event, data));  
  emit('msg', 'Hi') // 触发 '*' 监听 → 输出：全局事件: msg Hi  
  ```
- **上下文绑定**：允许指定回调的 `this` 指向  
  ```javascript  
  on('event', callback, context) {  
    const boundCb = callback.bind(context);  
    this.events.get(event).add(boundCb);  
  }  
  ```

## 实现一个插件系统

**通过插件注册机制、生命周期钩子及统一API注入，实现灵活可扩展的插件管理。**

**实现过程：**  
```javascript  
class PluginSystem {  
  constructor() {  
    this.plugins = new Map();    // 存储插件实例  
    this.hooks = new Map();      // 生命周期钩子：{ hookName: [fn1, fn2] }  
    this.api = {};               // 向插件暴露的API  
  }  

  // 注册插件（支持配置项）  
  register(plugin, options = {}) {  
    if (this.plugins.has(plugin.name)) {  
      throw new Error(`插件 ${plugin.name} 已存在`);  
    }  

    const pluginInstance = {  
      ...plugin,  
      options,  
      enabled: true  
    };  

    // 执行插件安装逻辑  
    if (typeof plugin.install === 'function') {  
      plugin.install(this.api, options);  
    }  

    // 注册生命周期钩子  
    if (plugin.hooks) {  
      Object.entries(plugin.hooks).forEach(([hookName, hookFn]) => {  
        this._addHook(hookName, hookFn);  
      });  
    }  

    this.plugins.set(plugin.name, pluginInstance);  
  }  

  // 添加钩子函数  
  _addHook(hookName, hookFn) {  
    if (!this.hooks.has(hookName)) {  
      this.hooks.set(hookName, []);  
    }  
    this.hooks.get(hookName).push(hookFn);  
  }  

  // 触发钩子（支持异步）  
  async triggerHook(hookName, ...args) {  
    if (!this.hooks.has(hookName)) return;  

    const hooks = this.hooks.get(hookName);  
    for (const hook of hooks) {  
      try {  
        await hook(...args);  // 支持异步钩子  
      } catch (e) {  
        console.error(`插件钩子 ${hookName} 执行失败:`, e);  
      }  
    }  
  }  

  // 卸载插件  
  unregister(pluginName) {  
    const plugin = this.plugins.get(pluginName);  
    if (!plugin) return;  

    // 执行插件卸载逻辑  
    if (typeof plugin.uninstall === 'function') {  
      plugin.uninstall(this.api);  
    }  

    // 移除相关钩子  
    if (plugin.hooks) {  
      Object.keys(plugin.hooks).forEach(hookName => {  
        const hooks = this.hooks.get(hookName).filter(fn => fn !== plugin.hooks[hookName]);  
        this.hooks.set(hookName, hooks);  
      });  
    }  

    this.plugins.delete(pluginName);  
  }  
}  

// 示例插件定义  
const loggerPlugin = {  
  name: 'logger',  
  install(api, options) {  
    api.log = (msg) => console.log(`[LOG] ${msg}`);  
  },  
  hooks: {  
    'beforeUpdate': (data) => console.log('更新前数据:', data),  
    'afterUpdate': async (data) => {  
      await new Promise(resolve => setTimeout(resolve, 1000));  
      console.log('更新完成');  
    }  
  }  
};  

// 使用示例  
const system = new PluginSystem();  
system.register(loggerPlugin, { logLevel: 'debug' });  

// 触发钩子  
system.triggerHook('beforeUpdate', { id: 1 });  
// 输出：更新前数据: {id:1}  
system.api.log('测试消息'); // 输出：[LOG] 测试消息  
```



**关键机制说明：**  
1. **插件结构**：  
   - **install/uninstall**：安装/卸载时执行的初始化与清理逻辑  
   - **hooks**：生命周期钩子函数（如 `beforeUpdate`、`afterUpdate`）  

2. **API 注入**：通过 `this.api` 向插件暴露可控的宿主能力  

3. **错误隔离**：单个钩子错误不影响其他钩子执行  



**扩展功能：**  
- **插件依赖管理**：  
  ```javascript  
  register(plugin) {  
    if (plugin.dependencies) {  
      plugin.dependencies.forEach(dep => {  
        if (!this.plugins.has(dep)) throw new Error(`依赖插件 ${dep} 未安装`);  
      });  
    }  
    // ...原有注册逻辑  
  }  
  ```
- **插件状态管理**：添加启用/禁用接口  
  ```javascript  
  enablePlugin(name) {  
    const plugin = this.plugins.get(name);  
    plugin.enabled = true;  
  }  
  ```
- **配置合并**：支持全局配置与插件独立配置  
  ```javascript  
  constructor(baseConfig) {  
    this.config = { ...baseConfig };  
  }  
  register(plugin, localConfig) {  
    const mergedConfig = { ...this.config.pluginDefaults, ...localConfig };  
    // ...  
  }  
  ```

**适用场景**：  
- 框架扩展（如Vue插件、Webpack插件）  
- 应用功能模块化（如仪表盘小部件）  
- 微前端架构中的子应用通信

## 实现一个跨标签页通信方案

**通过 localStorage 的 storage 事件监听，结合消息唯一标识，实现同源跨标签页实时通信。**

**实现过程：**  
```javascript  
class CrossTabCommunicator {  
  constructor(namespace = 'cross_tab') {  
    this.namespace = namespace;  
    this.listeners = new Map(); // 存储事件类型与回调关系  
    this.uuid = Math.random().toString(36).slice(2); // 唯一标识当前标签页  

    // 监听 storage 事件  
    window.addEventListener('storage', (e) => {  
      if (e.key !== this.namespace || e.newValue === null) return;  

      try {  
        const { type, data, from } = JSON.parse(e.newValue);  
        // 过滤自身触发的消息  
        if (from === this.uuid) return;  

        const callbacks = this.listeners.get(type) || [];  
        callbacks.forEach(cb => cb(data));  
      } catch (error) {  
        console.error('消息解析失败:', error);  
      }  
    });  
  }  

  // 发送消息  
  send(type, data) {  
    const message = JSON.stringify({  
      type,  
      data,  
      from: this.uuid,  
      timestamp: Date.now()  
    });  
    // 通过修改 localStorage 触发事件（需先删除旧值确保触发）  
    localStorage.removeItem(this.namespace);  
    localStorage.setItem(this.namespace, message);  
  }  

  // 监听消息  
  on(type, callback) {  
    if (!this.listeners.has(type)) {  
      this.listeners.set(type, []);  
    }  
    this.listeners.get(type).push(callback);  
    // 返回取消监听函数  
    return () => this.off(type, callback);  
  }  

  // 移除监听  
  off(type, callback) {  
    const callbacks = this.listeners.get(type) || [];  
    this.listeners.set(  
      type,  
      callbacks.filter(cb => cb !== callback)  
    );  
  }  
}  

// 使用示例  
const communicator = new CrossTabCommunicator();  

// 标签页A发送消息  
communicator.send('alert', { text: '新消息来了！' });  

// 标签页B监听消息  
const removeListener = communicator.on('alert', (data) => {  
  console.log('收到消息:', data.text); // 输出：收到消息: 新消息来了！  
});  

// 停止监听  
// removeListener();  
```

**核心机制说明：**  
1. **消息过滤**：  
   - 通过 `uuid` 标识当前标签页，避免接收自己发送的消息  
   - 消息格式包含 `type`（事件类型）和 `data`（负载数据）  

2. **存储触发**：  
   - 先 `removeItem` 再 `setItem` 确保每次修改都能触发 `storage` 事件（同值修改不会触发）  

3. **自动清理**：  
   - 无内置清理逻辑，需业务层处理过期消息（可通过 `timestamp` 过滤旧消息）  



**替代方案对比：**  
- **BroadcastChannel API**：更现代且高效，但兼容性较差（不支持 IE/Safari <15.4）  
  ```javascript  
  const channel = new BroadcastChannel('my_channel');  
  channel.postMessage({ type: 'msg', data: 'Hi' });  
  ```
- **SharedWorker**：适合复杂场景（如大量数据交换），但实现成本较高  
- **window.postMessage**：需通过 opener 引用其他窗口，适用面窄  



**扩展优化：**  
- **消息加密**：敏感数据使用 `CryptoJS` 加密后传输  
- **心跳检测**：定时发送心跳包检测其他标签页存活状态  
- **自动重试**：消息发送失败时（如 localStorage 已满）加入队列重试  
- **限流策略**：防止高频消息导致性能问题  
  ```javascript  
  send(type, data) {  
    // 使用节流控制发送频率  
    if (this.throttleTimer) return;  
    this.throttleTimer = setTimeout(() => {  
      // ...原发送逻辑  
      this.throttleTimer = null;  
    }, 100);  
  }  
  ```


## 基于 WebGl 实现 3D 立方体旋转动画

**通过 WebGL 绘制立方体顶点数据，结合变换矩阵与动画循环实现旋转效果。**  

**具体实现过程：**  

1. **初始化 WebGL 基础结构**：  
   - 创建 `<canvas>` 元素，获取 WebGL 上下文。  
   - 编写**顶点着色器**（处理坐标与矩阵变换）和**片段着色器**（固定颜色或动态计算颜色）。  

2. **定义立方体数据**：  
   - 顶点坐标（8 个顶点，含 x/y/z）。  
   - 顶点索引（12 个三角形，共 36 个索引，避免重复顶点）。  

3. **绑定缓冲区与着色器**：  
   - 将顶点和索引数据传入 GPU 缓冲区（`gl.createBuffer` + `gl.bufferData`）。  
   - 编译着色器并链接到 WebGL 程序。  

4. **矩阵变换与动画**：  
   - 创建模型矩阵（旋转）、视图矩阵（相机位置）、投影矩阵（透视）。  
   - 在渲染循环中用 `requestAnimationFrame` 更新旋转角度，合并矩阵并传入着色器。  

**示例核心代码片段**：  
```javascript  
// 顶点着色器（GLSL）  
const vertexShader = `  
  attribute vec3 position;  
  uniform mat4 modelViewProjection;  
  void main() {  
    gl_Position = modelViewProjection * vec4(position, 1.0);  
  }  
`;  

// 初始化旋转  
let angle = 0;  
function animate() {  
  angle += 0.01;  
  const model = mat4.create();  
  mat4.rotate(model, model, angle, [0, 1, 0]); // 绕 Y 轴旋转  
  const mvp = mat4.create();  
  mat4.multiply(mvp, viewProjMatrix, model); // 合并矩阵  
  gl.uniformMatrix4fv(mvpLocation, false, mvp);  
  gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);  
  requestAnimationFrame(animate);  
}  
```

**关键优化点**：  
- 使用 `gl.TRIANGLES` + 索引缓冲区减少数据量。  
- 矩阵运算库（如 `gl-matrix`）简化矩阵操作。  
- 避免每帧重复绑定静态缓冲区。
