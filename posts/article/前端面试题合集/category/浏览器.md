---
category: 浏览器
order: 11
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/article/前端面试题合集/read.html">
</nav-head>


# 浏览器

## 常见的浏览器内核有哪些？

浏览器内核的核心是**实现网页渲染和脚本执行的基础引擎**，常见内核可分为渲染引擎与 JavaScript 引擎两类。以下是具体分类与代表浏览器：

**一、渲染引擎（Rendering Engine）**

1. **Trident（IE 内核）**
   - **特点**：微软开发，兼容旧版 IE 标准，性能较差。
   - **代表浏览器**：IE（已停更）、旧版 Edge（2019 年前）、国内双核浏览器的兼容模式（如 360 浏览器）。
2. **Gecko（Firefox 内核）**
   - **特点**：开源，支持现代 Web 标准严格，扩展性强。
   - **代表浏览器**：Mozilla Firefox、Waterfox。
3. **WebKit（Safari 内核）**
   - **特点**：苹果主导，轻量高效，移动端优化。
   - **代表浏览器**：Safari、旧版 Chrome（2013 年前）。
4. **Blink（Chrome/Edge 内核）**
   - **特点**：WebKit 的分支，Google 主导开发，高性能，快速迭代。
   - **代表浏览器**：Chrome、新版 Edge（2019 后）、Opera、大部分国产浏览器（如 QQ 浏览器）。
5. **Presto（已废弃）**
   - **特点**：Opera 自主研发，渲染速度快，兼容性差。
   - **历史浏览器**：Opera（2013 年前）。

**二、JavaScript 引擎**

1. **V8（Chrome/Node.js）**
   - **特点**：Google 开发，高性能，支持即时编译（JIT）。
2. **SpiderMonkey（Firefox）**
   - **特点**：Mozilla 开发，首个 JavaScript 引擎。
3. **JavaScriptCore（Safari）**
   - **特点**：苹果开发，原名 Nitro，针对移动端优化。

**三、国内浏览器内核现状**

1. **双核模式**：
   - 兼容模式：Trident（处理老旧政府/企业网站）。
   - 极速模式：Blink（默认模式，如 360 浏览器、搜狗浏览器）。
2. **自主内核（探索阶段）**：
   - 如华为 HarmonyOS 的 Ark 引擎（基于 Chromium 二次开发）。

**四、核心差异与趋势**

- **性能对比**：Blink > WebKit > Gecko > Trident。
- **市场份额**：Blink（Chrome/Edge 主导）> WebKit（Safari 移动端优势）。
- **开发方向**：Blink 持续推动 Web 新特性（如 WebGPU），Trident 逐渐淘汰。

**总结**：现代浏览器以 Blink 和 WebKit 为主流内核，兼容性测试需覆盖 Chrome、Safari、Firefox，国内项目额外关注双核浏览器的 Trident 模式。

## 浏览器的主要组成部分有哪些？各自的作用是什么？

**浏览器的主要组成部分及其作用**

浏览器是一个复杂的软件系统，由多个核心组件协同工作，实现网页的加载、渲染和交互。以下是主要组件及其功能：

**1. 用户界面（User Interface）**  

- **作用**：提供用户与浏览器交互的视觉界面，包括地址栏、前进/后退按钮、书签栏、设置菜单等。  
- **示例**：Chrome 的标签页管理、Firefox 的侧边栏工具。

**2. 浏览器引擎（Browser Engine）**  

- **作用**：协调用户界面与渲染引擎之间的操作，处理用户输入（如 URL 输入、点击事件）并触发页面加载或刷新。  
- **核心任务**：  
  - 解析用户输入的 URL，调用网络组件加载资源。  
  - 管理前进/后退历史记录（通过 `History API`）。  
- **常见实现**：Chrome/Edge 的 Blink、Firefox 的 Gecko。

**3. 渲染引擎（Rendering Engine）**  

- **作用**：解析 HTML、CSS 并渲染页面内容，生成可视化布局。  
- **关键流程**：  
  1. **解析 HTML** → 构建 DOM 树。  
  2. **解析 CSS** → 构建 CSSOM 树。  
  3. **合并 DOM + CSSOM** → 生成渲染树（Render Tree）。  
  4. **布局（Layout/Reflow）** → 计算元素位置和尺寸。  
  5. **绘制（Paint）** → 将元素转换为屏幕像素。  
  6. **合成（Composite）** → 合并图层，输出最终画面。  
- **常见实现**：Blink（Chrome/Edge）、WebKit（Safari）、Gecko（Firefox）。

**4. 网络组件（Networking）**  

- **作用**：处理网络通信，包括 HTTP/HTTPS 请求、DNS 解析、TCP 连接管理。  
- **核心功能**：  
  - 实现缓存策略（强缓存、协商缓存）。  
  - 管理 HTTP/2、HTTP/3（QUIC）多路复用。  
  - 处理跨域请求（CORS）和安全策略（如 CSP）。  
- **示例**：Chrome 使用 `Cronet` 网络库。

**5. JavaScript 引擎（JavaScript Engine）**  

- **作用**：解析和执行 JavaScript 代码，驱动页面动态交互。  
- **核心流程**：  
  1. **解析** → 将 JS 代码转换为抽象语法树（AST）。  
  2. **编译** → 生成字节码或机器码（通过 JIT 编译器）。  
  3. **执行** → 运行代码并管理调用栈、内存堆。  
  4. **垃圾回收** → 自动回收不再使用的内存。  
- **常见引擎**：V8（Chrome/Node.js）、SpiderMonkey（Firefox）、JavaScriptCore（Safari）。

**6. UI 后端（UI Backend）**  

- **作用**：提供绘制基础控件（如按钮、输入框）的底层接口，与操作系统交互。  
- **核心功能**：  
  - 调用系统 API 绘制原生控件。  
  - 处理字体渲染、颜色管理等。  
- **示例**：Chrome 使用 Skia 图形库实现跨平台绘图。

**7. 数据持久化层（Data Persistence）**  

- **作用**：管理浏览器本地存储和缓存数据。  
- **核心存储类型**：  
  - **Cookie**：存储会话信息（如用户登录态）。  
  - **Web Storage**：`localStorage`（长期存储）、`sessionStorage`（会话级存储）。  
  - **IndexedDB**：结构化数据存储（类似小型数据库）。  
  - **Cache API**：Service Worker 离线缓存。  
- **示例**：Chrome 的 `LevelDB` 用于 IndexedDB 存储。

**8. 浏览器进程模型（Process Model）**  

- **作用**：现代浏览器采用多进程架构，提升稳定性、安全性和性能。  
- **常见进程类型**（以 Chrome 为例）：  
  - **浏览器主进程（Browser Process）**：管理全局功能（如书签、历史）。  
  - **渲染进程（Renderer Process）**：每个标签页独立进程，运行渲染引擎和 JS 引擎。  
  - **GPU 进程（GPU Process）**：处理图形渲染和硬件加速。  
  - **网络进程（Network Process）**：管理所有网络请求。  
  - **插件进程（Plugin Process）**：运行第三方插件（如 Flash）。  
- **优势**：单标签页崩溃不影响其他页面，隔离安全风险。

**组件协作流程示例**  

1. **用户输入 URL** → 浏览器引擎解析 URL，触发网络组件请求资源。  
2. **网络组件加载 HTML** → 渲染引擎解析并构建 DOM/CSSOM。  
3. **JS 引擎执行脚本** → 动态修改 DOM/CSSOM，触发重排或重绘。  
4. **GPU 进程合成最终画面** → 输出到屏幕。  

**总结**  

浏览器通过多组件分工协作，将代码转换为用户可交互的页面。理解其内部机制有助于：  
- **性能优化**：如减少重排、合理使用缓存。  
- **调试定位**：分析渲染阻塞、内存泄漏等问题。  
- **安全防护**：避免 XSS、CSRF 等攻击。  

**延伸问题**：  
- 浏览器如何实现沙箱（Sandbox）安全机制？  
- 从输入 URL 到页面显示的具体过程是什么？  
- 渲染引擎如何处理 `async`/`defer` 脚本？

## 说一说从输入 URL 到页面呈现发生了什么？

从输入 URL 到页面呈现的完整流程可以分为以下几个阶段，涵盖了网络通信、服务器处理、浏览器渲染等关键步骤：

**1. URL 解析与 DNS 查询**

- **输入处理**：浏览器解析 URL 格式（协议、域名、路径等），若非法则触发搜索引擎搜索。
- **DNS 解析**：
  - 浏览器缓存 → 系统缓存 → 路由器缓存 → 本地 DNS 服务器 → 递归查询根/顶级/权威 DNS 服务器。
  - 最终获取目标服务器的 **IP 地址**。
- **DNS 优化**：预解析（`<link rel="dns-prefetch">`）、CDN 域名分片。

**2. 建立网络连接**

- **TCP 三次握手**：客户端与服务器通过 SYN、SYN-ACK、ACK 包建立可靠连接。
  ```plaintext
  客户端 → SYN → 服务端
  客户端 ← SYN-ACK ← 服务端
  客户端 → ACK → 服务端
  ```
- **TLS 握手**（HTTPS 场景）：
  - 协商加密协议版本（TLS 1.2/1.3）。
  - 交换证书、验证身份、生成会话密钥（如 ECDHE 密钥交换）。

**3. 发送 HTTP 请求**

- **构造请求报文**：方法（GET/POST）、路径、协议版本、Headers（User-Agent、Cookie、Accept 等）。
- **请求缓存**：
  - 强缓存（`Cache-Control`/`Expires`）直接返回本地资源。
  - 协商缓存（`ETag`/`Last-Modified`）由服务器判断是否返回 304。

**4. 服务器处理请求**

- **负载均衡**：请求可能被反向代理（Nginx）分发到集群中的某台服务器。
- **业务逻辑处理**：执行 API 路由、数据库查询、身份验证等。
- **生成响应**：返回状态码（200/404/500 等）、Headers（Content-Type、Set-Cookie）、Body（HTML/JSON）。

**5. 浏览器解析与渲染**

**解析阶段**

- **HTML 解析**：逐行解析生成 **DOM 树**，遇到 `<script>` 会阻塞（除非标记 `async/defer`）。
- **CSS 解析**：解析外部/内联 CSS，生成 **CSSOM 树**。
- **构建渲染树（Render Tree）**：合并 DOM 和 CSSOM，排除不可见节点（如 `display: none`）。

**布局与绘制**

- **布局（Layout/Reflow）**：计算渲染树节点的几何位置（盒模型、浮动、定位）。
- **分层（Layer）**：将页面划分为多个图层（如 `transform` 会触发独立图层）。
- **绘制（Paint）**：将各图层转换为位图，输出到合成线程。
- **合成（Composite）**：合成线程将图层拼接成最终页面，通过 GPU 光栅化显示。

**JavaScript 执行**

- **编译与执行**：V8 引擎解析 JS，生成字节码，通过 JIT 编译优化。
- **事件循环**：处理任务队列（宏任务、微任务）、渲染帧（`requestAnimationFrame`）。

**6. 加载子资源**

- **预加载扫描器（Preload Scanner）**：并行请求 HTML 中发现的资源（图片、CSS、JS）。
- **资源优先级**：浏览器根据类型（CSS 阻塞渲染，JS 可能阻塞解析）调整加载顺序。

**7. 关键优化点**

- **网络层**：HTTP/2 多路复用、资源压缩（Brotli）、CDN 加速、域名分片。
- **渲染层**：减少重排/重绘、使用 CSS3 动画、延迟加载非关键资源（`loading="lazy"`）。
- **缓存策略**：Service Worker 离线缓存、内存缓存（Memory Cache）、磁盘缓存（Disk Cache）。

**示例流程**

```
输入 URL → DNS 解析 → TCP/TLS 握手 → 发送 HTTP 请求 → 服务器处理 → 
接收响应 → 解析 HTML → 构建 DOM/CSSOM → 渲染树 → 布局 → 绘制 → 合成 → 页面展示
```

**总结**

从 URL 到页面展现是一个涉及 **网络、服务器、浏览器引擎** 协同工作的复杂流程，理解每个环节的机制有助于针对性优化性能（如首屏时间、交互响应）。现代前端框架（React/Vue）和构建工具（Webpack/Vite）通过虚拟 DOM、代码分割等进一步优化了这一过程。

## 浏览器重绘域重排的区别？

**浏览器重绘（Repaint）与重排（Reflow）的区别**

**1. 定义与触发条件**

| **类型** | **触发条件**                                                 | **性能开销**             |
| -------- | ------------------------------------------------------------ | ------------------------ |
| **重排** | 元素的 **几何属性变化**（布局改变），如宽度、高度、位置（`width`、`position`）、字体大小等。 | **高**（涉及布局计算）   |
| **重绘** | 元素的 **非几何样式变化**（外观改变），如颜色、背景、边框样式（`color`、`background`）等。 | **低**（仅重新绘制像素） |

**2. 关键差异**

| **对比项**     | **重排（Reflow）**                                 | **重绘（Repaint）**                |
| -------------- | -------------------------------------------------- | ---------------------------------- |
| **影响范围**   | 可能触发父级及后续元素的连锁布局计算（全局影响）。 | 仅影响当前元素的绘制（局部影响）。 |
| **必然性**     | 重排 **必然** 导致重绘。                           | 重绘 **不会** 导致重排。           |
| **性能优先级** | 优化重点（成本高）。                               | 相对次要（成本低）。               |

**3. 常见触发场景**

**重排（Reflow）**

```javascript
// 修改元素布局属性
element.style.width = '100px';
element.style.height = '200px';
element.style.margin = '10px';
// 获取布局信息（强制同步重排）
const width = element.offsetWidth; // 触发重排
```
**重绘（Repaint）**

```javascript
// 修改非布局样式
element.style.color = 'red';
element.style.backgroundColor = '#f0f0f0';
element.style.outline = '1px solid blue';
```

**4. 优化策略**

1. **减少重排次数**：
   - **批量 DOM 操作**：使用 `DocumentFragment` 或虚拟 DOM 框架（React/Vue）合并多次修改。
   - **读写分离**：避免交替读取布局属性与修改样式（防止强制同步布局）。
     ```javascript
     // 错误示例：交替读写触发多次重排
     element.style.width = element.offsetWidth + 10 + 'px'; // 触发重排
     element.style.height = element.offsetHeight + 10 + 'px'; // 再次触发重排
     
     // 正确做法：批量写入
     const newWidth = element.offsetWidth + 10;
     const newHeight = element.offsetHeight + 10;
     element.style.width = newWidth + 'px';
     element.style.height = newHeight + 'px';
     ```
   - **脱离文档流修改**：复杂动画元素使用 `position: absolute/fixed` 或 `transform`，减少布局影响范围。

2. **使用 GPU 加速**：
   - **CSS3 属性**：优先使用 `transform`、`opacity` 等触发 **合成层（Compositing Layer）**，跳过重排/重绘。
     ```css
     .box {
       transform: translateZ(0); /* 开启 GPU 加速 */
       transition: transform 0.3s; /* 动画使用 transform */
     }
     ```

3. **避免强制同步布局**：
   - **批量读取布局属性**：在修改前统一读取所有需要的值。
   - **使用 `requestAnimationFrame`**：将样式修改集中在下一帧前执行。

**5. 性能检测工具**

- **Chrome DevTools**：
  - **Performance 面板**：分析重排/重绘的耗时与触发原因。
  - **Rendering 面板**：开启 `Paint flashing` 高亮重绘区域。
- **JavaScript API**：
  ```javascript
  // 监听重排事件（仅Chrome）
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach(entry => console.log('重排耗时:', entry.duration));
  });
  observer.observe({ entryTypes: ['layout-shift'] });
  ```

**总结**

- **核心区别**：重排影响布局计算，重绘仅更新像素。
- **优化核心**：减少重排次数、利用合成层、避免强制同步布局。
- **实际应用**：在动画、滚动等高频场景中，优先使用 `transform` 和 `opacity` 以绕过重排/重绘，直接触发 GPU 合成。

## localStorage、sessionStorage 和 Cookie 的区别是什么？各自的应用场景？

**一、核心区别**

| **特性**         | **Cookie**                     | **localStorage**               | **sessionStorage**         |
| ---------------- | ------------------------------ | ------------------------------ | -------------------------- |
| **存储容量**     | 约 4KB/域名                    | 约 5-10MB/域名（依浏览器）     | 同 localStorage            |
| **生命周期**     | 可设置过期时间（默认会话级）   | 永久存储，需手动清除           | 会话级（标签页关闭即清除） |
| **与服务器通信** | 每次请求自动携带在请求头       | 仅存客户端，不自动发送         | 同 localStorage            |
| **作用域**       | 由 `domain` 和 `path` 控制     | 同源协议、域名、端口共享       | 仅限当前标签页（同源）     |
| **API 易用性**   | 需手动处理字符串或使用库       | `setItem`/`getItem` 等简单 API | 同 localStorage            |
| **安全性**       | 支持 `HttpOnly`、`Secure` 属性 | 无安全属性，需防范 XSS 攻击    | 同 localStorage            |

**二、应用场景**

**1. Cookie**

- **场景**：需与服务器交互的短期或身份验证信息。
  
  - **用户认证**：存储 Session ID 或 Token，服务器验证用户身份。
    ```javascript
    // 示例：设置登录 Token（需后端配合设置 HttpOnly）
    document.cookie = "token=abc123; path=/; Secure; HttpOnly";
    ```
  - **跟踪行为**：记录用户偏好（如语言选择）、广告追踪 ID。
  - **会话管理**：电商网站临时保存未登录用户的购物车信息。

**2. localStorage**

- **场景**：需长期保存的客户端数据，减少服务器交互。
  - **用户偏好**：保存主题、字体大小、夜间模式等设置。
    ```javascript
    // 保存主题设置
    localStorage.setItem("theme", "dark");
    // 读取设置
    const theme = localStorage.getItem("theme") || "light";
    ```
  - **离线缓存**：缓存静态资源或 API 响应，提升弱网体验。
  - **表单草稿**：自动保存未提交的表单数据，防止意外丢失。

**3. sessionStorage**

- **场景**：临时保存会话级数据，标签页内共享。
  - **多步骤表单**：暂存分步填写的数据，避免刷新丢失。
    ```javascript
    // 暂存步骤1的数据
    sessionStorage.setItem("step1", JSON.stringify(formData));
    ```
  - **单页应用（SPA）状态**：临时存储路由状态或弹窗状态。
  - **敏感操作**：存储一次性令牌（如银行交易的验证码）。

**三、安全注意事项**

- **Cookie**：
  - 敏感信息（如 Session ID）应标记 `HttpOnly` 和 `Secure`，防止 XSS 窃取。
  - 使用 `SameSite` 属性防范 CSRF 攻击。
  
- **Web Storage（local/sessionStorage）**：
  - 避免存储敏感数据（密码、支付信息），因 JavaScript 可直接访问。
  - 防范 XSS 攻击，恶意脚本可能窃取存储内容。

## Service Worker 的作用是什么？如何实现离线缓存？

**一、Service Worker 的核心作用**

1. **离线缓存（Offline Caching）**  
   - 缓存关键资源（HTML、CSS、JS、图片），即使网络不可用，用户仍能访问页面核心内容。
2. **网络代理（Network Proxy）**  
   - 拦截并控制页面所有网络请求，可自定义缓存策略（如优先返回缓存或回退网络请求）。
3. **后台同步（Background Sync）**  
   - 在离线时暂存用户操作（如表单提交），待网络恢复后自动同步到服务器。
4. **推送通知（Push Notifications）**  
   - 即使用户未打开页面，也可通过浏览器接收服务端推送的消息。

**二、实现离线缓存的步骤**

**1. 注册 Service Worker**

在主线程（如 `main.js`）中注册 Service Worker：  
```javascript
// 检查浏览器是否支持
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(registration => console.log('SW 注册成功:', registration))
    .catch(err => console.error('SW 注册失败:', err));
}
```

**2. 编写 Service Worker 脚本（sw.js）**

定义缓存策略并监听生命周期事件：  
```javascript
// 定义缓存名称和资源列表
const CACHE_NAME = 'v1-static-cache';
const ASSETS = [
  '/',
  '/index.html',
  '/styles.css',
  '/app.js',
  '/logo.png'
];

// 安装阶段：预缓存关键资源
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(ASSETS))
      .then(() => self.skipWaiting())
  );
});

// 激活阶段：清理旧缓存
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(keys => 
      Promise.all(keys.map(key => 
        key !== CACHE_NAME ? caches.delete(key) : null
      ))
    )
  );
});

// 拦截请求：优先返回缓存，无缓存则请求网络
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(cachedResponse => {
        // 返回缓存或发起网络请求
        return cachedResponse || fetch(event.request)
          .then(response => {
            // 动态缓存新资源（可选）
            return caches.open(CACHE_NAME)
              .then(cache => {
                cache.put(event.request, response.clone());
                return response;
              });
          });
      })
      .catch(() => caches.match('/offline.html')) // 离线回退页面
  );
});
```

**3. 缓存策略示例**

- **Cache First（优先缓存）**：  
  适合静态资源（如 CSS、JS），提升加载速度。  
  ```javascript
  event.respondWith(caches.match(event.request) || fetch(event.request));
  ```
- **Network First（优先网络）**：  
  适合需要实时性的数据（如 API 响应）。  
  ```javascript
  event.respondWith(
    fetch(event.request)
      .catch(() => caches.match(event.request))
  );
  ```

**4. 更新缓存**

- **版本控制**：修改 `CACHE_NAME` 触发新缓存安装。  
- **手动更新**：用户刷新页面时，Service Worker 检测更新并替换旧缓存。

**三、测试离线功能**

1. **开发者工具模拟离线**：  
   Chrome DevTools → Network → Offline 勾选。  
2. **检查缓存状态**：  
   Application → Cache Storage 查看已缓存资源。  
3. **验证回退页面**：  
   访问未缓存的路径（如 `/new-page`），确认是否返回 `offline.html`。

**四、注意事项**

- **HTTPS 要求**：Service Worker 仅在生产环境（或 localhost）的 HTTPS 下生效。  
- **缓存容量**：不同浏览器对单个域名的存储限制不同（通常为 50-200MB）。  
- **缓存清理**：需在 `activate` 事件中清理过期缓存，避免占用过多空间。

**总结**

通过 Service Worker 的 **预缓存关键资源** 和 **动态拦截请求**，可实现强大的离线体验。结合不同缓存策略（如 Cache First、Network First），能有效平衡性能与数据实时性。典型应用场景包括 PWA（渐进式 Web 应用）、弱网络环境优化等。

## 浏览器如何实现跨标签页通信？列举至少 3 种方式

以下是浏览器实现跨标签页通信的几种常见方法及其应用场景：

1. **LocalStorage 事件**

- **原理**：当修改 `localStorage` 数据时，同源的其他标签页会触发 `storage` 事件。
- **示例**：
  ```javascript
  // 标签页A：存储数据
  localStorage.setItem("message", "Hello from Tab A");
  
  // 标签页B：监听变化
  window.addEventListener("storage", (e) => {
    if (e.key === "message") {
      console.log("Received:", e.newValue);
    }
  });
  ```
- **特点**：
  - **同源限制**：仅限同源页面。
  - **数据限制**：只能传递字符串。
  - **触发条件**：值必须发生改变，重复设置相同值不触发。

2. **BroadcastChannel API**

- **原理**：创建一个命名频道，允许同源页面通过该频道发送和接收消息。
- **示例**：
  ```javascript
  // 标签页A：发送消息
  const channel = new BroadcastChannel("chat");
  channel.postMessage({ text: "Hello from Tab A" });
  
  // 标签页B：接收消息
  const channel = new BroadcastChannel("chat");
  channel.onmessage = (e) => {
    console.log("Received:", e.data.text);
  };
  ```
- **特点**：
  - **现代API**：支持复杂对象（自动序列化）。
  - **兼容性**：不兼容 IE 和旧版移动浏览器。

3. **SharedWorker（共享工作者）**

- **原理**：运行在后台的共享脚本，允许多个标签页通过 `port` 通信。
- **示例**：
  ```javascript
  // SharedWorker 脚本（worker.js）：
  const ports = [];
  onconnect = (e) => {
    const port = e.ports[0];
    ports.push(port);
    port.onmessage = (e) => {
      ports.forEach(p => p.postMessage(e.data));
    };
  };
  
  // 标签页A/B：连接并通信
  const worker = new SharedWorker("worker.js");
  worker.port.onmessage = (e) => {
    console.log("Received:", e.data);
  };
  worker.port.postMessage("Hello from Tab A");
  ```
- **特点**：
  - **长期存活**：标签页关闭后仍可保留状态。
  - **复杂通信**：适合需要共享数据的场景（如实时协作）。

4. **Service Worker**

- **原理**：通过服务工作者拦截请求并转发消息。
- **示例**：
  ```javascript
  // Service Worker 脚本（sw.js）：
  self.addEventListener("message", (e) => {
    clients.matchAll().then(clients => {
      clients.forEach(client => client.postMessage(e.data));
    });
  });
  
  // 标签页A：发送消息
  navigator.serviceWorker.controller.postMessage("Hello from Tab A");
  
  // 标签页B：接收消息
  navigator.serviceWorker.onmessage = (e) => {
    console.log("Received:", e.data);
  };
  ```
- **特点**：
  - **离线支持**：可结合离线缓存使用。
  - **兼容性**：需 HTTPS 环境（本地开发除外）。

5. **window.open + postMessage**

- **原理**：通过 `window.open` 获取其他标签页的引用，直接发送消息。
- **示例**：
  ```javascript
  // 标签页A：打开新标签页并发送消息
  const newTab = window.open("https://example.com/tabB");
  newTab.postMessage("Hello from Tab A", "https://example.com");
  
  // 标签页B：监听消息
  window.addEventListener("message", (e) => {
    if (e.origin === "https://example.com") {
      console.log("Received:", e.data);
    }
  });
  ```
- **特点**：
  - **需引用关系**：必须持有目标标签页的 `window` 对象。
  - **安全限制**：需验证 `origin` 防止跨域攻击。

6. **Cookies 轮询**

- **原理**：通过定时检查 Cookie 变化实现通信。
- **示例**：
  ```javascript
  // 标签页A：设置 Cookie
  document.cookie = "message=Hello from Tab A; path=/";
  
  // 标签页B：轮询检查 Cookie
  setInterval(() => {
    const message = document.cookie
      .split("; ")
      .find(row => row.startsWith("message="))
      ?.split("=")[1];
    if (message) console.log("Received:", message);
  }, 1000);
  ```
- **特点**：
  - **简单但低效**：需轮询，占用资源。
  - **同源限制**：仅限同源页面。

7. **服务器中转（WebSocket/轮询）**

- **原理**：通过服务器转发消息（如 WebSocket 长连接）。
- **示例**：
  ```javascript
  // 所有标签页连接同一 WebSocket 服务器
  const ws = new WebSocket("wss://example.com/ws");
  ws.onmessage = (e) => {
    console.log("Received:", e.data);
  };
  
  // 标签页发送消息
  ws.send("Hello from current tab");
  ```
- **特点**：
  - **跨域支持**：可实现不同源页面通信。
  - **实时性高**：WebSocket 适合高频通信。

**方案选择指南**

| **方法**             | **适用场景**                     | **优点**             | **缺点**                 |
| -------------------- | -------------------------------- | -------------------- | ------------------------ |
| **LocalStorage**     | 简单同源状态同步（如主题切换）   | 简单易用             | 仅字符串、需值变化触发   |
| **BroadcastChannel** | 复杂消息传递（如实时聊天）       | 支持对象、无需轮询   | 兼容性差                 |
| **SharedWorker**     | 长期共享数据（如多标签协作）     | 后台运行、数据持久化 | 实现复杂                 |
| **Service Worker**   | 离线应用（如PWA消息推送）        | 支持离线、可拦截请求 | 需HTTPS、学习成本高      |
| **postMessage**      | 有引用关系的标签页（如父子页）   | 直接通信、安全可控   | 需明确目标窗口           |
| **Cookies轮询**      | 兼容性要求高的简单场景           | 兼容所有浏览器       | 效率低、资源占用高       |
| **服务器中转**       | 跨域或高实时性需求（如在线游戏） | 灵活、跨域支持       | 依赖服务器、延迟可能较高 |

根据实际需求选择最合适的方法，优先考虑 **同源限制**、**数据复杂度** 和 **浏览器兼容性**。

## 解释 BOM 和 DOM 的区别，列举常用的 BOM 对象方法

**BOM 与 DOM 的区别**

| **对比项**   | **BOM（Browser Object Model）**            | **DOM（Document Object Model）**           |
| ------------ | ------------------------------------------ | ------------------------------------------ |
| **定义**     | 浏览器对象模型，提供与浏览器窗口交互的 API | 文档对象模型，提供操作 HTML/XML 内容的 API |
| **作用对象** | 浏览器本身（窗口、导航栏、历史记录等）     | 网页内容（HTML 元素、属性、样式、事件等）  |
| **标准化**   | 无统一标准，各浏览器实现可能有差异         | W3C 标准，各浏览器遵循统一规范             |
| **核心对象** | `window`、`navigator`、`location` 等       | `document`、`Element`、`Node` 等           |
| **典型应用** | 控制浏览器行为（跳转、弹窗、尺寸等）       | 动态修改页面内容（增删元素、绑定事件等）   |

**常用的 BOM 对象及方法/属性**

**1. `window` 对象**  

- **作用**：表示浏览器窗口，是 BOM 的顶层对象。  
- **常用方法**：  
  ```javascript
  window.alert("提示信息");                // 弹窗
  window.setTimeout(() => {}, 1000);      // 定时器
  window.open("https://example.com");     // 打开新窗口
  window.scrollTo(x, y);                  // 滚动到指定位置
  ```
- **常用属性**：  
  ```javascript
  window.innerWidth;     // 视口宽度
  window.innerHeight;    // 视口高度
  window.localStorage;   // 本地存储对象
  window.location;       // 地址信息（参考下方 location 对象）
  ```

**2. `navigator` 对象**  

- **作用**：提供浏览器及操作系统信息。  
- **常用属性/方法**：  
  ```javascript
  navigator.userAgent;       // 浏览器 UA 字符串
  navigator.platform;        // 操作系统（如 "Win32"、"MacIntel"）
  navigator.language;        // 浏览器首选语言
  navigator.geolocation.getCurrentPosition(); // 获取地理位置
  ```

**3. `location` 对象**  

- **作用**：管理当前页面 URL 信息，控制页面跳转。  
- **常用属性/方法**：  
  ```javascript
  location.href;            // 完整 URL（可赋值实现跳转）
  location.host;            // 主机名和端口（如 "example.com:8080"）
  location.pathname;        // URL 路径（如 "/path/page.html"）
  location.search;          // 查询参数（如 "?id=123"）
  location.reload();        // 重新加载页面
  location.replace("new-url"); // 替换当前页面（无历史记录）
  ```

**4. `history` 对象**  

- **作用**：操作浏览器会话历史记录（前进/后退）。  
- **常用方法**：  
  ```javascript
  history.back();           // 返回上一页
  history.forward();        // 前进到下一页
  history.go(-2);           // 跳转到前两页
  history.pushState(state, title, "new-url"); // 添加历史记录（不刷新页面）
  ```

**5. `screen` 对象**  

- **作用**：获取用户屏幕信息。  
- **常用属性**：  
  ```javascript
  screen.width;            // 屏幕宽度（像素）
  screen.height;           // 屏幕高度（像素）
  screen.availWidth;       // 可用宽度（排除任务栏等）
  screen.colorDepth;       // 颜色深度（如 24 位）
  ```

**6. `performance` 对象**  

- **作用**：提供页面性能数据。  
- **常用方法**：  
  ```javascript
  performance.now();              // 高精度时间戳（毫秒）
  performance.getEntries();       // 资源加载性能数据
  performance.mark("start");      // 标记性能测量点
  ```

**BOM 与 DOM 的协作示例**

```javascript
// 通过 BOM 修改 URL
window.location.href = "https://example.com"; 

// 通过 DOM 修改页面内容
document.getElementById("title").textContent = "新标题"; 

// 监听窗口大小变化（BOM）
window.addEventListener("resize", () => {
  // 动态调整元素布局（DOM）
  document.querySelector(".box").style.width = window.innerWidth + "px";
});
```

**总结**

- **BOM** 控制浏览器行为（窗口、导航、历史等），**DOM** 操作网页内容。  
- 常用 BOM 对象包括 `window`、`navigator`、`location`、`history`、`screen`。  
- 掌握 BOM 对象方法（如 `setTimeout`、`history.pushState`）是前端开发的核心技能。

## 什么是 CSSOM 阻塞渲染？如何处理？

**CSSOM 阻塞渲染的原因**

1. **渲染依赖 CSSOM**：  
   浏览器需结合 DOM 和 CSSOM 生成渲染树（Render Tree）。若外部 CSS 未加载解析完成，浏览器会阻塞页面渲染，以避免无样式内容闪烁（FOUC）。

2. **解析顺序限制**：  
   CSS 文件会阻塞后续 JavaScript 的执行（除非 JS 显式声明异步），因为 JS 可能依赖样式计算结果。

**处理 CSSOM 阻塞渲染的方法**

**1. 内联关键 CSS（Critical CSS）**

- **做法**：将首屏渲染所需的核心 CSS 直接内嵌到 HTML 的 `<style>` 标签中。  
- **优点**：避免关键 CSS 的网络请求延迟，加速首次渲染。  
- **示例**：  
  ```html
  <head>
    <style>
      /* 内联首屏关键样式 */
      body { margin: 0; }
      .header { background: #333; }
    </style>
  </head>
  ```

**2. 异步加载非关键 CSS**

- **使用 `media` 属性**：标记非关键 CSS 为特定媒体类型（如打印），仅在匹配时加载。  
  ```html
  <link href="non-critical.css" rel="stylesheet" media="print" onload="this.media='all'">
  ```
  - **原理**：初始加载时不阻塞渲染，加载完成后应用样式。

- **动态加载 CSS**：通过 JavaScript 异步插入 `<link>` 标签。  
  ```javascript
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = 'styles.css';
  document.head.appendChild(link);
  ```

**3. 预加载 CSS 资源**

- **`<link rel="preload">`**：提示浏览器提前加载 CSS，但不阻塞渲染。  
  ```html
  <link rel="preload" href="styles.css" as="style" onload="this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="styles.css"></noscript>
  ```
  - **注意**：需配合 `onload` 事件将 `preload` 转换为 `stylesheet`。

**4. 压缩与合并 CSS**

- **工具优化**：使用 PostCSS、CSSNano 压缩 CSS，减少文件体积。  
- **合并文件**：减少 HTTP 请求次数（HTTP/2 下无需过度合并）。

**5. 避免 `@import`**

- **问题**：`@import` 引入的 CSS 会串行加载，增加阻塞时间。  
- **替代方案**：使用多个 `<link>` 标签并行加载。

**6. 使用 CDN 加速**

- **内容分发网络**：通过就近节点快速传输 CSS 文件，减少下载耗时。

**验证与监控**

- **Lighthouse 检测**：检查关键 CSS 是否内联、非关键 CSS 是否异步加载。  
- **Chrome DevTools**：  
  - **Performance 面板**：分析 CSS 加载与渲染时间线。  
  - **Coverage 工具**：查看未使用的 CSS 比例，优化代码冗余。

**总结**

- **核心思路**：优先加载关键 CSS，异步或延迟非关键 CSS。  
- **关键方法**：内联首屏样式、`media` 属性异步加载、预加载优化。  
- **效果**：缩短首次有意义绘制（FMP）时间，提升用户体验。

## JS 阻塞渲染的原理是什么？如何避免？

**一、阻塞渲染的原理**

浏览器渲染流程中，**JavaScript 的执行会阻塞 DOM 构建和渲染**，主要原因如下：

1. **DOM/CSSOM 依赖**：  
   JavaScript 可能操作 DOM 或 CSSOM（如 `document.createElement`、`element.style`），因此浏览器需 **确保脚本执行前已完成当前所有 DOM 和 CSSOM 的构建**，以避免数据竞争。

2. **渲染流水线中断**：  
   - 当浏览器解析 HTML 遇到 `<script>` 标签时，会 **暂停 HTML 解析**，下载并执行脚本。  
   - 若脚本是外部文件（`<script src="...">`），浏览器还需等待其 **下载完成**（网络延迟加剧阻塞）。

3. **同步执行模式**：  
   默认情况下，JavaScript 在 **主线程同步执行**，长时间任务会阻塞 UI 渲染和用户交互。

**二、避免阻塞的核心方法**

**1. 异步加载脚本**

- **`async` 属性**：  
  异步下载脚本，**下载完成后立即执行**（可能中断 HTML 解析）。  
  ```html
  <script async src="analytics.js"></script>
  ```
  - **适用场景**：独立脚本（如统计代码、广告 SDK），不依赖 DOM 或其他脚本。

- **`defer` 属性**：  
  异步下载脚本，**延迟到 HTML 解析完成后顺序执行**。  
  ```html
  <script defer src="app.js"></script>
  ```
  - **适用场景**：依赖 DOM 的脚本（如页面初始化逻辑）。

- **动态加载脚本**：  
  通过 JavaScript 动态创建 `<script>` 标签，实现非阻塞加载。  
  ```javascript
  const script = document.createElement('script');
  script.src = 'dynamic.js';
  document.body.appendChild(script);
  ```

**2. 延迟非关键脚本**

- **置于 `<body>` 末尾**：  
  将非关键脚本放在 HTML 文件底部，优先渲染页面内容。  
  ```html
  <body>
    <!-- 页面内容 -->
    <script src="non-critical.js"></script>
  </body>
  ```

- **按需加载**：  
  在特定事件（如点击、滚动）触发时加载脚本。  
  ```javascript
  button.addEventListener('click', () => {
    import('./modal.js').then(module => module.showModal());
  });
  ```

**3. 优化 JavaScript 执行**

- **任务拆分**：  
  将长任务拆分为多个小任务，使用 `setTimeout` 或 `requestIdleCallback` 分批执行。  
  
  ```javascript
  function processChunk() {
    // 处理数据块
    if (hasMore) requestIdleCallback(processChunk);
  }
  requestIdleCallback(processChunk);
  ```
  
- **Web Workers**：  
  将计算密集型任务移至 Web Worker，释放主线程。  
  ```javascript
  const worker = new Worker('task.js');
  worker.postMessage(data);
  worker.onmessage = (e) => { /* 处理结果 */ };
  ```

**4. 使用现代模块化（ES Modules）**

- **`type="module"`**：  
  现代浏览器默认以 `defer` 模式加载 ES 模块脚本。  
  ```html
  <script type="module" src="app.mjs"></script>
  ```

**三、性能检测工具**

1. **Lighthouse**：  
   检测阻塞渲染的脚本，并给出优化建议（如移除未使用的 JS、延迟加载）。  
2. **Chrome DevTools**：  
   - **Performance 面板**：分析主线程任务和长任务（Long Tasks）。  
   - **Coverage 工具**：查看 JS/CSS 代码的未使用比例。  

**四、总结**

| **优化策略**               | **适用场景** | **核心效果**               |
| -------------------------- | ------------ | -------------------------- |
| `async`/`defer`            | 外部脚本加载 | 非阻塞下载，控制执行时机   |
| 动态加载                   | 按需加载功能 | 减少初始负载，提升首屏速度 |
| Web Workers                | 复杂计算任务 | 避免主线程阻塞             |
| 代码分割（Code Splitting） | 大型应用     | 按需加载，减少初始 JS 体积 |

**关键原则**：  
- **优先加载关键资源**，延迟非关键脚本。  
- **减少主线程阻塞时间**，拆分长任务。  
- **利用浏览器特性**（如 `async`、`defer`、模块化）优化执行流程。

## 浏览器如何处理 async 和 defer 属性的脚本？

浏览器处理带有`async`和`defer`属性的脚本时，会优化加载过程以避免阻塞HTML解析：

1. **async（异步加载）**  
   - **加载**：异步下载脚本，不阻塞HTML解析。  
   - **执行**：下载完成后**立即执行**，此时可能中断HTML解析。  
   - **顺序**：多个`async`脚本**执行顺序不确定**（按下载完成顺序）。  
   - **适用场景**：独立且无依赖的脚本（如统计代码）。

2. **defer（延迟执行）**  
   - **加载**：异步下载，同样不阻塞HTML解析。  
   - **执行**：在**HTML解析完成后、DOMContentLoaded事件前**按文档中的**顺序执行**。  
   - **顺序**：多个`defer`脚本**严格按顺序执行**。  
   - **适用场景**：需DOM就绪或存在依赖关系的脚本。

**注意**：两者均仅对外部脚本生效，内联脚本会忽略属性。`DOMContentLoaded`会等待`defer`脚本执行完毕，而`async`脚本可能在其前后触发。

## 解释浏览器的预渲染（Pre-rendering）和预加载（Preloading）机制

**浏览器的预渲染（Prerendering）和预加载（Preloading）机制区别如下：**

1. **预加载（Preloading）**  
   - **目的**：提前加载**关键资源**（如字体、图片、脚本），减少后续请求的延迟。  
   - **实现**：通过 `<link rel="preload">` 或 HTTP 头 `Link: preload` 声明优先级。  
   - **特点**：仅加载资源，**不执行**（如脚本需二次解析）。  
   - **适用场景**：优化首屏渲染，例如提前加载首屏字体或关键 JS/CSS。

2. **预渲染（Prerendering）**  
   - **目的**：提前在后台**完整渲染整个页面**（包括 JS 执行和布局），实现点击后**瞬时切换**。  
   - **实现**：通过 `<link rel="prerender">` 或浏览器预测行为（如 Chrome 的预测预渲染）。  
   - **特点**：消耗较高资源（CPU/内存），仅适用于**高概率跳转的页面**。  
   - **适用场景**：搜索引擎结果页提前渲染第一条结果，或用户明确提示的下一页。

**关键区别**：  
- 预加载是**资源级优化**，预渲染是**页面级优化**。  
- 预渲染可能触发敏感逻辑（如广告统计），需谨慎使用。

## 如何测量页面加载性能？列举常用的 API 和工具

**测量页面加载性能常用方法如下：**

1. **核心 API**  
   - **Performance Timing API**：通过 `performance.timing` 获取关键时间节点（如 DNS、DOM 解析、加载完成时间）。  
   - **PerformanceObserver**：异步监听性能指标（如 LCP、FCP 等 Core Web Vitals）。  
   - **Resource Timing API**：通过 `performance.getEntriesByType('resource')` 分析具体资源的加载耗时。  
   - **Paint Timing API**：通过 `performance.getEntriesByType('paint')` 获取首次绘制（FCP）等渲染时间点。  

2. **常用工具**  
   - **Chrome DevTools**：  
     - *Performance 面板*：录制并分析页面加载的详细过程。  
     - *Lighthouse*：生成性能报告，提供优化建议（如 TTI、CLS 等指标）。  
   - **WebPageTest**：多地点测试，生成瀑布图及视频回放。  
   - **RUM（真实用户监控）工具**：如 New Relic、Google Analytics，收集用户实际访问性能数据。  

**示例代码（获取关键指标）**：  
```javascript
// 获取页面加载整体耗时
const [pageLoad] = performance.getEntriesByType('navigation');
console.log('DOMContentLoaded:', pageLoad.domContentLoadedEventEnd);
console.log('Load 事件耗时:', pageLoad.loadEventEnd - pageLoad.loadEventStart);

// 监听 LCP
new PerformanceObserver((list) => {
  const entries = list.getEntries();
  console.log('LCP:', entries[0].startTime);
}).observe({ type: 'largest-contentful-paint', buffered: true });
```
**注意**：线上环境需结合 API 与监控工具，区分实验室数据（Lab）和真实用户数据（Field）。

## 描述浏览器的事件循环机制，包括宏任务和微任务的执行顺序

**浏览器的事件循环机制及任务执行顺序如下：**

1. **事件循环流程**  
   浏览器通过事件循环协调任务执行，确保主线程非阻塞。其核心流程为：  
   - **执行一个宏任务**（如 script 代码、setTimeout 回调等）。  
   - **清空微任务队列**：执行所有微任务（如 Promise.then、MutationObserver），直到队列为空。  
   - **渲染页面**（若需要更新 UI）。  
   - **重复循环**，从宏任务队列中取出下一个任务执行。

2. **宏任务（Macrotask）与微任务（Microtask）**  
   - **宏任务**：  
     - 包含 script 整体代码、setTimeout、setInterval、I/O、UI 渲染等。  
     - **队列机制**：按顺序执行，每次循环处理一个宏任务。  
   - **微任务**：  
     - 包含 Promise 回调、MutationObserver、queueMicrotask 等。  
     - **执行时机**：在**当前宏任务结束后、渲染前**，必须一次性清空队列。  
     - **嵌套处理**：若微任务中产生新微任务，会继续执行，直到队列为空。

3. **执行顺序示例**  
   ```javascript
   console.log("Script start");          // 宏任务（主线程代码）
   
   setTimeout(() => {                     // 宏任务（setTimeout）
     console.log("setTimeout");
   }, 0);
   
   Promise.resolve().then(() => {         // 微任务（Promise）
     console.log("Promise 1");
   }).then(() => {                        // 微任务（嵌套）
     console.log("Promise 2");
   });
   
   console.log("Script end");            // 宏任务（主线程代码）
   ```
   **输出顺序**：  
   `Script start → Script end → Promise 1 → Promise 2 → setTimeout`

4. **关键规则**  
   - **微任务优先**：同一事件循环中，微任务总在下一个宏任务前执行。  
   - **渲染时机**：通常在微任务队列清空后，执行 UI 渲染（如 requestAnimationFrame）。  
   - **避免阻塞**：长时间运行的微任务会延迟渲染和后续宏任务执行。

**总结**：事件循环确保任务按“宏任务 → 微任务 → 渲染”的顺序循环处理，微任务的高优先级使其能在当前宏任务后立即执行，优化响应速度。

## DOM 事件的三个阶段是什么？如何阻止事件冒泡和默认行为？

**DOM 事件三阶段及阻止事件方法如下：**

1. **事件三阶段**  
   - **捕获阶段（Capture Phase）**：事件从 `window` 向目标元素逐层传递。  
   - **目标阶段（Target Phase）**：事件到达目标元素。  
   - **冒泡阶段（Bubble Phase）**：事件从目标元素逐层向上回传至 `window`。

2. **阻止事件冒泡**  
   - **方法**：调用事件对象的 `event.stopPropagation()`。  
   - **效果**：阻止事件继续向父元素传播（不影响当前元素的其他监听器）。  
   - **扩展**：若需同时阻止当前元素的其他监听器执行，使用 `event.stopImmediatePropagation()`。

3. **阻止默认行为**  
   - **方法**：调用 `event.preventDefault()`。  
   - **注意**：仅对可取消的默认行为生效（如表单提交、链接跳转），可通过 `event.cancelable` 属性判断是否支持。

**示例代码**：  
```javascript
element.addEventListener("click", function(event) {
  event.stopPropagation();    // 阻止冒泡
  event.preventDefault();     // 阻止默认行为
}, false);                    // false 表示监听冒泡阶段（默认值）
```

**关键点**：  
- 通过 `addEventListener` 的第三个参数选择监听阶段（`true` 为捕获，`false` 为冒泡）。  
- `return false` 在原生事件中仅阻止默认行为，在 jQuery 中同时阻止冒泡和默认行为。

## 什么是浏览器缓存策略？强缓存和协商缓存的区别是什么？

**浏览器缓存策略及强缓存与协商缓存的区别：**

**1. 浏览器缓存策略**  
浏览器缓存通过存储资源副本（如JS、CSS、图片），减少重复请求，提升加载速度。缓存策略分为**强缓存**和**协商缓存**，优先级依次为：强缓存 → 协商缓存 → 重新请求资源。

**2. 强缓存（Strong Cache）**  
- **机制**：浏览器直接判断本地缓存是否过期，未过期则直接使用缓存，**不发送请求到服务器**。  
- **响应头**：  
  - `Cache-Control`（HTTP/1.1）：  
    - `max-age=3600`：缓存有效期（秒）。  
    - `no-cache`：跳过强缓存，直接进入协商缓存。  
    - `no-store`：禁止缓存。  
  - `Expires`（HTTP/1.0）：指定缓存过期时间（绝对时间，可能因客户端时间不准失效）。  
- **特点**：性能最佳，但资源更新时需通过文件名哈希或版本号强制刷新缓存。

**3. 协商缓存（Conditional Cache）**  
- **机制**：强缓存失效后，浏览器携带缓存标识向服务器验证资源是否变化。若未变化（304状态码），则复用缓存；若变化（200状态码），则返回新资源。  
- **响应头/请求头**：  
  - `Last-Modified`（响应头）：资源最后修改时间。  
  - `If-Modified-Since`（请求头）：浏览器发送该时间，服务器比对后决定返回304或200。  
  - `ETag`（响应头）：资源唯一标识（哈希值），优先级高于 `Last-Modified`。  
  - `If-None-Match`（请求头）：浏览器发送 `ETag`，服务器比对后返回结果。  
- **特点**：必发请求，但可减少传输体积（304无响应体）。

**4. 核心区别**  
| **对比项**         | **强缓存**                    | **协商缓存**                     |
| ------------------ | ----------------------------- | -------------------------------- |
| **是否请求服务器** | 否（直接读缓存）              | 是（服务器验证缓存有效性）       |
| **响应状态码**     | 200（from disk/memory cache） | 304（Not Modified）              |
| **优先级**         | 高                            | 低（强缓存失效后触发）           |
| **适用场景**       | 静态资源（如`logo.png`）      | 频繁更新的资源（如`index.html`） |

**示例流程**：  
1. 首次请求：返回资源及 `Cache-Control: max-age=3600`。  
2. 60分钟内再次请求：强缓存生效，直接读取本地资源。  
3. 60分钟后再次请求：携带 `If-None-Match`（ETag）发起请求，服务器返回304，浏览器复用缓存。  
4. 资源修改后请求：服务器返回200及新资源，更新本地缓存。  

**总结**：强缓存优化性能，协商缓存保证资源时效性，两者结合可高效管理资源加载。

## 如何强制浏览器不使用缓存，每次请求都从服务端获取最新资源？

**强制浏览器不使用缓存的方法如下：**

1. **设置 HTTP 响应头**  
   - 在服务器返回资源时，添加以下响应头：  
     ```http
     Cache-Control: no-store, no-cache, must-revalidate
     Pragma: no-cache
     Expires: 0
     ```
     - `no-store`：禁止缓存任何响应内容。  
     - `no-cache` 和 `must-revalidate`：每次请求需向服务器验证资源有效性。  
     - `Expires: 0` 表示资源立即过期。  

2. **URL 添加动态参数**  
   - 在资源 URL 后附加版本号或时间戳，例如：  
     ```html
     <script src="app.js?v=20231001"></script>
     <!-- 或使用哈希值（推荐） -->
     <script src="app.abc123.js"></script>
     ```
     - 每次更新资源时修改参数值，使浏览器视为新资源。  

3. **开发者工具禁用缓存（仅调试）**  
   - 在 Chrome DevTools 的 **Network** 面板勾选 **Disable cache**，强制所有请求跳过缓存。  

**适用场景**：  
- **开发环境**：使用动态参数或禁用缓存工具。  
- **生产环境**：通过文件名哈希（如 Webpack 的 `[contenthash]`）和服务器缓存头配置，确保资源更新后 URL 变化。  

**注意事项**：  
- 强刷新（`Ctrl+F5`）会跳过缓存，但依赖用户操作。  
- `Cache-Control` 优先级高于 `Expires`，需确保服务器正确配置。

##  html 文档渲染过程，css 文件和 js 文件的下载，是否会阻塞渲染？

**HTML 渲染过程中 CSS 和 JS 文件的阻塞行为如下：**

**1. CSS 文件的下载与阻塞**

- **下载**：CSS 文件**不会阻塞 DOM 解析**（HTML 解析器会继续工作），但会**阻塞渲染树的生成**（即阻塞页面渲染）。  
  - **原因**：浏览器需要 CSSOM 树和 DOM 树共同构建渲染树（Render Tree），未加载完成的 CSS 会导致页面无法渲染（避免无样式内容闪现）。  
- **优化建议**：将 `<link>` 标签放在 `<head>` 中，尽早加载 CSS。

**2. JS 文件的下载与阻塞**

- **默认行为**：JS 文件**会阻塞 DOM 解析**（HTML 解析暂停），直到脚本下载并执行完成。  
  - **原因**：JS 可能修改 DOM 或 CSSOM，浏览器需确保脚本执行前的 DOM/CSSOM 状态。  
- **优化方法**：  
  - **`async` 属性**：异步下载 JS，下载完成后**立即执行**（可能中断渲染）。  
  - **`defer` 属性**：异步下载 JS，延迟到 **DOM 解析完成后按顺序执行**。  
  - **动态加载脚本**：通过 `document.createElement('script')` 异步加载。  

**关键规则总结**

| **资源类型** | **阻塞 DOM 解析**              | **阻塞渲染（Render）**        |
| ------------ | ------------------------------ | ----------------------------- |
| **CSS**      | ❌ 不阻塞                       | ✅ 阻塞（直到 CSSOM 构建完成） |
| **JS**       | ✅ 阻塞（除非用 `async/defer`） | ✅ 阻塞（执行时可能中断渲染）  |

**示例场景**

```html
<html>
  <head>
    <link href="style.css" rel="stylesheet"> <!-- 阻塞渲染，不阻塞 DOM 解析 -->
    <script src="app.js"></script>           <!-- 阻塞 DOM 解析和渲染 -->
    <script async src="analytics.js"></script> <!-- 异步下载，执行时可能阻塞 -->
    <script defer src="vendor.js"></script>   <!-- 延迟到 DOM 解析后执行 -->
  </head>
  <body>
    <!-- DOM 解析可能被 JS 阻塞 -->
  </body>
</html>
```

**总结**：  
- CSS 阻塞渲染但不阻塞 DOM 解析，JS 默认阻塞两者。  
- 通过 `async/defer` 优化 JS 加载，通过预加载（`<link rel="preload">`）优化关键资源优先级。

## 解释浏览器的合成层（Compositing Layers）机制，如何手动创建合成层？

**浏览器的合成层（Compositing Layers）机制及手动创建方法如下：**

**1. 合成层机制**  

合成层是浏览器将页面分割为多个独立图层（Layer）的优化手段。每个图层可单独栅格化（Rasterize）并交由 GPU 处理，最终通过合成（Composite）形成最终画面。其核心优势在于：  
- **局部更新**：仅更新变化的图层，避免全局重绘（Repaint）或重排（Reflow）。  
- **GPU 加速**：利用 GPU 并行处理图层，提升动画（如位移、透明度）的性能。  

**触发合成层的典型场景**：  
- 使用 CSS 3D 变换（如 `transform: translate3d()`）。  
- 包含 `opacity` 动画的元素。  
- 使用 `will-change` 属性声明的元素。  
- 视频（`<video>`）或 Canvas 元素。  

**2. 手动创建合成层的方法**  

通过以下 CSS 属性可强制将元素提升为独立合成层：  

**方法 1：使用 3D 变换**  

```css  
.element {  
  transform: translateZ(0);  /* 或 translate3d(0, 0, 0) */  
}  
```
- **原理**：触发浏览器启用 GPU 加速，自动分配独立图层。  

**方法 2：设置 `will-change` 属性**  

```css  
.element {  
  will-change: transform;  /* 提前告知浏览器元素可能的变化 */  
}  
```
- **注意**：需在变化前添加此属性，且完成后移除以避免内存占用。  

**方法 3：使用 `opacity` 动画**  

```css  
.element {  
  opacity: 0.99;  /* 非 1 的值可能触发合成层 */  
}  
```
- **适用场景**：与 `transition` 或 `animation` 结合优化透明度动画。  

**3. 注意事项**  

- **内存消耗**：过多合成层会增加 GPU 内存占用，可能导致卡顿（尤其移动端）。  
- **合理使用**：仅在频繁变化或性能敏感的元素（如动画、滚动组件）上手动提升图层。  
- **验证工具**：通过 Chrome DevTools 的 **Layers** 面板查看图层分布及占用情况。  



**示例优化场景**：  
```css  
/* 提升动画元素至合成层 */  
.animated-element {  
  will-change: transform;  
  /* 或 transform: translateZ(0); */  
}  
```
**总结**：合成层通过隔离渲染单元优化性能，手动创建需结合场景权衡利弊，优先依赖浏览器自动优化，必要时精准干预。

## 什么是浏览器的 “渲染层合并”？在什么情况下会触发层合并或层分离？

浏览器内有多个进程，其中渲染进程被称为浏览器内核，负责页面渲染和执行 JS 脚本等。渲染进程负责浏览器的解析和渲染，内部有 JS 引擎线程、 GUI 渲染线程、事件循环管理线程、定时器线程、HTTP 线程。

JS 引擎线程负责执行 JS 脚本，GUI 渲染线程负责页面的解析和渲染，两者是互斥的，也就是执行 JS 的时候页面是停止解析和渲染的。这是因为如果在页面渲染的同时 JS 引擎修改了页面元素，比如清空页面，会造成后续页面渲染的不必要和错误。而由于 JS 经常要操作 DOM ，就要涉及 JS 引擎线程和 GUI 渲染线程的通信，而线程间通信代价是非常昂贵的，这也是造成 JS 操作 DOM 效率不高的原因。

浏览器的 HTML/CSS 的解析和渲染都属于 GUI渲染线程，所以和 JS 引擎线程是互斥、阻塞的。下面从代码实际运行的角度分析浏览器解析和渲染的顺序，以及互相间的阻塞关系。

**CSS 阻塞**

- css 文件的下载和解析不会影响 DOM 的解析，但是会阻塞 DOM 的渲染。因为 CSSOM Tree 要和 DOM Tree 合成 Render Tree 才能绘制页面。下面的 test1 在 css 下载并解析完成前是默认样式， test2 在 css 下载并解析完成之前不会显示：

```html
<button class="btn btn-primary">test1</button>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
<div>test2</div>
```

- css 文件没下载并解析完成之前，后续的 js 脚本不能执行。下面的 alert('ok') 在 css 下载并解析完成之前不会弹出来：

```html
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
<script>
    alert('ok')
</script>
```

- css 文件的下载不会阻塞前面的 js 脚本执行。下面的 alert('ok') 会在 css 下载完成前弹出：

```html
<script>
    alert('ok')
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
```

所以在需要提前执行不操作 dom 元素的 js 时，不妨把 js 放到 css 文件之前。

**js 阻塞**

js 文件的下载和解析会阻塞 GUI 渲染进程，也就是会阻塞 DOM 和 CSS 的解析和渲染。

js 文件没下载并解析完成之前，后续的 HTML 和 CSS 无法解析：

```html
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>
<div>test</div>
```

- js 文件的下载不会阻塞前面 HTML 和 CSS 的解析：

```html
<div>test</div>
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>
```

**需要注意的点**

- 第一，GUI 渲染线程会尽可能早的将内容呈现到屏幕上，并不会等到所有的 HTML 都解析完成之后再去构建和布局 Render Tree，而是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。下面 test1 会在 js 文件下载完成前渲染完成，而 test2 则会在 js 文件下载并执行完之后渲染：

```html
  <div>test1</div>
  <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
  <div>test2</div>
```

- 第二，文件的下载是不会被阻塞的，不管是 css 还是 js 文件，浏览器的主线程会在页面解析前开启下载，所以就算在外部脚本执行前删除脚本，脚本也还是会下载。

```html
<body>
  <script>
    document.body.remove()
  </script>  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
  <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
</body>
```

## 内存泄漏的常见场景有哪些？如何通过浏览器工具检测内存泄漏？

**一、常见内存泄漏场景**

1. **意外的全局变量**  
   ```javascript
   function leak() {
     leakedVar = '全局变量'; // 未用 var/let/const 声明
     this.temp = '隐式绑定到全局'; // this 指向 window（非严格模式）
   }
   ```

2. **未清除的定时器或回调**  
   ```javascript
   const intervalId = setInterval(() => { /* ... */ }, 1000);
   // 未在组件销毁时调用 clearInterval(intervalId)
   ```

3. **闭包引用未释放**  
   ```javascript
   function outer() {
     const largeData = new Array(1000000).fill('*');
     return function inner() { 
       // 闭包保留了 largeData 的引用，即使 inner 未执行
     };
   }
   ```

4. **未解绑的 DOM 事件监听**  
   ```javascript
   element.addEventListener('click', onClick);
   // 未在元素移除时调用 removeEventListener
   ```

5. **残留的 DOM 引用**  
   ```javascript
   const elements = {
     button: document.getElementById('btn') // 即使 DOM 被移除，elements 仍持有引用
   };
   ```

6. **第三方库未销毁**  
   - 例如未调用 `chart.dispose()` 销毁 ECharts 实例。

**二、浏览器工具检测方法（以 Chrome DevTools 为例）**

1. **Memory 面板 - Heap Snapshots**  
   - **步骤**：  
     1. 录制初始堆快照（Take Heap Snapshot）。  
     2. 执行可能泄漏的操作（如打开/关闭组件）。  
     3. 录制第二次堆快照，筛选 `Comparison` 模式，查看对象增量。  
   - **用途**：定位未被释放的对象及引用链。

2. **Performance 面板 - Memory 监控**  
   - **步骤**：  
     1. 开启 Performance 录制。  
     2. 重复操作（如频繁切换页面）。  
     3. 观察内存折线图是否持续上升（未回落）。  
   - **用途**：快速识别内存增长趋势。

3. **Allocation instrumentation on timeline**  
   - **步骤**：  
     1. 选择 `Allocation instrumentation on timeline`。  
     2. 执行操作，观察内存分配堆栈。  
   - **用途**：追踪内存分配来源，定位未回收的代码位置。

4. **Detached Elements 检测**  
   - **方法**：在控制台输入 `queryObjects(HTMLDivElement)`，检查分离的 DOM 节点。  
   - **用途**：查找已从 DOM 树移除但仍被 JS 引用的元素。

**三、修复与预防**

- **及时清理**：定时器、事件监听、全局/缓存数据。  
- **弱引用**：使用 `WeakMap`/`WeakSet` 避免强引用。  
- **框架规范**：在 React/Vue 生命周期中正确销毁资源（如 `useEffect` 的清理函数）。  
- **代码审查**：避免闭包长期持有大对象，第三方库按文档销毁。  

## 解释 JavaScript 的垃圾回收机制

JavaScript 的垃圾回收机制核心是**自动管理内存，释放不再使用的对象所占用的内存空间**。具体实现如下：

**一、核心机制**

1. **标记清除（Mark-Sweep）**
   - **标记阶段**：从根对象（全局变量、活动函数作用域链）出发，递归标记所有可达对象为“活动对象”。
   - **清除阶段**：遍历堆内存，回收未被标记的不可达对象。
   - **优势**：解决循环引用问题（现代浏览器主要算法）。
2. **引用计数（Reference Counting）**
   - **原理**：记录每个对象被引用的次数，当引用数为 0 时立即回收。
   - **缺陷**：无法处理循环引用（如两个对象互相引用），已逐渐被淘汰。

**二、内存泄漏常见场景**

1. **未释放的闭包**：函数内部变量被外部引用，导致外部函数作用域无法回收。

   ```javascript
   function createLeak() {
     const data = new Array(1e6); // 大对象
     return () => console.log(data); // 闭包保留 data 的引用
   }
   const leak = createLeak(); // data 无法被回收
   ```

2. **未清理的 DOM 引用**：移除 DOM 元素后，未清除其 JS 变量引用。

   ```javascript
   const button = document.getElementById('btn');
   document.body.removeChild(button); // DOM 被移除
   // button 变量仍引用该 DOM 对象 → 内存泄漏
   ```

3. **未清除的定时器/事件监听**：

   ```javascript
   const timer = setInterval(() => {}, 1000);
   // 忘记 clearInterval(timer) → 定时器持续占用内存
   ```

**三、优化实践**

1. **手动解除引用**：不再使用的对象设为 `null`（如 `data = null`）。
2. **弱引用**：使用 `WeakMap`/`WeakSet`（键为弱引用，不影响垃圾回收）。
3. **避免内存膨胀**：分页加载大数据集，及时销毁无用缓存。

**总结**：理解垃圾回收机制可有效预防内存泄漏，关键是通过作用域管理和资源清理，确保对象及时变为“不可达”状态。

## 浏览器有哪几种缓存，各种缓存的优先级是什么样的？

浏览器缓存的核心是**通过多级缓存策略减少网络请求，提升加载速度**。优先级由高到低依次为：

**一、缓存类型与优先级**

1. **Service Worker 缓存**（最高优先级）
   - **特点**：可编程控制缓存策略，支持离线访问。
   - **场景**：PWA 应用、自定义缓存逻辑（如优先返回缓存，失败再请求网络）。
2. **Memory Cache（内存缓存）**
   - **特点**：浏览器内存缓存，快速读取但随进程关闭释放。
   - **场景**：页面刷新时，相同资源（如 Base64 图片）直接从内存加载。
3. **Disk Cache（磁盘缓存）**
   - **特点**：持久化缓存，容量大但读取速度较慢。
   - **子类**：
     - **强缓存**（`Cache-Control` / `Expires`）：直接使用本地缓存，不发送请求。
     - **协商缓存**（`Last-Modified` / `ETag`）：发送请求验证，返回 `304` 复用缓存。
4. **Push Cache（推送缓存）**（最低优先级）
   - **特点**：HTTP/2 服务器推送的临时缓存，会话结束即失效。
   - **场景**：多页面共享资源（如同一 CDN 的字体文件）。

**二、缓存匹配流程**

1. **请求资源时**：
   - **Service Worker** → **Memory Cache** → **Disk Cache（强缓存优先）** → **Push Cache** → **网络请求（协商缓存）**。
2. **示例**：
   - 若资源在 Service Worker 中命中，直接返回，不再检查其他缓存。
   - 若强缓存（如 `Cache-Control: max-age=3600`）有效，跳过网络请求。

**三、用户行为对缓存的影响**

- **正常刷新**：跳过强缓存，触发协商缓存（可能返回 `304`）。
- **强制刷新（Ctrl+F5）**：忽略所有缓存，直接请求最新资源。
- **关闭标签页**：Memory Cache 失效，Disk Cache 保留。

**总结**：Service Worker 优先级最高，其次是内存和磁盘缓存，最后是 HTTP/2 推送缓存。合理配置 `Cache-Control` 和 `ETag` 可显著优化性能。

## 什么是跨站脚本攻击（XSS）？如何防范？

**1. XSS 定义与类型**  

**跨站脚本攻击（XSS）** 是攻击者通过注入恶意脚本（通常是 JavaScript）到网页中，当其他用户访问该页面时，脚本在用户浏览器执行，从而窃取 Cookie、会话信息或劫持用户操作的攻击手段。  
**主要类型**：  
- **反射型 XSS**：恶意脚本通过 URL 参数传递，服务器直接返回给用户触发（如钓鱼链接）。  
- **存储型 XSS**：恶意脚本存储到服务器（如评论、数据库），用户访问页面时触发。  
- **DOM 型 XSS**：完全在客户端执行，通过修改 DOM 环境触发（如 `document.write` 动态插入未转义内容）。  

**2. 防范措施**  

**(1) 输入过滤与输出转义**  

- **输入验证**：对用户输入进行严格校验（如长度、格式），拒绝非法字符（如 `<`, `>`, `&`）。  
- **输出编码**：根据输出场景转义内容：  
  - HTML 内容：使用 `textContent` 替代 `innerHTML`，或转义 `<` 为 `&lt;`、`>` 为 `&gt;`。  
  - HTML 属性：转义 `"` 为 `&quot;`。  
  - JavaScript 内嵌数据：使用 `JSON.stringify` 并包裹在 `<script>` 标签中。  

**(2) 使用安全 API 与框架**  

- 避免直接操作 HTML：优先使用 `textContent` 而非 `innerHTML`。  
- 现代框架防护：React/Vue/Angular 默认对插值表达式自动转义。  

**(3) 内容安全策略（CSP）**  

通过 HTTP 头 `Content-Security-Policy` 限制资源加载来源，例如：  
```http  
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;  
```
- 禁止内联脚本（`'unsafe-inline'`）和 `eval`（`'unsafe-eval'`）。  
- 仅允许指定域名的脚本加载，阻断恶意脚本执行。  

**(4) 设置 Cookie 安全属性**  

- `HttpOnly`：禁止 JavaScript 读取 Cookie，防止会话劫持。  
- `Secure`：仅通过 HTTPS 传输 Cookie。  
```http  
Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict  
```

**(5) 富文本处理**  

使用白名单过滤库（如 `DOMPurify`、`xss`）处理富文本内容：  
```javascript  
import DOMPurify from 'dompurify';  
const cleanHTML = DOMPurify.sanitize(userInput);  
```

**(6) 其他措施**  

- 避免拼接 HTML：使用模板引擎（如 Handlebars）自动转义。  
- 定期安全测试：使用工具（如 OWASP ZAP、XSS 扫描器）检测漏洞。  

**示例攻击与防御**  

**攻击场景**：  
```javascript  
// 用户输入未转义直接插入页面  
document.getElementById('content').innerHTML = userComment;  
// 若 userComment 为 `<img src="x" onerror="stealCookie()">`，则触发 XSS  
```

**防御代码**：  
```javascript  
// 转义后输出  
const safeContent = escapeHTML(userComment);  
document.getElementById('content').textContent = safeContent;  

// 或使用 DOMPurify 处理  
const cleanHTML = DOMPurify.sanitize(userComment);  
element.innerHTML = cleanHTML;  
```

**总结**：XSS 防御核心在于 **不信任用户输入**，通过输入过滤、输出转义、CSP 等多层防护，结合框架特性和安全配置，全面阻断恶意脚本执行。

## 跨站请求伪造（CSRF）的原理是什么？如何防御？

**跨站请求伪造（CSRF）的原理及防御方法如下：**

**1. CSRF 原理**  

攻击者诱导用户在**已登录目标网站的状态下**，访问恶意页面或点击链接，利用浏览器的 **Cookie 自动携带机制**，伪造用户身份发起非法请求（如转账、修改密码）。  
**核心条件**：  
- 用户已登录目标网站（会话未过期）。  
- 请求参数可预测（如无需验证码或动态 Token）。  

**示例攻击流程**：  
1. 用户登录银行网站 `bank.com`，Cookie 保留登录态。  
2. 用户访问恶意网站，页面内隐藏一个自动提交的表单：  
   ```html  
   <form action="https://bank.com/transfer" method="POST">  
     <input type="hidden" name="to" value="hacker">  
     <input type="hidden" name="amount" value="1000">  
   </form>  
   <script>document.forms[0].submit();</script>  
   ```
3. 浏览器自动携带 `bank.com` 的 Cookie 提交请求，完成非法转账。  

**2. 防御方法**  

**(1) CSRF Token**  

- **机制**：  
  1. 服务端生成随机 Token，返回给客户端（如嵌入表单或响应头）。  
  2. 客户端在后续请求中携带 Token（表单字段或自定义请求头）。  
  3. 服务端验证 Token 合法性，拒绝非法请求。  
- **实现**：  
  ```html  
  <!-- 表单中嵌入 Token -->  
  <input type="hidden" name="csrf_token" value="{{csrfToken}}">  
  ```
  ```javascript  
  // 请求头添加 Token（如 Axios）  
  axios.defaults.headers.common['X-CSRF-Token'] = getCSRFToken();  
  ```

**(2) SameSite Cookie 属性**  

通过设置 Cookie 的 `SameSite` 属性，限制跨站请求携带 Cookie：  
- **`SameSite=Strict`**：完全禁止跨站携带 Cookie（可能影响用户体验）。  
- **`SameSite=Lax`**（默认）：允许 GET 请求跨站携带 Cookie（如导航链接），阻止 POST 等非安全方法。  
- **`SameSite=None`**：允许跨站携带，但需同时设置 `Secure`（仅 HTTPS）。  
```http  
Set-Cookie: sessionId=abc123; SameSite=Lax; Secure  
```

**(3) 验证请求来源（Referer/Origin）**  

- 检查请求头中的 `Referer` 或 `Origin` 是否来自可信域名。  
- **局限性**：部分浏览器可能不发送 `Referer`，且可能被伪造。  

**(4) 双重验证**  

- 敏感操作需附加验证（如短信验证码、密码二次确认）。  

**现代框架的自动防护**  

- **Django**：内置中间件 `django.middleware.csrf.CsrfViewMiddleware`，自动生成和验证 Token。  
- **Spring Security**：默认启用 CSRF 防护，要求表单提交携带 Token。  
- **React/Vue**：结合后端 Token，通过全局拦截器自动添加请求头。  

**总结**  

- **核心防御**：CSRF Token + SameSite Cookie。  
- **增强措施**：验证请求来源 + 敏感操作双重验证。  
- **避免依赖单一机制**，需多层次防护确保安全性。

## 什么是浏览器的同源策略，以及跨域？

**浏览器的同源策略（Same-Origin Policy）**

**1. 定义**

同源策略是浏览器的一项核心安全机制，用于限制不同源的文档或脚本之间的交互。  
**同源的条件**：协议（Protocol）、域名（Domain）、端口（Port）三者完全一致。  
- **示例**：  
  - 同源：`https://example.com/app` 与 `https://example.com/api`  
  - 不同源：`https://example.com` 与 `http://example.com`（协议不同）、`https://example.com` 与 `https://api.example.com`（子域不同）。

**2. 限制范围**

同源策略主要限制以下行为：  
- **AJAX 请求**：禁止跨域发送 `XMLHttpRequest` 或 `Fetch` 请求（除非目标服务器允许）。  
- **DOM 访问**：禁止通过 JavaScript 操作跨域页面的 DOM（如 `iframe` 内的内容）。  
- **Cookie/LocalStorage**：禁止读取跨域的 Cookie 或本地存储数据。

**跨域（Cross-Origin）问题**

**1. 触发条件**

当浏览器检测到 **目标资源与当前页面不同源**，且未明确允许跨域访问时，会拦截请求并报错（如 CORS 错误）。

**2. 常见场景**

- 前端页面部署在 `http://localhost:3000`，请求后端 API `http://api.example.com`。  
- 使用第三方服务（如 Google Maps API）未正确配置 CORS 头。

**跨域解决方案**

**1. CORS（跨源资源共享，Cross-Origin Resource Sharing）**

- **原理**：服务器通过 HTTP 响应头声明允许的跨域来源、方法和头信息。  
- **关键响应头**：  
  ```http
  Access-Control-Allow-Origin: https://example.com  # 允许的源
  Access-Control-Allow-Methods: GET, POST           # 允许的方法
  Access-Control-Allow-Headers: Content-Type        # 允许的请求头
  ```
- **预检请求（Preflight）**：对非简单请求（如 `PUT`、自定义头），浏览器自动发送 `OPTIONS` 请求确认权限。

**2. JSONP（JSON with Padding）**

- **原理**：利用 `<script>` 标签不受同源策略限制的特性，通过动态创建脚本获取数据。  
- **限制**：仅支持 `GET` 请求，存在安全风险（如 XSS）。  
- **示例**：  
  ```html
  <script src="https://api.example.com/data?callback=handleData"></script>
  <script>
    function handleData(data) { console.log(data); }
  </script>
  ```

**3. 代理服务器**

- **原理**：前端请求同源代理服务器，代理转发请求到目标服务器并返回结果。  
- **实现**：  
  - 开发环境：使用 Webpack DevServer、Vite Proxy 配置。  
  - 生产环境：通过 Nginx 反向代理。  
  ```nginx
  location /api {
    proxy_pass https://api.example.com;
  }
  ```

**4. WebSocket**

- **原理**：WebSocket 协议不受同源策略限制，适用于实时通信场景。  
  ```javascript
  const socket = new WebSocket('wss://api.example.com');
  socket.onmessage = (event) => { console.log(event.data); };
  ```

**5. postMessage**

- **原理**：允许跨域窗口间通过 `window.postMessage` 安全通信。  
  ```javascript
  // 父窗口发送消息
  iframe.contentWindow.postMessage('data', 'https://target-site.com');
  
  // 子窗口接收消息
  window.addEventListener('message', (event) => {
    if (event.origin !== 'https://parent-site.com') return;
    console.log(event.data);
  });
  ```

**同源策略的重要性**

- **安全防护**：防止恶意网站窃取用户敏感数据（如 Cookie）。  
- **隔离风险**：限制攻击面，避免跨站脚本攻击（XSS）和跨站请求伪造（CSRF）。

**总结**

- **同源策略**是浏览器安全基石，限制跨域交互以防止数据泄露。  
- **跨域问题**需通过 CORS、代理、JSONP 等技术解决，具体方案取决于场景和安全要求。  
- **现代开发**中，CORS 是主流解决方案，结合代理服务器可简化开发与部署流程。

## 前端性能优化的常见手段有哪些？

**一、加载优化**  

1. **减少资源体积**  
   - **代码压缩**：JS/CSS 文件通过工具（如 Terser、CSSNano）压缩。  
   - **Tree Shaking**：移除未使用的代码（Webpack/Rollup 支持）。  
   - **图片优化**：使用 WebP/AVIF 格式、CDN 动态裁剪、懒加载非首屏图片。  

2. **提升加载速度**  
   - **CDN 加速**：静态资源分发至边缘节点。  
   - **HTTP/2 或 HTTP/3**：多路复用减少连接开销。  
   - **预加载关键资源**：`<link rel="preload">` 提前加载字体、关键 CSS/JS。  

3. **减少请求数量**  
   - **合并文件**：将小图标合并为雪碧图（Sprite）。  
   - **内联关键 CSS**：避免首屏渲染阻塞。  
   - **按需加载**：动态导入非关键代码（如 `import()` 或路由懒加载）。  

4. **缓存策略**  
   - **强缓存**：通过 `Cache-Control: max-age` 减少重复请求。  
   - **协商缓存**：利用 `ETag`/`Last-Modified` 验证资源是否过期。  

**二、渲染优化**  

1. **减少重排（Reflow）与重绘（Repaint）**  
   - 避免频繁操作 DOM，使用 `transform`/`opacity` 触发 GPU 加速（合成层）。  
   - 批量修改样式（如 `classList` 替代多次 `style` 操作）。  

2. **优化关键渲染路径**  
   - **优先加载 CSS**：CSS 放 `<head>` 中，避免阻塞渲染。  
   - **异步非关键 JS**：使用 `async`/`defer` 延迟脚本执行。  

3. **优化长列表性能**  
   - **虚拟滚动**：仅渲染可视区域内容（如 React-Virtualized、Vue Virtual Scroller）。  
   - **分页加载**：避免一次性渲染大量 DOM 节点。  

4. **合理使用合成层**  
   - 通过 `will-change: transform` 或 `translateZ(0)` 提升动画元素至独立图层。  

**三、交互优化**  

1. **事件处理优化**  
   - **防抖（Debounce）与节流（Throttle）**：控制高频事件（如 `scroll`/`resize`）触发频率。  
   - **事件委托**：利用事件冒泡，减少事件监听器数量（如 `addEventListener` 到父节点）。  

2. **主线程优化**  
   - **Web Workers**：将复杂计算（如数据处理）移至子线程，避免阻塞 UI 渲染。  
   - **时间切片**：使用 `requestIdleCallback` 或 React 的 `Scheduler` 拆分长任务。  

3. **动画优化**  
   - **使用 CSS 动画**：优先用 `transition`/`animation`，而非 JS 定时器修改样式。  
   - **优化帧率**：确保动画在 `requestAnimationFrame` 中执行，保持 60fps。  

4. **现代框架最佳实践**

   - **React**：

     - **减少渲染次数**

       - **`React.memo`**：缓存函数组件，避免父组件更新触发的子组件无意义渲染。
       - **`useCallback`/`useMemo`**：缓存函数和计算值，避免因引用变化触发子组件更新。
       - **`shouldComponentUpdate`**（类组件）：手动控制组件是否更新。

     - **代码分割与懒加载**

       - **`React.lazy` + `Suspense`**：动态加载组件，减少首屏体积。

       ```JavaScript
       const LazyComponent = React.lazy(() => import('./Component'));  
       ```

     - **虚拟化长列表**

       - **`react-window` 或 `react-virtualized`**：仅渲染可视区域内的列表项。

     - **状态管理优化**

       - **局部状态优先**：避免将状态过度提升到全局（如 Redux）。
       - **选择器优化**：使用 `reselect`（Redux）或 `useSelector` 缓存派生状态。

     - **并发模式（Concurrent Mode）**

       - **时间切片**：通过 `useTransition`/`useDeferredValue` 拆分长任务，保持交互响应。
       - **流式渲染**：配合 `Suspense` 逐步渲染页面区块。

   - **Vue**：

     - **响应式系统优化**

       - **避免深层响应式**：对无需响应式的大对象使用 `Object.freeze()` 或 `shallowRef`/`shallowReactive`（Vue 3）。
       - **合理拆分组件**：细化组件粒度，减少响应式依赖追踪范围。

     - **减少不必要的渲染**

       - **`v-once`**：标记静态内容，仅渲染一次。
       - **`v-memo`**（Vue 3）：缓存子树，依赖项未变化时跳过渲染。
       - **`computed` 属性**：缓存计算值，避免重复计算。

     - **组件懒加载**

       - **异步组件**：结合 `defineAsyncComponent` 按需加载非关键组件。

       ```JavaScript
       const AsyncComp = defineAsyncComponent(() => import('./Component.vue'));  
       ```

     - **列表渲染优化**

       - **`key` 属性**：为 `v-for` 列表项设置唯一且稳定的 `key`。
       - **虚拟滚动**：使用 `vue-virtual-scroller` 优化长列表性能。

     - **状态管理优化**

       - **局部状态**：避免将全局状态（如 Vuex/Pinia）用于局部组件。
       - **`shallowReadonly`**（Vue 3）：限制对只读状态的深层访问。

   - **通用优化手段**

     1. **减少 DOM 操作**
        - 批量更新（Vue 自动批处理，React 18+ 默认批处理）。
        - 使用 CSS 动画替代 JS 动画，触发 GPU 加速。
     2. **内存泄漏预防**
        - **清除副作用**：Vue 的 `onUnmounted`、React 的 `useEffect` 清理函数。
     3. **工具链优化**
        - **Vite（Vue）**：利用 ES 模块原生加载加速开发构建。
        - **Webpack（React）**：配置代码分割、Tree Shaking。
     4. **性能分析工具**
        - **Vue Devtools**：检测组件渲染次数和时间。
        - **React DevTools Profiler**：录制并分析组件渲染性能。

**四、其他优化**  

1. **字体优化**  
   - 使用 `font-display: swap` 避免文字渲染阻塞（FOIT）。  
   - 子集化字体（如通过 FontTools 移除未用字符）。  

2. **第三方库控制**  
   - 按需引入（如 Lodash 的 `lodash-es`）。  
   - 延迟加载非核心库（如 `IntersectionObserver` 监听可见时加载）。  

3. **服务端优化**  
   - **SSR/SSG**：服务端渲染（如 Next.js）或静态生成（如 Gatsby），加速首屏渲染。  
   - **Edge Side Includes (ESI)**：CDN 边缘节点动态拼接页面片段。  
4. **工具与监控**
   - **Lighthouse**：分析FCP、LCP、CLS等核心指标。
   - **Chrome DevTools**：Performance面板排查长任务，Memory面板查泄漏。



**工具与监控**：  
- **Lighthouse**：分析性能指标（FCP、LCP、CLS）。  
- **Chrome DevTools**：Performance 面板分析运行时性能，Memory 面板排查内存泄漏。  
- **RUM（真实用户监控）**：通过 Sentry、New Relic 收集线上性能数据。  

**总结**：性能优化需结合 **加载速度、渲染效率、交互流畅度** 多维度分析，优先解决瓶颈问题（如 20% 的优化带来 80% 的收益）。

## 如何检测浏览器是否支持某个 API

**检测浏览器是否支持某个 API 的常用方法如下：**

**1. 直接属性检查**

通过判断全局对象（如 `window`、`navigator`）是否包含该 API：
```javascript
if ('IntersectionObserver' in window) {
  // 支持 IntersectionObserver
} else {
  // 不支持，降级处理
}
```

**2. 安全类型检查（更严谨）**

使用 `typeof` 避免因某些浏览器将未实现的 API 赋值为 `null` 或 `0` 导致的误判：
```javascript
if (typeof window.IntersectionObserver === 'function') {
  // 支持
}
```

**3. 检测嵌套对象中的 API**

若 API 位于深层对象中（如 `navigator.mediaDevices.getUserMedia`）：
```javascript
function isGetUserMediaSupported() {
  return !!(
    navigator.mediaDevices &&
    typeof navigator.mediaDevices.getUserMedia === 'function'
  );
}
```

**4. 使用 Modernizr（第三方库）**

自动检测浏览器特性并生成标记：
```html
<script src="modernizr.js"></script>
<script>
  if (Modernizr.intersectionobserver) {
    // 支持
  }
</script>
```

**5. 动态加载 Polyfill**

检测到不支持时，动态加载兼容代码：
```javascript
if (!('fetch' in window)) {
  import('whatwg-fetch').then(() => {
    // 加载完成后执行
  });
}
```

**6. 兼容性数据查询**

参考 [MDN](https://developer.mozilla.org/) 或 [Can I Use](https://caniuse.com/) 获取 API 的浏览器支持范围。

**示例（检测 `ResizeObserver` 支持）：**
```javascript
const isResizeObserverSupported = 
  typeof window.ResizeObserver === 'function';

if (isResizeObserverSupported) {
  const observer = new ResizeObserver(callback);
} else {
  console.warn('当前浏览器不支持 ResizeObserver');
  // 降级为监听 window.resize 等
}
```

**总结**：优先使用 `typeof` 或 `in` 运算符进行特性检测，结合降级方案提升兼容性，复杂场景可借助工具库或动态加载 Polyfill。

## 什么是浏览器的内存泄漏？常见场景有哪些？如何排查？

**1. 内存泄漏定义**  

内存泄漏指程序中已不再使用的对象，因被意外引用而无法被垃圾回收（GC），导致内存占用持续增长，最终引发页面卡顿或崩溃。

**2. 常见泄漏场景**  

- **未清除的定时器/回调**  
  ```javascript  
  // 定时器未清除  
  const timer = setInterval(() => {}, 1000);  
  // 组件销毁时需 clearInterval(timer);  
  ```

- **闭包长期引用外部变量**  
  ```javascript  
  function outer() {  
    const largeData = new Array(1000000);  
    return () => largeData; // 闭包持有 largeData 的引用  
  }  
  ```

- **未解绑的 DOM 事件监听**  
  ```javascript  
  element.addEventListener('click', onClick);  
  // 元素移除前需 element.removeEventListener('click', onClick);  
  ```

- **全局变量意外累积**  
  ```javascript  
  function leak() {  
    leakedVar = '全局变量'; // 未声明变量，挂载到 window  
  }  
  ```

- **第三方库未销毁**  
  ```javascript  
  const chart = echarts.init(dom);  
  // 组件卸载时需 chart.dispose();  
  ```

- **框架组件内未清理副作用**  
  ```javascript  
  // React useEffect 未返回清理函数  
  useEffect(() => {  
    window.addEventListener('resize', handleResize);  
  }, []);  
  ```

**3. 排查方法（Chrome DevTools）**  

**步骤 1：监控内存趋势**  

- **Performance 面板**：录制页面操作，观察 JS Heap 是否持续上升。  

**步骤 2：定位泄漏源**  

- **Memory 面板 - Heap Snapshots**：  
  1. 操作前拍摄快照（Baseline）。  
  2. 执行疑似泄漏的操作（如打开/关闭组件）。  
  3. 再次拍摄快照（Comparison），筛选新增的未释放对象。  

- **Allocation instrumentation timeline**：  
  实时记录内存分配堆栈，定位频繁分配且未回收的代码位置。  

**步骤 3：检测分离的 DOM**  

- 控制台输入 `queryObjects(HTMLDivElement)`，查看已脱离 DOM 树但被 JS 引用的节点。  

**4. 修复与预防**  

- **及时清理资源**：定时器、事件监听、全局引用。  
- **弱引用优化**：使用 `WeakMap`/`WeakSet` 避免强引用。  
- **框架规范**：  
  - **React**：在 `useEffect` 清理函数中销毁资源。  
  - **Vue**：在 `onUnmounted` 生命周期解绑监听。  
- **代码审查**：避免闭包长期引用大对象，第三方库按文档销毁。  

## document.write 和 innerHTML 的区别是什么？动态添加大量内容时如何优化？

**一、核心区别**

| **特性**     | **document.write**                         | **innerHTML**                           |
| ------------ | ------------------------------------------ | --------------------------------------- |
| **作用对象** | 直接操作文档流                             | 操作特定 DOM 元素的 HTML 内容           |
| **执行时机** | 页面加载中：插入内容；加载后：覆盖整个文档 | 任何时间操作，不影响其他内容            |
| **性能影响** | 页面加载阶段高效；加载后使用会清空页面     | 频繁修改触发重排/重绘，大量内容性能较差 |
| **安全性**   | 可能引发 XSS 注入                          | 更易引发 XSS（需手动转义）              |
| **现代使用** | 已不推荐，仅遗留代码或特定场景使用         | 常用，但需谨慎处理动态内容              |

**二、动态添加大量内容的优化方案**

**1. 减少 DOM 操作频率**  

- **使用 DocumentFragment**  
  创建虚拟节点树，批量插入 DOM，避免多次重排：  
  ```javascript  
  const fragment = document.createDocumentFragment();  
  for (let i = 0; i < 1000; i++) {  
    const div = document.createElement('div');  
    fragment.appendChild(div);  
  }  
  document.body.appendChild(fragment);  
  ```

- **字符串拼接后一次性设置 innerHTML**  
  ```javascript  
  let html = '';  
  for (let i = 0; i < 1000; i++) {  
    html += `<div>${i}</div>`;  
  }  
  container.innerHTML = html;  
  ```

**2. 分批次渲染**  

- **时间切片（requestAnimationFrame）**  
  将任务拆分为多帧执行，避免阻塞主线程：  
  ```javascript  
  function renderChunk(data, chunkSize, index = 0) {  
    const chunk = data.slice(index, index + chunkSize);  
    chunk.forEach(item => {  
      container.appendChild(createElement(item));  
    });  
    if (index < data.length) {  
      requestAnimationFrame(() => renderChunk(data, chunkSize, index + chunkSize));  
    }  
  }  
  ```

- **虚拟滚动（Virtual Scrolling）**  
  仅渲染可视区域内容，适用于超长列表：  
  ```javascript  
  // 使用库如 react-window 或 vue-virtual-scroller  
  <List height={600} itemSize={35} itemCount={10000}>  
    {({ index, style }) => <div style={style}>Item {index}</div>}  
  </List>  
  ```

**3. 优化 DOM 结构**  

- **隐藏容器后操作（display: none）**  
  操作完成后再显示，减少中间渲染计算：  
  ```javascript  
  container.style.display = 'none';  
  // 批量插入内容  
  container.style.display = 'block';  
  ```

- **使用 CSS 动画优化渲染**  
  对位移、透明度等属性使用 `transform`/`opacity`，触发 GPU 加速。  

**4. 避免 XSS 风险**  

- **转义动态内容**  
  使用 `textContent` 或 `DOMPurify.sanitize()` 处理用户输入：  
  ```javascript  
  const safeHTML = DOMPurify.sanitize(userInput);  
  container.innerHTML = safeHTML;  
  ```

**三、总结**  

- **优先选择 `innerHTML`**：更可控，但需注意性能与安全。  
- **替代方案**：推荐使用 `createElement` + `appendChild` 或现代框架（如 React 的虚拟 DOM）。  
- **核心优化原则**：  
  - **减少直接 DOM 操作次数**（批量处理）。  
  - **分块渲染**避免阻塞主线程。  
  - **利用 GPU 加速**合成层。

## 请解释一下浏览器引擎的工作原理是什么？

浏览器引擎的核心工作原理是**将网页代码（HTML/CSS/JS）转换为可视化页面和可交互程序**，主要通过渲染引擎与 JavaScript 引擎协作完成。以下是具体流程：

**一、核心模块分工**

1. **渲染引擎（如 Blink/WebKit）**
   - **HTML 解析**：将 HTML 转换为 DOM 树（Document Object Model）。
   - **CSS 解析**：将 CSS 转换为 CSSOM 树（CSS Object Model）。
   - **渲染树构建**：合并 DOM 和 CSSOM 生成 Render Tree（仅包含可见元素）。
   - **布局（Layout）**：计算每个节点的几何位置（重排）。
   - **绘制（Painting）**：将布局结果栅格化为像素（重绘）。
   - **合成（Compositing）**：分层绘制，GPU 加速合成最终画面。
2. **JavaScript 引擎（如 V8/SpiderMonkey）**
   - **解析（Parsing）**：将 JS 代码转换为抽象语法树（AST）。
   - **编译（Compilation）**：即时编译（JIT）为机器码。
   - **执行（Execution）**：在调用栈中运行代码，通过事件循环处理异步任务。

**二、关键协作流程**

1. **阻塞与并行**
   - **HTML 解析**：遇到 `<script>` 默认阻塞 DOM 构建（除非标记 `async/defer`）。
   - **CSS 加载**：阻塞渲染树合成（但 DOM 解析可继续）。
2. **关键渲染路径优化**
   - **优化目标**：最小化首次渲染时间（First Meaningful Paint）。
   - **优化手段**：
     - 内联关键 CSS/JS
     - 预加载关键资源（`<link rel="preload">`）
     - 延迟非必要脚本（`async/defer`）
3. **交互响应机制**
   - **事件循环（Event Loop）**：通过任务队列（宏任务/微任务）调度 JS 执行与渲染更新。
   - **帧率同步**：`requestAnimationFrame` 确保动画与浏览器刷新率同步（通常 60fps）。

**三、现代引擎优化特性**

1. **渐进式渲染**：流式解析 HTML，逐步显示内容（如 Chrome 的预渲染扫描器）。
2. **GPU 加速**：通过分层合成（Composite Layers）和光栅化线程减少主线程负载。
3. **推测执行**：预加载可能需要的资源（如 Chrome 的预加载器预测后续请求）。

**四、示例引擎架构**

- **Chromium（Blink + V8）**：
  - 多进程架构（渲染进程、GPU 进程、浏览器主进程）
  - 支持 WebAssembly、WebGPU 等新标准
- **Firefox（Gecko + SpiderMonkey）**：
  - 增量垃圾回收
  - 更严格的隐私保护策略

**总结**：浏览器引擎通过多阶段流水线将代码转化为交互式页面，其性能直接影响用户体验，理解原理有助于针对性优化网页性能。

## V8 引擎是什么，它是如何提高 JavaScript 执行性能的？

V8 引擎是 **Google 开发的高性能 JavaScript 引擎**，核心目标是**通过即时编译（JIT）和内存优化，让 JavaScript 执行速度接近原生代码**。以下是其核心优化手段：

**一、关键性能优化技术**

1. **即时编译（JIT）**

   - **基线编译器（Ignition）**：快速生成未优化的字节码，支持快速启动。
   - **优化编译器（TurboFan）**：根据代码运行时的类型反馈（Type Feedback）生成高度优化的机器码。
   - **去优化（Deoptimization）**：当假设失效（如变量类型突变）时，回退到字节码重新优化。

2. **隐藏类（Hidden Class）与内联缓存（Inline Cache）**

   - **隐藏类**：为动态对象的结构分配固定内存布局，减少属性访问耗时（类似静态语言的类结构）。

     ```javascript
     // 对象 a 和 b 共享同一隐藏类（结构相同）
     const a = { x: 1, y: 2 };
     const b = { x: 3, y: 4 };
     ```

   - **内联缓存**：缓存对象属性的内存偏移量，加速后续访问（如 `obj.x` 直接通过缓存定位）。

3. **高效垃圾回收（GC）**

   - **分代式回收**：
     - **新生代（Scavenge）**：使用复制算法快速回收短期对象（如函数局部变量）。
     - **老生代（Mark-Sweep/Compact）**：标记-清除/整理算法处理长期存活对象（如全局变量）。
   - **增量标记与并行回收**：减少主线程阻塞时间，避免页面卡顿。

4. **热点代码优化**

   - **函数内联（Inlining）**：将小函数直接嵌入调用处，减少调用开销。
   - **逃逸分析**：识别未逃逸对象，直接在栈上分配内存（避免堆内存分配）。

**二、其他优化特性**

1. **WebAssembly 支持**
   - 直接编译 C/C++/Rust 等语言到机器码，突破 JavaScript 性能瓶颈（如游戏、音视频处理）。
2. **并发解析与编译**
   - 在后台线程预解析代码，减少主线程编译耗时（如流式解析大型脚本）。
3. **内存压缩指针（Pointer Compression）**
   - 将 64 位指针压缩为 32 位，减少内存占用（适用于堆内存小于 4GB 的场景）。

**三、性能对比**

- **解释执行（如早期 JS 引擎）**：逐行翻译代码，速度慢。
- **V8 JIT 优化**：通过动态编译，性能提升 **10~100 倍**，接近 C++ 水平。

**示例**：

```javascript
// 循环优化前（未编译）
for (let i = 0; i < 1e6; i++) { ... }

// TurboFan 优化后生成机器码，循环速度接近原生代码
```



**总结**：V8 通过 JIT 编译、隐藏类、分代 GC 等设计，将 JavaScript 从解释型语言提升到接近编译型语言的性能，支撑了现代 Web 应用和高性能 Node.js 服务。

## 浏览器一帧都会干些什么？

- 接受输入事件
- 执行事件回调
- 开始一帧
- 执行 RAF (RequestAnimationFrame)
- 页面布局，样式计算
- 绘制渲染
- 执行 RIC (RequestIdelCallback)

第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。



## 浏览器并发请求数限制是多少？如何绕过？

**浏览器并发请求数限制与绕过策略**

**1. 浏览器并发请求数限制**

浏览器对 **同一域名下的并发请求数** 有严格限制，主要出于性能优化和防止服务器过载的考虑。不同浏览器及协议的限制如下：  
| **浏览器/协议**     | **HTTP/1.1** | **HTTP/2**             |
| ------------------- | ------------ | ---------------------- |
| Chrome/Firefox/Edge | 6            | 无硬性限制（多路复用） |
| Safari              | 6            | 无硬性限制             |
| 移动端浏览器        | 4-6          | 无硬性限制             |

**注**：HTTP/1.1 的并发限制是针对同一域名的 TCP 连接数，每个连接只能串行处理请求；HTTP/2 通过多路复用（Multiplexing）在单个连接上并行传输多个请求，突破此限制。

**2. 绕过并发限制的常用方法**

**（1）域名分片（Domain Sharding）**  

- **原理**：将资源分散到多个子域名，每个子域名独立计算并发限制。  
  ```html  
  <!-- 图片资源分片到不同子域 -->  
  <img src="https://static1.example.com/image1.jpg">  
  <img src="https://static2.example.com/image2.jpg">  
  ```
- **优点**：简单有效，兼容所有浏览器。  
- **缺点**：  
  - 增加 DNS 解析开销（可预解析缓解：`<link rel="dns-prefetch" href="//static1.example.com">`）。  
  - HTTP/2 下效果反降（多域名破坏连接复用）。

**（2）升级至 HTTP/2**  

- **原理**：利用 HTTP/2 的多路复用和头部压缩特性，单连接并行处理多个请求。  
- **实现**：  
  - 服务器启用 TLS（HTTP/2 主流实现需 HTTPS）。  
  - 配置 Nginx/Apache 支持 HTTP/2。  
- **优点**：彻底解决并发限制，减少连接开销，提升加载速度。  
- **缺点**：需服务器和客户端支持，旧版本浏览器（如 IE11）不兼容。

**（3）资源合并（Asset Concatenation）**  

- **原理**：将多个小文件合并为单个文件（如 CSS/JS 打包）。  
  ```javascript  
  // Webpack 配置合并 JS  
  module.exports = {  
    entry: { main: './src/index.js' },  
    output: { filename: 'bundle.js' }  
  };  
  ```
- **优点**：减少请求数，适合低变动资源。  
- **缺点**：  
  - 缓存失效粒度变粗（修改一个小文件需重新下载整个包）。  
  - 首屏加载时间可能增加（需权衡代码分割）。

**（4）懒加载（Lazy Loading）**  

- **原理**：按需加载非关键资源（如图片、次级路由组件）。  
  ```javascript  
  // 图片懒加载  
  <img data-src="image.jpg" class="lazyload">  
  <script>  
    const observer = new IntersectionObserver(entries => {  
      entries.forEach(entry => {  
        if (entry.isIntersecting) {  
          entry.target.src = entry.target.dataset.src;  
          observer.unobserve(entry.target);  
        }  
      });  
    });  
    document.querySelectorAll('.lazyload').forEach(img => observer.observe(img));  
  </script>  
  ```
- **优点**：减少初始请求数，提升首屏速度。  
- **缺点**：需额外逻辑控制，滚动体验可能受影响。

**（5）Service Worker 缓存**  

- **原理**：通过 Service Worker 拦截请求并缓存资源，减少网络请求。  
  ```javascript  
  // 注册 Service Worker  
  if ('serviceWorker' in navigator) {  
    navigator.serviceWorker.register('/sw.js')  
      .then(registration => console.log('SW registered'))  
      .catch(err => console.log('SW failed:', err));  
  }  
  
  // sw.js 缓存策略  
  self.addEventListener('fetch', event => {  
    event.respondWith(  
      caches.match(event.request).then(response => {  
        return response || fetch(event.request);  
      })  
    );  
  });  
  ```
- **优点**：离线可用，重复资源直接读缓存。  
- **缺点**：需处理缓存更新策略，首次加载需注册。

**3. 方案选型建议**  

| **场景**                | **推荐方案**                 | **理由**           |
| ----------------------- | ---------------------------- | ------------------ |
| 传统项目（HTTP/1.1）    | 域名分片 + 资源合并          | 兼容性好，快速生效 |
| 现代项目（支持 HTTP/2） | HTTP/2 + 懒加载              | 性能最优，未来趋势 |
| 高动态资源              | 懒加载 + Service Worker      | 按需加载，缓存降级 |
| 兼容旧浏览器            | 域名分片 + 资源合并 + 预加载 | 平衡性能与兼容性   |

**4. 工具与检测**  

- **性能分析工具**：  
  - Chrome DevTools **Network Panel**：查看请求队列和瀑布流。  
  - Lighthouse：评估并发请求优化效果。  
- **自动化构建**：  
  - Webpack/Vite：代码分割（`SplitChunksPlugin`）、资源压缩。  
  - Nginx：配置 HTTP/2、域名分片。  

**总结**  

浏览器并发限制是 HTTP/1.1 时代的产物，HTTP/2 多路复用已极大缓解此问题。实际项目中应：  
1. **优先升级 HTTP/2**，发挥多路复用优势。  
2. **结合懒加载与代码分割**，减少非关键资源阻塞。  
3. **域名分片作为保底方案**，兼容旧环境。  
4. **监控性能指标**，持续优化请求队列与缓存策略。

## 浏览器对队头阻塞有什么优化？

**浏览器对队头阻塞（HOL Blocking）的优化策略**

队头阻塞（Head-of-Line Blocking）指在顺序处理的通信管道中，前序任务延迟导致后续任务被阻塞的现象。浏览器在不同层级（HTTP、TCP、资源加载）采取了多种优化措施：

**1. HTTP 层优化**

**(1) HTTP/2 多路复用（Multiplexing）**

- **原理**：在单个 TCP 连接上并行传输多个请求/响应（通过二进制分帧）。  
- **效果**：  
  - 解决 HTTP/1.1 的请求队列阻塞问题（6 连接限制）。  
  - 允许乱序响应，避免前序请求延迟影响后续请求。  
- **示例**：  
  ```plaintext
  HTTP/2 帧结构：
  Stream 1: Header Frame → Data Frame (请求1)
  Stream 2: Header Frame → Data Frame (请求2)
  ```

**(2) 请求优先级（Priority Hints）**

- **原理**：通过 `priority` 属性或 HTTP/2 的优先级树（Priority Tree）标记资源加载顺序。  
- **实现**：  
  ```html
  <!-- 标记高优先级资源 -->
  <link rel="stylesheet" href="critical.css" importance="high">
  <script src="main.js" fetchpriority="high"></script>
  ```
- **效果**：优先加载关键资源（如 CSS、首屏 JS），减少渲染阻塞。

**(3) 服务器推送（Server Push）**

- **原理**：服务器主动推送相关资源（如 CSS/JS），无需等待客户端解析 HTML 后请求。  
- **示例**：  
  ```http
  HTTP/2 响应头：
  Link: </styles.css>; rel=preload; as=style
  ```

**2. 传输层优化**

**(1) QUIC 协议（HTTP/3）**

- **原理**：基于 UDP 实现可靠传输，每个流（Stream）独立处理，彻底解决 TCP 队头阻塞。  
- **优势**：  
  - 单包丢失仅影响当前流，其他流不受影响。  
  - 更快的连接建立（0-RTT/1-RTT 握手）。  
- **应用**：Chrome、Edge 等现代浏览器默认支持 HTTP/3。

**(2) TCP Fast Open（TFO）**

- **原理**：允许在 TCP 握手期间携带数据，减少连接延迟。  
- **效果**：降低首字节时间（TTFB），缓解队头阻塞对首请求的影响。

**3. 浏览器资源加载优化**

**(1) 预加载（Preload）**

- **原理**：提前加载关键资源，减少后续请求队列压力。  
  ```html
  <link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
  ```
- **工具支持**：通过 Lighthouse 检测未预加载的资源。

**(2) 预连接（Preconnect）**

- **原理**：提前建立 DNS 查询、TCP 连接、TLS 握手。  
  ```html
  <link rel="preconnect" href="https://cdn.example.com">
  ```

**(3) 域名分片（Domain Sharding）**

- **原理**：将资源分配到多个子域，绕过 HTTP/1.1 的并发限制。  
  ```html
  <img src="https://static1.example.com/img1.jpg">
  <img src="https://static2.example.com/img2.jpg">
  ```

**(4) 资源懒加载（Lazy Loading）**

- **原理**：按需加载非关键资源（如图片、视频）。  
  
  ```html
  <img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
  ```

**4. 渲染层优化**

**(1) 异步脚本（Async/Defer）**

- **原理**：非阻塞加载 JS，避免脚本解析阻塞 DOM/CSSOM 构建。  
  ```html
  <script src="app.js" defer></script>  <!-- DOM 解析完成后执行 -->
  <script src="analytics.js" async></script> <!-- 下载完成后立即执行 -->
  ```

**(2) 增量渲染（Incremental Rendering）**

- **原理**：浏览器逐步渲染已接收的 HTML 片段，无需等待完整文档。  
- **示例**：  
  ```html
  <!-- 分块传输（Chunked Encoding） -->
  Transfer-Encoding: chunked
  ```

**各协议层队头阻塞对比**

| **协议/技术**     | 队头阻塞类型         | 优化手段                 |
| ----------------- | -------------------- | ------------------------ |
| **HTTP/1.1**      | 请求队列阻塞         | 域名分片、并发连接       |
| **HTTP/2**        | TCP 层阻塞（单个流） | 多路复用、优先级控制     |
| **HTTP/3 (QUIC)** | 无传输层队头阻塞     | 独立流处理、UDP 多路复用 |

**总结**

浏览器通过 **协议升级（HTTP/2/3）**、**资源加载策略（预加载/懒加载）** 和 **渲染优化（异步脚本）** 多维度缓解队头阻塞：  
- **HTTP/2**：解决应用层队头阻塞，但受限于 TCP 层。  
- **HTTP/3**：基于 QUIC 彻底消除传输层队头阻塞，成为未来趋势。  
- **工程实践**：结合预加载、域名分片、懒加载等策略，最大化页面加载效率。
