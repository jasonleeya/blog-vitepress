---
category: 浏览器
order: 10
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 浏览器

## 常见的浏览器内核有哪些？

浏览器内核的核心是**实现网页渲染和脚本执行的基础引擎**，常见内核可分为渲染引擎与 JavaScript 引擎两类。以下是具体分类与代表浏览器：

**一、渲染引擎（Rendering Engine）**

1. **Trident（IE 内核）**
   - **特点**：微软开发，兼容旧版 IE 标准，性能较差。
   - **代表浏览器**：IE（已停更）、旧版 Edge（2019 年前）、国内双核浏览器的兼容模式（如 360 浏览器）。
2. **Gecko（Firefox 内核）**
   - **特点**：开源，支持现代 Web 标准严格，扩展性强。
   - **代表浏览器**：Mozilla Firefox、Waterfox。
3. **WebKit（Safari 内核）**
   - **特点**：苹果主导，轻量高效，移动端优化。
   - **代表浏览器**：Safari、旧版 Chrome（2013 年前）。
4. **Blink（Chrome/Edge 内核）**
   - **特点**：WebKit 的分支，Google 主导开发，高性能，快速迭代。
   - **代表浏览器**：Chrome、新版 Edge（2019 后）、Opera、大部分国产浏览器（如 QQ 浏览器）。
5. **Presto（已废弃）**
   - **特点**：Opera 自主研发，渲染速度快，兼容性差。
   - **历史浏览器**：Opera（2013 年前）。

**二、JavaScript 引擎**

1. **V8（Chrome/Node.js）**
   - **特点**：Google 开发，高性能，支持即时编译（JIT）。
2. **SpiderMonkey（Firefox）**
   - **特点**：Mozilla 开发，首个 JavaScript 引擎。
3. **JavaScriptCore（Safari）**
   - **特点**：苹果开发，原名 Nitro，针对移动端优化。

**三、国内浏览器内核现状**

1. **双核模式**：
   - 兼容模式：Trident（处理老旧政府/企业网站）。
   - 极速模式：Blink（默认模式，如 360 浏览器、搜狗浏览器）。
2. **自主内核（探索阶段）**：
   - 如华为 HarmonyOS 的 Ark 引擎（基于 Chromium 二次开发）。

**四、核心差异与趋势**

- **性能对比**：Blink > WebKit > Gecko > Trident。
- **市场份额**：Blink（Chrome/Edge 主导）> WebKit（Safari 移动端优势）。
- **开发方向**：Blink 持续推动 Web 新特性（如 WebGPU），Trident 逐渐淘汰。

**总结**：现代浏览器以 Blink 和 WebKit 为主流内核，兼容性测试需覆盖 Chrome、Safari、Firefox，国内项目额外关注双核浏览器的 Trident 模式。

## 说一说从输入URL到页面呈现发生了什么？

[从浏览器输入url后都经历了什么](#browser)

## 浏览器重绘域重排的区别？

[浏览器重绘域重排的区别？](#reflow-and-repaint)

## CSS加载会阻塞DOM吗？

CSS加载**不会阻塞DOM的解析**，但**会阻塞页面的渲染**。

具体来说：

1. **DOM解析不阻塞**：浏览器会并行解析HTML和下载CSS文件，DOM树的构建可继续进行。
2. **渲染阻塞**：浏览器需等待CSSOM（CSS对象模型）构建完成后，才会生成渲染树（Render Tree），因此页面内容会保持空白，直到CSS加载完成。
3. **优化手段**：
   - **内联关键CSS**：首屏样式直接写入HTML，减少外链阻塞时间。
   - **异步加载非关键CSS**：通过`<link media="print" onload="this.media='all'">`实现异步加载。
   - **CDN加速**：缩短CSS文件加载耗时。

## script 标签defer和async的区别？

`defer` 和 `async` 是用于优化脚本加载的 HTML 属性，**核心区别在于脚本的执行时机和顺序**：

一句话总结：

- **`async`**：异步下载，下载完成后立即执行（执行顺序不确定）。
- **`defer`**：异步下载，延迟到 HTML 解析完成后按顺序执行。

## html文档渲染过程，css文件和js文件的下载，是否会阻塞渲染？

浏览器内有多个进程，其中渲染进程被称为浏览器内核，负责页面渲染和执行 JS 脚本等。渲染进程负责浏览器的解析和渲染，内部有 JS 引擎线程、 GUI 渲染线程、事件循环管理线程、定时器线程、HTTP 线程。

JS 引擎线程负责执行 JS 脚本，GUI 渲染线程负责页面的解析和渲染，两者是互斥的，也就是执行 JS 的时候页面是停止解析和渲染的。这是因为如果在页面渲染的同时 JS 引擎修改了页面元素，比如清空页面，会造成后续页面渲染的不必要和错误。而由于 JS 经常要操作 DOM ，就要涉及 JS 引擎线程和 GUI 渲染线程的通信，而线程间通信代价是非常昂贵的，这也是造成 JS 操作 DOM 效率不高的原因。

浏览器的 HTML/CSS 的解析和渲染都属于 GUI渲染线程，所以和 JS 引擎线程是互斥、阻塞的。下面从代码实际运行的角度分析浏览器解析和渲染的顺序，以及互相间的阻塞关系。

**CSS 阻塞**

- css 文件的下载和解析不会影响 DOM 的解析，但是会阻塞 DOM 的渲染。因为 CSSOM Tree 要和 DOM Tree 合成 Render Tree 才能绘制页面。下面的 test1 在 css 下载并解析完成前是默认样式， test2 在 css 下载并解析完成之前不会显示：

```html
<button class="btn btn-primary">test1</button>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
<div>test2</div>
```

- css 文件没下载并解析完成之前，后续的 js 脚本不能执行。下面的 alert('ok') 在 css 下载并解析完成之前不会弹出来：

```html
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
<script>
    alert('ok')
</script>
```

- css 文件的下载不会阻塞前面的 js 脚本执行。下面的 alert('ok') 会在 css 下载完成前弹出：

```html
<script>
    alert('ok')
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
```

所以在需要提前执行不操作 dom 元素的 js 时，不妨把 js 放到 css 文件之前。

**js 阻塞**

js 文件的下载和解析会阻塞 GUI 渲染进程，也就是会阻塞 DOM 和 CSS 的解析和渲染。

js 文件没下载并解析完成之前，后续的 HTML 和 CSS 无法解析：

```html
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>
<div>test</div>
```

- js 文件的下载不会阻塞前面 HTML 和 CSS 的解析：

```html
<div>test</div>
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>
```

**需要注意的点**

- 第一，GUI 渲染线程会尽可能早的将内容呈现到屏幕上，并不会等到所有的 HTML 都解析完成之后再去构建和布局 Render Tree，而是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。下面 test1 会在 js 文件下载完成前渲染完成，而 test2 则会在 js 文件下载并执行完之后渲染：

```html
  <div>test1</div>
  <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
  <div>test2</div>
```

- 第二，文件的下载是不会被阻塞的，不管是 css 还是 js 文件，浏览器的主线程会在页面解析前开启下载，所以就算在外部脚本执行前删除脚本，脚本也还是会下载。

```html
<body>
  <script>
    document.body.remove()
  </script>  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css">
  <script src="https://code.jquery.com/jquery-3.4.1.js"></script>
</body>
```



## 解释 JavaScript 的垃圾回收机制

JavaScript 的垃圾回收机制核心是**自动管理内存，释放不再使用的对象所占用的内存空间**。具体实现如下：

**一、核心机制**

1. **标记清除（Mark-Sweep）**
   - **标记阶段**：从根对象（全局变量、活动函数作用域链）出发，递归标记所有可达对象为“活动对象”。
   - **清除阶段**：遍历堆内存，回收未被标记的不可达对象。
   - **优势**：解决循环引用问题（现代浏览器主要算法）。
2. **引用计数（Reference Counting）**
   - **原理**：记录每个对象被引用的次数，当引用数为 0 时立即回收。
   - **缺陷**：无法处理循环引用（如两个对象互相引用），已逐渐被淘汰。

**二、内存泄漏常见场景**

1. **未释放的闭包**：函数内部变量被外部引用，导致外部函数作用域无法回收。

   ```javascript
   function createLeak() {
     const data = new Array(1e6); // 大对象
     return () => console.log(data); // 闭包保留 data 的引用
   }
   const leak = createLeak(); // data 无法被回收
   ```

2. **未清理的 DOM 引用**：移除 DOM 元素后，未清除其 JS 变量引用。

   ```javascript
   const button = document.getElementById('btn');
   document.body.removeChild(button); // DOM 被移除
   // button 变量仍引用该 DOM 对象 → 内存泄漏
   ```

3. **未清除的定时器/事件监听**：

   ```javascript
   const timer = setInterval(() => {}, 1000);
   // 忘记 clearInterval(timer) → 定时器持续占用内存
   ```

**三、优化实践**

1. **手动解除引用**：不再使用的对象设为 `null`（如 `data = null`）。
2. **弱引用**：使用 `WeakMap`/`WeakSet`（键为弱引用，不影响垃圾回收）。
3. **避免内存膨胀**：分页加载大数据集，及时销毁无用缓存。

**总结**：理解垃圾回收机制可有效预防内存泄漏，关键是通过作用域管理和资源清理，确保对象及时变为“不可达”状态。

## 浏览器有哪几种缓存，各种缓存的优先级是什么样的？

浏览器缓存的核心是**通过多级缓存策略减少网络请求，提升加载速度**。优先级由高到低依次为：

**一、缓存类型与优先级**

1. **Service Worker 缓存**（最高优先级）
   - **特点**：可编程控制缓存策略，支持离线访问。
   - **场景**：PWA 应用、自定义缓存逻辑（如优先返回缓存，失败再请求网络）。
2. **Memory Cache（内存缓存）**
   - **特点**：浏览器内存缓存，快速读取但随进程关闭释放。
   - **场景**：页面刷新时，相同资源（如 Base64 图片）直接从内存加载。
3. **Disk Cache（磁盘缓存）**
   - **特点**：持久化缓存，容量大但读取速度较慢。
   - **子类**：
     - **强缓存**（`Cache-Control` / `Expires`）：直接使用本地缓存，不发送请求。
     - **协商缓存**（`Last-Modified` / `ETag`）：发送请求验证，返回 `304` 复用缓存。
4. **Push Cache（推送缓存）**（最低优先级）
   - **特点**：HTTP/2 服务器推送的临时缓存，会话结束即失效。
   - **场景**：多页面共享资源（如同一 CDN 的字体文件）。

**二、缓存匹配流程**

1. **请求资源时**：
   - **Service Worker** → **Memory Cache** → **Disk Cache（强缓存优先）** → **Push Cache** → **网络请求（协商缓存）**。
2. **示例**：
   - 若资源在 Service Worker 中命中，直接返回，不再检查其他缓存。
   - 若强缓存（如 `Cache-Control: max-age=3600`）有效，跳过网络请求。

**三、用户行为对缓存的影响**

- **正常刷新**：跳过强缓存，触发协商缓存（可能返回 `304`）。
- **强制刷新（Ctrl+F5）**：忽略所有缓存，直接请求最新资源。
- **关闭标签页**：Memory Cache 失效，Disk Cache 保留。

**总结**：Service Worker 优先级最高，其次是内存和磁盘缓存，最后是 HTTP/2 推送缓存。合理配置 `Cache-Control` 和 `ETag` 可显著优化性能。

## 什么是浏览器的同源策略，以及跨域？

[跨域的处理方案有哪些？](#cross-origin)

## 请解释一下浏览器引擎的工作原理是什么？

浏览器引擎的核心工作原理是**将网页代码（HTML/CSS/JS）转换为可视化页面和可交互程序**，主要通过渲染引擎与 JavaScript 引擎协作完成。以下是具体流程：

**一、核心模块分工**

1. **渲染引擎（如 Blink/WebKit）**
   - **HTML 解析**：将 HTML 转换为 DOM 树（Document Object Model）。
   - **CSS 解析**：将 CSS 转换为 CSSOM 树（CSS Object Model）。
   - **渲染树构建**：合并 DOM 和 CSSOM 生成 Render Tree（仅包含可见元素）。
   - **布局（Layout）**：计算每个节点的几何位置（重排）。
   - **绘制（Painting）**：将布局结果栅格化为像素（重绘）。
   - **合成（Compositing）**：分层绘制，GPU 加速合成最终画面。
2. **JavaScript 引擎（如 V8/SpiderMonkey）**
   - **解析（Parsing）**：将 JS 代码转换为抽象语法树（AST）。
   - **编译（Compilation）**：即时编译（JIT）为机器码。
   - **执行（Execution）**：在调用栈中运行代码，通过事件循环处理异步任务。

**二、关键协作流程**

1. **阻塞与并行**
   - **HTML 解析**：遇到 `<script>` 默认阻塞 DOM 构建（除非标记 `async/defer`）。
   - **CSS 加载**：阻塞渲染树合成（但 DOM 解析可继续）。
2. **关键渲染路径优化**
   - **优化目标**：最小化首次渲染时间（First Meaningful Paint）。
   - **优化手段**：
     - 内联关键 CSS/JS
     - 预加载关键资源（`<link rel="preload">`）
     - 延迟非必要脚本（`async/defer`）
3. **交互响应机制**
   - **事件循环（Event Loop）**：通过任务队列（宏任务/微任务）调度 JS 执行与渲染更新。
   - **帧率同步**：`requestAnimationFrame` 确保动画与浏览器刷新率同步（通常 60fps）。

**三、现代引擎优化特性**

1. **渐进式渲染**：流式解析 HTML，逐步显示内容（如 Chrome 的预渲染扫描器）。
2. **GPU 加速**：通过分层合成（Composite Layers）和光栅化线程减少主线程负载。
3. **推测执行**：预加载可能需要的资源（如 Chrome 的预加载器预测后续请求）。

**四、示例引擎架构**

- **Chromium（Blink + V8）**：
  - 多进程架构（渲染进程、GPU 进程、浏览器主进程）
  - 支持 WebAssembly、WebGPU 等新标准
- **Firefox（Gecko + SpiderMonkey）**：
  - 增量垃圾回收
  - 更严格的隐私保护策略

**总结**：浏览器引擎通过多阶段流水线将代码转化为交互式页面，其性能直接影响用户体验，理解原理有助于针对性优化网页性能。

## V8引擎是什么，它是如何提高JavaScript执行性能的？

V8 引擎是 **Google 开发的高性能 JavaScript 引擎**，核心目标是**通过即时编译（JIT）和内存优化，让 JavaScript 执行速度接近原生代码**。以下是其核心优化手段：

**一、关键性能优化技术**

1. **即时编译（JIT）**

   - **基线编译器（Ignition）**：快速生成未优化的字节码，支持快速启动。
   - **优化编译器（TurboFan）**：根据代码运行时的类型反馈（Type Feedback）生成高度优化的机器码。
   - **去优化（Deoptimization）**：当假设失效（如变量类型突变）时，回退到字节码重新优化。

2. **隐藏类（Hidden Class）与内联缓存（Inline Cache）**

   - **隐藏类**：为动态对象的结构分配固定内存布局，减少属性访问耗时（类似静态语言的类结构）。

     ```javascript
     // 对象 a 和 b 共享同一隐藏类（结构相同）
     const a = { x: 1, y: 2 };
     const b = { x: 3, y: 4 };
     ```

   - **内联缓存**：缓存对象属性的内存偏移量，加速后续访问（如 `obj.x` 直接通过缓存定位）。

3. **高效垃圾回收（GC）**

   - **分代式回收**：
     - **新生代（Scavenge）**：使用复制算法快速回收短期对象（如函数局部变量）。
     - **老生代（Mark-Sweep/Compact）**：标记-清除/整理算法处理长期存活对象（如全局变量）。
   - **增量标记与并行回收**：减少主线程阻塞时间，避免页面卡顿。

4. **热点代码优化**

   - **函数内联（Inlining）**：将小函数直接嵌入调用处，减少调用开销。
   - **逃逸分析**：识别未逃逸对象，直接在栈上分配内存（避免堆内存分配）。

**二、其他优化特性**

1. **WebAssembly 支持**
   - 直接编译 C/C++/Rust 等语言到机器码，突破 JavaScript 性能瓶颈（如游戏、音视频处理）。
2. **并发解析与编译**
   - 在后台线程预解析代码，减少主线程编译耗时（如流式解析大型脚本）。
3. **内存压缩指针（Pointer Compression）**
   - 将 64 位指针压缩为 32 位，减少内存占用（适用于堆内存小于 4GB 的场景）。

**三、性能对比**

- **解释执行（如早期 JS 引擎）**：逐行翻译代码，速度慢。
- **V8 JIT 优化**：通过动态编译，性能提升 **10~100 倍**，接近 C++ 水平。

**示例**：

```javascript
// 循环优化前（未编译）
for (let i = 0; i < 1e6; i++) { ... }

// TurboFan 优化后生成机器码，循环速度接近原生代码
```



**总结**：V8 通过 JIT 编译、隐藏类、分代 GC 等设计，将 JavaScript 从解释型语言提升到接近编译型语言的性能，支撑了现代 Web 应用和高性能 Node.js 服务。

## 浏览器一帧都会干些什么？

- 接受输入事件
- 执行事件回调
- 开始一帧
- 执行 RAF (RequestAnimationFrame)
- 页面布局，样式计算
- 绘制渲染
- 执行 RIC (RequestIdelCallback)

第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。
