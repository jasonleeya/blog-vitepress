---
category: 架构
order: 12
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 架构


## 你是怎么理解前端架构的？

前端架构是指在前端开发中，设计和构建应用的整体结构和策略。这包括代码组织、工具选择、性能优化、团队协作等多个方面。良好的前端架构有助于提高开发效率、确保代码质量、优化用户体验。

以下与前端架构相关的一些要点：

**1. 代码组织**

- **模块化**：将代码拆分成独立的模块或组件，提高可维护性和可重用性。采用前端框架（如 React、Vue、Angular）通常会自然支持组件化。
- **目录结构**：设计合理的目录结构，以便于代码管理和团队协作。常见的结构包括按功能划分（如 `components/`、`services/`、`views/`）、按类型划分等。

**2. 构建工具和流程**

- **构建工具**：使用工具如 Webpack、Vite、Rollup 来打包、编译和优化前端资源。这些工具支持模块打包、代码分割、热重载等功能。
- **自动化**：配置自动化流程（CI/CD），包括构建、测试、部署等，确保代码的持续集成和交付。

**3. 性能优化**

- **加载性能**：优化资源的加载时间，例如通过代码分割、懒加载、图片压缩等技术。
- **运行性能**：优化页面的响应速度和渲染性能，减少 JavaScript 执行时间、优化渲染流程等。
- **缓存策略**：使用合适的缓存策略，如 HTTP 缓存、Service Worker 缓存等，提升应用的离线体验和响应速度。

**4. 状态管理**

- **状态管理库**：在复杂的应用中，使用状态管理库（如 Redux、Vuex、MobX）来集中管理应用的状态，确保状态一致性。
- **本地状态和全局状态**：合理划分本地状态（组件内部状态）和全局状态（应用级别状态），根据需要选择合适的管理方式。

**5. 路由管理**

- **客户端路由**：使用路由库（如 React Router、Vue Router）来管理应用的导航和路由。
- **路由设计**：设计合理的路由结构，确保用户体验流畅且符合应用需求。

**6. 安全**

- **前端安全**：防范常见的安全问题，如跨站脚本攻击（XSS）、跨站请求伪造（CSRF）。使用工具和最佳实践来保护应用安全。
- **数据保护**：确保敏感数据在传输和存储过程中得到适当的保护。

**7. 测试**

- **单元测试**：对单个组件或功能进行测试，确保它们的正确性。使用测试框架如 Jest、Mocha。
- **集成测试**：测试组件之间的交互和集成，验证系统的整体功能。
- **端到端测试**：模拟用户行为，测试整个应用的功能和性能。使用工具如 Cypress、Selenium。

**8. 用户体验**

- **响应式设计**：确保应用在不同设备和屏幕尺寸上都能良好显示。
- **可访问性**：关注应用的可访问性，确保所有用户，包括有特殊需求的用户，都能顺利使用应用。

**9. 团队协作**

- **代码审查**：实施代码审查流程，保证代码质量和团队协作。
- **文档**：编写和维护项目文档，帮助团队成员了解项目结构、规范和最佳实践。

## 你参与过哪些前端基建方面的建设？

**1. 项目架构**

- **目录结构**：定义项目文件和目录的组织结构，确保项目的可维护性和可扩展性。
- **代码规范**：统一代码风格和规范，使用 ESLint、Prettier 等工具进行代码检查和格式化。
- **模块化**：采用模块化设计，将代码拆分为独立的模块，提高可重用性和可维护性。
- **脚手架**：自动生成项目的基础结构，包括目录结构、配置文件、示例代码等。

 **2. 构建工具和配置**

- **构建工具**：使用工具如 Webpack、Vite、Rollup 等进行项目的构建和打包。
- **配置管理**：配置构建工具以支持各种功能，如代码分割、热重载、环境变量等。
- **优化**：配置代码压缩、缓存策略、Tree Shaking 等，提升构建产物的性能和效率。

 **3. 开发环境**

- **开发服务器**：设置本地开发服务器，支持热重载和调试功能。
- **环境配置**：管理开发、测试、生产环境的配置和变量。

 **4. 包管理**

- **依赖管理**：使用 npm、Yarn 或 pnpm 等工具管理项目依赖，确保依赖版本一致性。
- **发布管理**：管理和发布自定义的 npm 包或组件库。

 **5. 自动化流程**

- **CI/CD**：配置持续集成（CI）和持续部署（CD）流程，自动化构建、测试和部署。
- **测试**：集成单元测试、集成测试和端到端测试工具，如 Jest、Cypress 等，确保代码质量。

**6. 代码质量**

- **静态分析**：使用 ESLint、TSLint 等工具进行代码静态检查。
- **测试覆盖率**：监控测试覆盖率，确保关键代码路径被充分测试。

 **7. 文档**

- **代码文档**：编写和维护项目文档，包括 API 文档、开发指南和使用说明。
- **自动化文档生成**：使用工具如 Storybook、JSDoc 等生成组件库和 API 文档。

 **8. 组件库**

- **设计系统**：构建和维护一套一致的设计系统和组件库，提高开发效率和界面一致性。
- **共享组件**：创建和管理共享组件，促进代码复用。

 **9. 性能优化**

- **前端性能**：优化页面加载速度、响应时间和渲染性能。
- **网络请求**：管理和优化网络请求策略，减少请求次数和数据传输量。

 **10. 安全**

- **安全最佳实践**：遵循前端安全最佳实践，如防范 XSS 和 CSRF 攻击。
- **敏感数据保护**：确保敏感数据不被暴露或滥用。

## 怎样做技术选型？在项目中做过哪些关键技术决策？

技术选型的核心是**基于项目需求、团队能力与长期维护成本，选择最合适的技术方案**。具体步骤和案例如下：

**一、技术选型方法论**

1. **明确需求**
   - 分析业务场景（如高并发、SEO 需求）、产品目标（MVP 快速迭代 or 长期维护）。
   - 示例：电商项目需 SEO → 选择 SSR 框架（Next.js/Nuxt.js）。
2. **技术评估**
   - **性能**：对比框架体积、渲染速度（如 React vs Vue 的虚拟 DOM 差异）。
   - **生态**：社区活跃度、三方库支持（如 React 生态更丰富）。
   - **可维护性**：TypeScript 支持、代码规范工具链。
3. **团队适配**
   - 选择团队熟悉的技术栈（如从 jQuery 迁移到 Vue，而非直接上 React）。
   - 评估学习成本（如引入 Rust 写 Wasm 需权衡收益与上手难度）。
4. **长期维护**
   - 技术前瞻性：避免选择过时技术（如放弃 AngularJS 改用 Vue3）。
   - 供应商锁定风险：优先开源方案，避免过度依赖特定云服务。

**二、关键技术决策案例**

1. **框架选择**
   - **场景**：中后台管理系统，需快速迭代。
   - **决策**：选用 React + Ant Design（生态成熟，团队熟悉），而非 Vue + Element（虽更轻量但团队经验不足）。
2. **状态管理**
   - **场景**：复杂表单与跨组件通信。
   - **决策**：Redux Toolkit（标准化状态管理）替代 Context API（避免冗余渲染）。
3. **构建工具**
   - **场景**：项目冷启动慢，HMR 延迟高。
   - **决策**：迁移 Webpack 到 Vite（开发构建速度提升 70%）。
4. **性能优化**
   - **场景**：首屏加载超时。
   - **决策**：
     - 静态资源上 CDN + 开启 HTTP/2。
     - 路由懒加载 + 分包策略（主包体积减少 40%）。
5. **跨端方案**
   - **场景**：需同时支持 H5 与小程序。
   - **决策**：Taro 3（React 语法写多端）替代原生开发（减少重复工作量）。

**三、避坑经验**

- **避免过度设计**：MVP 阶段用 KISS 原则（如直接用 CSS 而非 CSS-in-JS）。
- **渐进式升级**：旧项目迁移用微前端（qiankun）隔离技术栈，逐步替换。
- **数据驱动决策**：通过 A/B 测试验证技术方案效果（如 SSR 对 SEO 的实际提升）。

**总结**：技术选型需平衡短期效率与长期维护，关键决策应紧密围绕业务价值，而非盲目追求新技术。

## 前端基建涉及到哪些方面？

[前端基建设计到哪些方面](https://github.com/pro-collection/interview-question/issues/543)

## 业务需要实现前端项目的灰度发布，你会怎么设计？

前端灰度发布的核心设计是**通过用户分流策略和版本动态加载，控制新功能逐步覆盖特定用户群体**。具体方案如下：

**一、分流策略设计**

1. **用户标识与规则**

   - **标识方式**：Cookie（如 `version=new`）、URL参数（`?version=new`）、用户ID哈希、请求头（后端传递灰度标记）。
   - **分流规则**：
     - **按比例**：10% 流量导向新版本。
     - **按条件**：白名单用户（内部员工）、特定设备（iOS）、地域（国内用户）。

2. **动态加载版本**

   - **入口文件分流**：通过 Nginx 或 CDN 边缘计算（如 Cloudflare Workers）根据规则返回不同版本的 HTML 入口。

     ```
     # Nginx 配置示例：按 Cookie 分流
     location / {
         if ($http_cookie ~* "version=new") {
             proxy_pass http://new_version_server;
         }
         proxy_pass http://old_version_server;
     }
     ```

   - **前端运行时分流**：主应用加载后，通过接口获取用户灰度标识，动态加载新版本代码（如 Webpack 动态导入）。

     ```
     // 前端代码示例
     fetchUserGrayStatus().then(({ isGray }) => {
       if (isGray) {
         import('newFeature.js').then(module => module.init());
       }
     });
     ```

**二、版本管理与部署**

1. **多版本共存**
   - **静态资源隔离**：新旧版本代码部署到不同目录（如 `/v1.2.3/`、`/v2.0.0/`），通过文件名哈希避免缓存冲突。
   - **API 兼容性**：确保后端接口兼容新旧版本，或通过版本号路由（如 `/api/v2/getData`）。
2. **快速回滚机制**
   - **版本标记回退**：在灰度平台手动关闭新版本流量，Nginx/CDN 自动切换回旧版本入口。
   - **构建物回滚**：保留旧版本镜像或静态资源，通过 CI/CD 工具（如 Jenkins）快速重新部署。

**三、监控与效果验证**

1. **监控指标**
   - **稳定性**：错误率（接入 Sentry）、接口成功率、页面白屏率。
   - **性能**：首屏时间（LCP）、JS 加载耗时。
   - **业务指标**：转化率、功能使用率（通过埋点上报）。
2. **渐进式放量**
   - **分阶段扩大**：10% → 50% → 100% 流量，每阶段观察 1-2 天。
   - **自动熔断**：若错误率超过阈值（如 5%），自动回滚至旧版本。

**四、实现方案示例**

1. **简单方案（适合小团队）**
   - 使用 Nginx 根据 IP 哈希分流，静态资源部署到不同路径。
   - 前端通过 `localStorage` 记录用户版本，手动开关灰度。
2. **平台化方案（中大型项目）**
   - **灰度控制台**：集成到内部运维平台，支持可视化配置规则、实时流量监控。
   - **结合微前端**：通过 qiankun 动态加载新旧子应用，实现无损切换。

**总结**：灰度发布需平衡风险与效率，关键点在于灵活的分流策略、版本隔离、实时监控与快速回滚能力。

## 如何在前端团队快速落地代码规范?

在前端团队中快速落地代码规范可以显著提升代码质量和团队效率。以下是一些步骤和建议，帮助你在团队中有效地实施代码规范：

**1. 确定规范**

1. **选择标准化的规范**：
   - 选择广泛认可的代码规范，如 Airbnb、Google 或 Standard 的 JavaScript 风格指南。
   - 可以根据项目需求和团队情况自定义规则。
2. **定义团队规范**：
   - 根据选择的标准，定义团队特有的规则，例如缩进风格、变量命名规则、代码组织方式等。

**2. 工具配置**

1. **使用代码格式化工具**：
   - **Prettier**：自动格式化代码，确保一致的代码风格。
   - 配置 `.prettierrc` 文件以定义格式化规则。
2. **使用静态代码分析工具**：
   - **ESLint**：检测和修复 JavaScript 和 TypeScript 代码中的潜在问题。
   - 配置 `.eslintrc` 文件以定义 linting 规则。
   - 可以与 Prettier 集成，确保格式和规范一致。
3. **设置版本控制钩子**：
   - 使用工具如 **Husky** 和 **Lint-staged**，在每次提交代码之前自动运行格式化和 lint 检查。
   - 配置 `pre-commit` 钩子以确保提交的代码符合规范。

**3. 培训与文档**

1. **培训团队成员**：
   - 组织代码规范培训，确保每个团队成员理解和掌握规范。
   - 分享学习资源和示例代码，帮助团队成员快速适应。
2. **编写规范文档**：
   - 创建并维护代码规范文档，详细描述团队的代码风格和最佳实践。
   - 将文档放在团队可以轻松访问的地方，如项目 Wiki 或共享文档库。

**4. 实施与反馈**

1. **实施阶段**：
   - 在新代码中实施规范，并逐步引入到现有代码库。
   - 确保所有团队成员在编写新代码时遵循规范。
2. **定期审查与反馈**：
   - 定期进行代码审查，确保代码规范得到了遵守。
   - 鼓励团队成员提供反馈，调整规范以适应实际工作中的问题。
3. **工具集成**：
   - 将规范工具集成到 CI/CD 流程中，自动检测代码规范是否符合标准。

**5. 自动化与维护**

1. **自动化测试**：
   - 将格式化和 lint 检查集成到构建和测试流程中，确保每次构建都符合规范。
2. **持续更新**：
   - 定期更新规范工具和规则，以适应新的技术和最佳实践。
   - 维护文档和培训资料，确保它们与当前的代码规范保持一致。

## 如果公司要做一个低代码平台，你会怎么进行架构设计？

设计一个低代码平台的架构需要综合考虑灵活性、可扩展性、性能、安全性等因素，旨在帮助用户通过拖拽、可视化界面配置等方式快速构建应用，同时又具备高度的可扩展性和稳定性。

以下是一些思路：

1. **总体架构思路**

一个低代码平台可以划分为以下几个主要模块：

- **前端界面层**：提供用户交互的可视化界面，支持组件拖拽、属性配置、数据绑定等操作。
- **中台服务层**：负责处理数据流、权限、业务逻辑等，提供 API 和服务支持。
- **后端支撑层**：处理数据存储、流程引擎、权限控制、扩展机制等。
- **扩展模块**：为高级用户提供插件、扩展和自定义代码的能力。

2. **前端架构**

前端是用户使用低代码平台的核心，主要任务是提供拖拽式可视化界面和动态配置能力。

2.1. **基于组件化的设计**

低代码平台中的 UI 组件是核心，用户通过拖拽组件来搭建应用，因此前端架构要高度组件化。

- **组件库**：基础组件库，包括表单组件、布局组件、按钮、图表等。每个组件都有配置项、事件、样式等属性。
- **拖拽引擎**：负责管理组件的拖拽、位置调整和动态添加。可以基于 `react-dnd`、`Vue Drag-and-Drop` 等库实现。
- **属性面板**：展示当前组件的可配置属性（如样式、数据源等），并提供动态配置的能力。
- **事件机制**：为组件设置事件处理程序，支持点击、提交等行为，并与后端 API 交互。

2.2. **动态渲染与预览**

用户在可视化搭建应用时，可以实时预览效果，因此需要实现动态渲染引擎：

- **页面配置化渲染**：将用户搭建的页面结构和组件配置转化为 JSON，使用配置化的方式渲染页面。
- **实时预览**：用户在编辑器中所见即所得，支持实时预览和切换不同设备视图（如移动端、桌面端）。

2.3. **插件系统**

平台需提供灵活的插件机制，允许开发者扩展组件库或功能模块。比如：导入第三方组件库、扩展事件处理器等。

3. **中台服务架构**

中台负责连接前端的配置和业务逻辑，提供处理应用逻辑的能力，包括数据处理、权限管理、业务流程等。

3.1. **API 网关**

中台可以基于 API 网关进行架构设计，处理所有的 API 请求，并提供统一的鉴权、日志和监控功能。

3.2. **流程引擎**

低代码平台需要支持工作流或流程设计，用户可以通过拖拽节点创建业务流程：

- **流程节点**：包括条件节点、操作节点（如调用 API、写入数据库）、事件节点等。
- **流程引擎**：控制流程的执行顺序、条件判断，类似于 BPM（业务流程管理）。

3.3. **数据集成与管理**

平台需提供数据集成功能，允许用户通过拖拽或配置连接外部数据源：

- **数据源连接**：支持 REST API、GraphQL、数据库等多种数据源类型。
- **数据绑定**：前端组件需要通过可视化方式绑定数据源，例如通过下拉选择绑定 API 返回的数据。

3.4. **权限管理**

中台负责提供权限控制，确保不同用户可以访问不同的数据和功能。

- **角色权限**：基于角色进行权限控制，用户根据权限可以操作不同的页面、数据和功能。
- **数据权限**：对于敏感数据，平台需提供细粒度的数据权限控制。

4. **后端支撑**

后端负责平台的稳定运行、数据存储、权限控制等。

4.1. **数据存储**

选择合适的数据存储方案，根据业务需求使用多种数据库：

- **关系型数据库**：存储应用配置、用户信息等结构化数据。
- **非关系型数据库**：例如 MongoDB，适合存储页面 JSON 配置、用户行为记录等非结构化数据。

4.2. **缓存系统**

为了加快页面的加载速度和减少数据库的压力，可以使用缓存系统（如 Redis）存储高频访问的数据和配置。

4.3. **微服务架构**

后端架构可以采用微服务拆分的方式，将不同的功能模块（如用户管理、日志监控、权限控制等）独立成微服务，方便后续扩展和维护。

5. **扩展与定制化**

为了满足不同用户的需求，平台需提供扩展能力：

- **自定义组件**：用户可以开发自己的组件，上传到平台并进行使用。
- **脚本扩展**：支持用户编写自定义脚本，实现更复杂的交互和逻辑控制。
- **模板机制**：允许用户保存配置好的应用为模板，供其他人复用。

6. **安全性设计**

平台的安全性是重点考虑的方面，需要从以下几个层面保障系统的安全：

- **身份认证与授权**：采用 OAuth 或 JWT 等认证机制，确保每个用户都经过身份验证。
- **数据加密**：对于用户数据，需采用传输层和存储层加密的方式保护敏感信息。
- **操作日志**：记录用户的操作行为，方便问题追溯和监控。

7. **性能优化**

低代码平台要处理大量的配置化数据，性能优化显得尤为重要：

- **按需加载**：对于组件库和插件系统，支持按需加载，避免一次性加载所有组件。
- **数据缓存**：通过缓存机制，避免重复的请求和数据处理。
- **静态资源优化**：前端通过 Webpack、Vite 等工具优化静态资源加载，减少打包体积，提高页面加载速度。

8. **CI/CD 和运维部署**

低代码平台的持续集成与交付（CI/CD）是确保开发和部署高效进行的基础：

- **自动化测试**：确保平台的稳定性，进行单元测试、集成测试。
- **自动化部署**：通过 Kubernetes 或 Docker 实现自动化部署，支持横向扩展和多环境部署。
