---
category: 场景题
order: 7
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 场景题


## 如何实现轮播图？

**轮播图实现的核心方案**：

1. **纯CSS实现（简单轮播）**
   - 使用 `CSS动画` + `@keyframes` 控制自动轮播，通过 `:hover` 暂停动画，适合静态展示。
2. **原生JS + CSS过渡**
   - **布局**：Flex/Grid横向排列图片，外层容器 `overflow: hidden`。
   - **滑动逻辑**：监听点击事件，通过 `transform: translateX` 切换位置，结合 `transition` 实现平滑动画。
   - **无限循环**：首尾添加克隆元素，切换时瞬间重置位置。
3. **第三方库（快速开发）**
   - 使用 **Swiper.js** 或 **Slick**，提供丰富API（分页器、懒加载、触摸滑动），适用于复杂交互需求。
4. **关键细节优化**
   - **自动播放**：`setInterval` 定时触发切换，离开页面时用 `visibilitychange` 暂停。
   - **响应式**：监听 `resize` 事件动态调整容器尺寸。
   - **指示器与导航**：动态生成分页点，绑定点击跳转逻辑。

## 如何实现前端水印功能？如何禁止别人移除？

**1. 水印实现方式**

- **Canvas 绘制**
  动态生成带水印的 Base64 图片，设为页面背景：

  ```javascript
  const createWatermark = (text) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = '16px Arial';
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.rotate(-20 * Math.PI / 180);
    ctx.fillText(text, 10, 70);
    return canvas.toDataURL('image/png');
  };
  document.body.style.backgroundImage = `url(${createWatermark('Confidential')})`;
  ```

- **CSS 伪元素覆盖**
  通过绝对定位覆盖全屏，防止遮挡交互：

  ```
  .watermark {
    position: fixed;
    pointer-events: none; /* 禁止交互 */
    z-index: 9999;
    opacity: 0.1;
    background: repeating-linear-gradient(-45deg, #000 0 20px, transparent 20px 40px);
  }
  ```

**2. 防移除关键策略**

- **DOM 监控**
  使用 `MutationObserver` 监听水印节点变化，被删时重新插入：

  ```javascript
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (!document.getElementById('watermark')) {
        document.body.appendChild(createWatermarkElement());
      }
    });
  });
  observer.observe(document.body, { childList: true });
  ```

- **加密混淆**
  动态生成水印元素，避免固定 ID 或 Class 被针对性删除：

  ```javascript
  const randomAttr = `data-${Math.random().toString(36).slice(2)}`;
  watermarkElement.setAttribute(randomAttr, '');
  ```

- **服务端配合**
  关键内容（如图片/PDF）由服务端预加水印，避免纯前端依赖。

## 站点一键换肤的实现方式有哪些？

**前端一键换肤的核心实现方案**：

1. **CSS变量（推荐）**
   定义主题色变量，通过切换 `data-theme` 属性动态修改：

   ```css
   :root {
     --primary-color: #2196f3;
   }
   [data-theme="dark"] {
     --primary-color: #333;
   }
   ```

   ```javascript
   document.documentElement.setAttribute('data-theme', 'dark');
   ```

2. **Sass/Less预处理变量**
   编译多套主题CSS文件，动态切换 `<link>` 的 `href`（需提前加载）。

3. **类名切换**
   为不同主题定义独立类名，通过 JS 切换根元素的类：

   ```css
   .theme-dark { background: #000; color: #fff; }
   ```

4. **CSS-in-JS动态注入**
   使用 styled-components 等库，结合状态管理动态生成样式。

5. **CSS滤镜（简单场景）**
   通过 `filter: invert(1)` 快速反色，但色彩控制粗糙。

**优化细节**：

- **持久化**：用 `localStorage` 存储用户选择，初始化时读取。
- **平滑过渡**：为颜色属性添加 `transition` 动画。
- **按需加载**：异步加载非核心主题样式，减少首屏体积。

## 实现一个图片懒加载组件

**实现图片懒加载组件的核心步骤**：

1. **HTML 结构准备**
   将真实图片地址存入 `data-src`，初始 `src` 使用占位图或留空：

   ```html
   <img class="lazyload" data-src="real-image.jpg" src="placeholder.png">
   ```

2. **Intersection Observer 检测可视区域**
   监听图片是否进入视口，触发加载

   ```javascript
   const observer = new IntersectionObserver((entries) => {
     entries.forEach(entry => {
       if (entry.isIntersecting) {
         const img = entry.target;
         img.src = img.dataset.src;
         img.classList.add('loaded');
         observer.unobserve(img); // 加载后停止观察
       }
     });
   }, { rootMargin: '0px 0px 200px 0px' }); // 提前200px加载
   
   document.querySelectorAll('.lazyload').forEach(img => observer.observe(img));
   ```

3. **滚动兼容方案（备用）**
   不支持 `IntersectionObserver` 时降级为滚动监听 + 节流：

   ```javascript
   const throttleCheck = () => {
     document.querySelectorAll('.lazyload').forEach(img => {
       const rect = img.getBoundingClientRect();
       if (rect.top < window.innerHeight + 200) {
         img.src = img.dataset.src;
       }
     });
   };
   window.addEventListener('scroll', throttle(throttleCheck, 200));
   ```

4. **加载效果优化**
   CSS 添加过渡动画：

   ```css
   .lazyload {
     opacity: 0;
     transition: opacity 0.3s;
   }
   .lazyload.loaded {
     opacity: 1;
   }
   ```

5. **封装为可复用组件（Vue 示例）**

   ```vue
   <template>
     <img :data-src="src" class="lazyload" :src="placeholder">
   </template>
   
   <script>
   export default {
     props: ['src', 'placeholder'],
     mounted() {
       this.initLazyLoad();
     },
     methods: {
       initLazyLoad() {
         const observer = new IntersectionObserver((entries) => {
           entries.forEach(entry => {
             if (entry.isIntersecting) {
               entry.target.src = entry.target.dataset.src;
               observer.unobserve(entry.target);
             }
           });
         });
         observer.observe(this.$el);
       }
     }
   }
   </script>
   ```

**优化要点**：

- **性能**：优先使用 `IntersectionObserver`，滚动监听需加节流
- **兼容性**：引入 `polyfill` 或降级方案
- **体验**：提前加载、加载动画、错误处理（`onerror` 事件）

## 如何实现元素的拖拽功能？

1. **事件监听**
   - **`mousedown`**：在目标元素上监听，记录初始鼠标位置和元素当前位置。
   - **`mousemove`**：在文档（`document`）上监听，计算偏移量并实时更新元素位置（如修改 `left/top` 或 `transform`）。
   - **`mouseup`**：在文档上监听，移除 `mousemove` 和 `mouseup` 事件，结束拖拽。
2. **位置计算**
   - 通过 `clientX/clientY` 获取鼠标坐标，结合元素初始位置计算偏移量。
   - 更新元素样式时优先使用 `transform: translate()` 以提升性能。
3. **交互优化**
   - **防止文本选中**：在 `mousedown` 事件中设置 `user-select: none` 或调用 `event.preventDefault()`。
   - **光标反馈**：动态切换 `cursor` 样式（如 `grab` 和 `grabbing`）。

## 如何实现一个拖拽排序列表

**实现拖拽排序列表的核心步骤**：

1. **HTML 结构**
   为列表项添加 `draggable="true"` 属性，禁用默认拖拽图像：

   ```html
   <ul class="sortable-list">
     <li draggable="true" data-id="1">Item 1</li>
     <li draggable="true" data-id="2">Item 2</li>
   </ul>
   ```

2. **事件监听**
   绑定关键事件：

   ```javascript
   let draggedItem = null;
   
   items.forEach(item => {
     item.addEventListener('dragstart', handleDragStart);
     item.addEventListener('dragover', handleDragOver);
     item.addEventListener('dragend', handleDragEnd);
   });
   ```

3. **拖拽逻辑**

   - **记录拖拽元素**：

     ```javascript
     function handleDragStart(e) {
       draggedItem = e.target;
       e.dataTransfer.effectAllowed = 'move';
       e.target.classList.add('dragging');
     }
     ```

   - **计算插入位置**：

     ```javascript
     function handleDragOver(e) {
       e.preventDefault();
       const afterElement = getDragAfterElement(e.clientY); // 根据坐标计算插入点
       const list = document.querySelector('.sortable-list');
       if (afterElement) {
         list.insertBefore(draggedItem, afterElement);
       } else {
         list.appendChild(draggedItem);
       }
     }
     ```

4. **视觉优化**

   - 添加拖拽占位符和过渡动画：

     ```javascript
     .dragging {
       opacity: 0.5;
       background: #f0f0f0;
     }
     ```

5. **框架优化（如 Vue/React）**
   结合状态管理更新数据源：

   ```VUE
   <template>
     <ul @dragover.prevent="handleDragOver">
       <li v-for="item in list" 
           draggable 
           @dragstart="handleDragStart(item.id)"
           @dragend="handleDragEnd">
         {{ item.text }}
       </li>
     </ul>
   </template>
   
   <script>
   export default {
     methods: {
       handleDragStart(id) {
         this.draggedId = id;
       },
       handleDragOver(e) {
         const newList = [...this.list];
         const from = this.list.findIndex(item => item.id === this.draggedId);
         const to = this.calculateNewPosition(e); // 计算新位置
         newList.splice(to, 0, newList.splice(from, 1)[0]);
         this.list = newList;
       }
     }
   }
   </script>
   ```

**备选方案**：

- **第三方库**：直接使用 Sortable.js 或 react-beautiful-dnd（React 生态）快速实现。
- **移动端适配**：结合 `touchstart`/`touchmove` 事件实现触摸拖拽。

## 如何实现前端文件分片上传与断点续传

**1. 分片上传实现**

- **文件分片**
  使用 `Blob.slice()` 切割文件为固定大小（如 5MB/片）：

  ```javascript
  const chunkSize = 5 * 1024 * 1024; // 5MB
  const chunks = [];
  let start = 0;
  while (start < file.size) {
    chunks.push(file.slice(start, start + chunkSize));
    start += chunkSize;
  }
  ```

- **唯一标识**
  计算文件哈希值（如 `SparkMD5`），作为分片标识：

  ```javascript
  const fileHash = await calculateHash(file); // Web Worker中计算
  ```

- **并发上传**
  通过 `Promise.all` 控制并发请求数（如并发3片）：

  ```javascript
  const uploadChunk = (chunk, index) => {
    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('hash', `${fileHash}-${index}`);
    return axios.post('/upload', formData);
  };
  
  // 控制并发
  const maxConcurrent = 3;
  for (let i = 0; i < chunks.length; i += maxConcurrent) {
    await Promise.all(chunks.slice(i, i + maxConcurrent).map(uploadChunk));
  }
  ```

**2. 断点续传实现**

- **服务端记录已传分片**
  上传前调用接口检查已上传的分片索引：

  ```javascript
  const { uploadedIndexes } = await axios.get(`/check?hash=${fileHash}`);
  ```

- **跳过已传分片**
  前端过滤已上传的分片，仅传剩余部分：

  ```javascript
  chunks.filter((_, index) => !uploadedIndexes.includes(index));
  ```

- **合并分片**
  所有分片上传完成后，通知服务端合并：

  ```javascript
  await axios.post(`/merge`, { hash: fileHash, fileName: file.name });
  ```

**3. 关键优化点**

- **进度反馈**
  监听 `axios` 的 `onUploadProgress` 事件更新进度条。
- **错误重试**
  为每个分片添加重试机制（如最多重试3次）。
- **暂停恢复**
  通过 `AbortController` 中断请求，记录已传分片。

**4. 完整流程示例**

```javascript
// 1. 计算文件哈希（Web Worker避免阻塞）
const fileHash = await computeHash(file);

// 2. 检查已上传分片
const { uploaded } = await checkExist(fileHash);

// 3. 过滤未上传分片
const chunks = splitFile(file);
const unuploaded = chunks.filter((_, i) => !uploaded.includes(i));

// 4. 分片上传（控制并发）
uploadChunks(unuploaded, fileHash);

// 5. 合并请求
await mergeChunks(fileHash, file.name);
```

**技术选型建议**：

- 原生实现用 `Blob.slice` + `Axios`
- 快速开发用 `Uppy.js` 或 `tus-js-client`
- 大文件必配 **Web Worker** 计算哈希，避免主线程卡顿

## 设计一个撤消/重做（Undo/Redo）功能

在Vue中实现撤销/重做功能，可以通过维护状态快照栈来实现。以下是具体步骤：

1. **数据设计**：在组件或Vuex中定义`history`数组和`currentIndex`指针

```javascript
data() {
  return {
    history: [deepCopy(initialState)], // 初始状态深拷贝
    currentIndex: 0,
    isUndoRedo: false // 防止撤销/重做触发记录
  }
}
```

1. **操作记录**：在每次状态变更后保存快照

```javascript
methods: {
  saveSnapshot() {
    if (this.isUndoRedo) return
    // 覆盖重做栈
    this.history = this.history.slice(0, this.currentIndex + 1)
    this.history.push(deepCopy(this.$data)) // 保存当前状态
    this.currentIndex++
  }
}
```

1. **撤销/重做实现**：

```javascript
undo() {
  if (this.currentIndex > 0) {
    this.isUndoRedo = true
    this.currentIndex--
    this.applySnapshot()
  }
},
redo() {
  if (this.currentIndex < this.history.length - 1) {
    this.isUndoRedo = true
    this.currentIndex++
    this.applySnapshot()
  }
},
applySnapshot() {
  Object.assign(this.$data, this.history[this.currentIndex])
  this.$nextTick(() => this.isUndoRedo = false)
}
```

1. **触发监听**：通过watch自动记录状态变化

```javascript
watch: {
  $data: {
    handler: 'saveSnapshot',
    deep: true,
    immediate: false
  }
}
```

**注意**：使用`JSON.parse(JSON.stringify())`进行简单深拷贝，复杂场景建议使用lodash的`_.cloneDeep`。按钮状态可通过计算属性判断`currentIndex`边界值。

## JS 执行 100 万个任务， 如何保证浏览器不卡顿？

核心思路：将任务拆分为多个可中断的块

浏览器的渲染和事件响应依赖主线程，单次长时间占用主线程会导致卡顿。我们需要将任务分解为多个小块，每执行完一小块后让主线程有机会处理其他任务（如渲染、用户交互）。

方法 1：使用 `requestIdleCallback` 或 `setTimeout` 分片

```javascript
function processTasks(tasks, chunkSize = 1000) {
  let index = 0;

  function processNextChunk(deadline) {
    while (index < tasks.length && (deadline.timeRemaining() > 0 || deadline.didTimeout)) {
      // 每次处理一小块任务
      for (let i = 0; i < chunkSize && index < tasks.length; i++, index++) {
        executeTask(tasks[index]); // 执行单个任务
      }
    }

    if (index < tasks.length) {
      // 继续调度下一块任务
      requestIdleCallback(processNextChunk, { timeout: 1000 });
    }
  }

  requestIdleCallback(processNextChunk, { timeout: 1000 });
}

// 启动任务处理
processTasks(Array(1e6).fill(null));
```

**优化点：**

- **动态调整分片大小**：根据 `deadline.timeRemaining()` 动态调整每块任务量。
- **超时控制**：设置 `timeout` 确保即使浏览器不空闲时任务仍能推进。



方法 2：使用 Web Workers 多线程处理（纯计算任务）

如果任务不涉及 DOM，可将计算逻辑转移到 Web Worker：

```javascript
// 主线程代码
const worker = new Worker('task-worker.js');
worker.postMessage({ tasks: Array(1e6).fill(null) });
worker.onmessage = (e) => {
  console.log('任务完成', e.data);
};

// task-worker.js
self.onmessage = function(e) {
  const results = e.data.tasks.map(executeTask); // 执行任务
  self.postMessage(results);
};
```

**优点**：彻底避免主线程阻塞。



方法 3：Generator + `setTimeout`/`requestAnimationFrame`

利用 Generator 函数的暂停特性分步执行：

```javascript
function* taskGenerator(tasks) {
  for (const task of tasks) {
    yield executeTask(task); // 每次 yield 一个任务
  }
}

function runTasks(tasks) {
  const generator = taskGenerator(tasks);
  
  function next() {
    let start = performance.now();
    let res;
    do {
      res = generator.next();
    } while (!res.done && performance.now() - start < 5); // 每帧最多执行 5ms
    
    if (!res.done) {
      requestAnimationFrame(next); // 下一帧继续
    }
  }

  requestAnimationFrame(next);
}

runTasks(Array(1e6).fill(null));
```

**优点**：与浏览器渲染周期对齐，减少卡顿。



方法 4：使用 `Promise` 微任务调度

通过微任务队列逐步处理任务：

```javascript
async function processTasks(tasks) {
  let index = 0;
  const chunkSize = 1000;

  async function processChunk() {
    for (let i = 0; i < chunkSize && index < tasks.length; i++, index++) {
      executeTask(tasks[index]);
    }
    if (index < tasks.length) {
      await Promise.resolve(); // 让出主线程
      processChunk();
    }
  }

  await processChunk();
}

processTasks(Array(1e6).fill(null));
```

**注意**：微任务会连续执行直到队列清空，需合理控制分片大小。

## 如何实现瀑布流布局？

实现瀑布流布局的关键是动态计算每项的位置，使元素依次填充到高度最小的列。步骤如下：

1. **确定列数**：根据容器宽度和列宽计算
2. **跟踪列高**：用数组记录每列当前高度
3. **定位元素**：遍历元素时，总是插入到高度最小的列
4. **更新布局**：元素插入后更新列高，最后设置容器高度

简单Vue实现：

```vue
<<template>
  <!-- 容器绑定ref用于获取DOM -->
  <div class="waterfall" ref="container">
    <!-- 动态生成子元素 -->
    <div v-for="(item, index) in items" :key="index" class="item">
      <!-- 实际内容 -->
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      colHeights: [], // 存储每列高度
    }
  },
  mounted() {
    this.layout()
    window.addEventListener('resize', this.handleResize)
  },
  methods: {
    layout() {
      // 1. 获取容器和子元素
      const container = this.$refs.container
      const items = container.children
      
      // 2. 计算列数和列宽
      const colCount = 3 // 可改为响应式计算
      const gap = 10
      const itemWidth = (container.offsetWidth - gap*(colCount-1))/colCount
      
      // 3. 初始化列高度数组
      this.colHeights = new Array(colCount).fill(0)

      // 4. 遍历元素定位
      Array.from(items).forEach(item => {
        item.style.position = 'absolute'
        item.style.width = `${itemWidth}px`
        
        // 5. 找到当前最短列
        const minHeight = Math.min(...this.colHeights)
        const colIndex = this.colHeights.indexOf(minHeight)
        
        // 6. 设置元素位置
        item.style.left = `${colIndex * (itemWidth + gap)}px`
        item.style.top = `${minHeight}px`
        
        // 7. 更新列高度
        this.colHeights[colIndex] += item.offsetHeight + gap
      })

      // 8. 设置容器总高度
      container.style.height = `${Math.max(...this.colHeights)}px`
    },
    handleResize() {
      // 防抖处理更佳
      this.layout()
    }
  },
  beforeDestroy() {
    window.removeEventListener('resize', this.handleResize)
  }
}
</script>

<style>
.waterfall {
  position: relative;
  margin: 0 auto;
}
.item {
  transition: all 0.3s; /* 可选动画效果 */
}
</style>
```

注意：实际使用需处理图片异步加载（用imagesLoaded库）、性能优化（防抖）和响应式列数调整。CSS方案（columns或grid）可能有限制，JS方案更灵活。

## 如何判断一个元素是否在可视区域中？

[如何判断一个元素是否在可视区域中？](#Intersection)

## 移动端如何实现上拉加载，下拉刷新？

```vue
<template>
  <div class="container"
       @touchstart="touchStart"
       @touchmove="touchMove"
       @touchend="touchEnd"
       ref="scrollContainer">
    <!-- 下拉刷新提示 -->
    <div class="refresh-tip" :style="{ transform: `translateY(${pullDownY}px)` }">
      {{ refreshStatus }}
    </div>

    <!-- 内容区域 -->
    <div class="content">
      <slot></slot>
    </div>

    <!-- 上拉加载提示 -->
    <div class="load-tip">
      {{ loadStatus }}
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      startY: 0,          // 触摸起始Y坐标
      pullDownY: 0,       // 下拉距离
      isRefreshing: false, // 刷新状态
      isLoading: false    // 加载状态
    }
  },
  methods: {
    touchStart(e) {
      // 1. 记录起始位置
      this.startY = e.touches[0].pageY
    },
    touchMove(e) {
      // 2. 计算下拉距离（仅限顶部下拉）
      if (this.$refs.scrollContainer.scrollTop > 0) return
      
      const currentY = e.touches[0].pageY
      this.pullDownY = currentY - this.startY
      
      // 3. 阻止原生滚动
      if (this.pullDownY > 0) {
        e.preventDefault()
      }
    },
    touchEnd() {
      // 4. 触发刷新判断（下拉距离>60）
      if (this.pullDownY > 60 && !this.isRefreshing) {
        this.isRefreshing = true
        this.$emit('refresh')
      }
      this.pullDownY = 0
    },

    checkScroll() {
      // 5. 上拉加载判断
      const container = this.$refs.scrollContainer
      const { scrollTop, scrollHeight, clientHeight } = container
      
      // 6. 触底判断（距离底部<50 且未在加载）
      if (scrollHeight - scrollTop - clientHeight < 50 && !this.isLoading) {
        this.isLoading = true
        this.$emit('load')
      }
    }
  },
  mounted() {
    // 7. 监听滚动事件
    this.$refs.scrollContainer.addEventListener('scroll', this.checkScroll)
  },
  beforeDestroy() {
    this.$refs.scrollContainer.removeEventListener('scroll', this.checkScroll)
  }
}
</script>

<style>
.container {
  height: 100vh;
  overflow: auto;
  -webkit-overflow-scrolling: touch; /* 启用弹性滚动 */
}

.refresh-tip {
  position: fixed;
  top: -50px;
  width: 100%;
  text-align: center;
  transition: transform 0.3s;
}
</style>
```

**核心流程：**

1. **下拉刷新**：通过`touchstart/touchmove/touchend`计算下拉距离
2. **上拉加载**：监听容器滚动事件，计算触底距离
3. **状态管理**：通过标志位防止重复触发
4. **事件通信**：通过`$emit`触发父组件数据更新

**使用示例：**

```vue
<ScrollWrapper @refresh="fetchData" @load="loadMore">
  <!-- 内容列表 -->
</ScrollWrapper>
```

**优化方向：**

- 添加加载动画/状态提示
- 增加防抖节流
- 支持自定义阈值
- 使用IntersectionObserver优化触底检测

## 如何实现将数组转化为树状结构？

**方法一**

很容易想到的一个方法就是利用递归：每次遍历时，找到将本次遍历的根节点作为父节点的所有子节点，直至找不到有子节点的。 

```javascript
function arrayToTree(list, root) {
  return list
    .filter(item => item.parent_id === root)
    .map(item => ({ ...item, children: arrayToTree(list, item.id) }))
}
```

**方法二**

可以利用浅拷贝是拷贝对象的内存地址的特性，我们修改拷贝后，所有引用都会同步修改。利用这个特点，我们将子节点依次放入父节点，最后将最外层父节点返回即可。

```javascript
function arrayToTree(list, root) {
  const result = [] // 用于存放结果
  const map = {} // 用于存放 list 下的节点

  // 遍历 list
  for (const item of list) {
    // 1. 获取节点的 id 和 父 id
    const { id, parent_id } = item // ES6 解构赋值

    // 2. 将节点存入 map
    if (!map[id]) map[id] = {}

    // 3. 根据 id，将节点与之前存入的子节点合并
    map[id] = map[id].children
      ? { ...item, children: map[id].children }
      : { ...item }

    // 4. 如果是根节点，存入 result
    if (parent_id === root) {
      result.push(map[id])
    } else {
      // 5. 反之，存入父节点
      if (!map[parent_id]) map[parent_id] = {}
      if (!map[parent_id].children) map[parent_id].children = []
      map[parent_id].children.push(map[id])
    }
  }

  // 将结果返回
  return result
}
```



## 高并发场景下前端如何优化？

高并发是指在极短单位时间内，有很多用户同时的访问同一 API 接口或者 Url 地址，造成极多个请求同时发起到服务器。它经常会发生在有大活跃用户量，用户高聚集的业务场景中。大部分的高并发处理基本都是在后端处理，但是在部分特殊情况下，后端无法阻止用户行为，需要前端做配合。例如在抢购、秒杀等场景。

前端可以做些什么？

1. 合并请求
2. 节流防抖
3. 数据分页+虚拟滚动，避免全量加载
4. 代码压缩
5. 压缩图片
6. 图片懒加载
7. 图片使用Base64编码，雪碧图
8. CDN加速 + 文件名哈希强缓存

## 做一个 Dialog 组件，说说你设计的思路?它应该有什么功能?

我设计的Dialog组件核心功能包括：遮罩层、可关闭机制、自定义内容插槽、动画过渡。支持v-model控制显隐，提供标题/内容/底部按钮区插槽，并暴露确认/取消事件。

**简易实现（Vue3）：**

```vue
<template>
  <Teleport to="body">
    <Transition name="fade">
      <div v-if="modelValue" class="mask">
        <div class="dialog">
          <div class="header">
            <slot name="title">{{ title }}</slot>
            <span @click="$emit('update:modelValue', false)">×</span>
          </div>
          <div class="content">
            <slot></slot>
          </div>
          <div class="footer">
            <slot name="footer">
              <button @click="$emit('cancel')">取消</button>
              <button @click="$emit('confirm')">确定</button>
            </slot>
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup>
defineProps({
  modelValue: Boolean,
  title: String
})
defineEmits(['update:modelValue', 'confirm', 'cancel'])
</script>

<style scoped>
.mask {
  position: fixed;
  top:0; left:0; 
  width:100%; height:100%;
  background: rgba(0,0,0,0.5);
  display: grid;
  place-items: center;
}

.dialog {
  background: white;
  padding: 20px;
  border-radius: 4px;
  min-width: 300px;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

**如果考虑全局服务式调用：**

```javascript
// 全局服务封装
let dialogInstance = null

export const useDialog = () => {
  const createDialog = (options) => {
    if (!dialogInstance) {
      const container = document.createElement('div')
      dialogInstance = createApp(DialogComponent, options)
      document.body.appendChild(container)
      dialogInstance.mount(container)
    }
    return dialogInstance
  }

  return {
    open: (options) => createDialog().open(options),
    close: () => dialogInstance?.unmount()
  }
}

// 组件增强
defineProps({
  teleportTo: {
    type: [String, HTMLElement],
    default: 'body'
  }
})
```

**使用方式：**

```vue
<!-- 组件式 -->
<MyDialog v-model="show" teleport-to="#custom-root" />

<!-- 服务式 -->
<script setup>
const { open } = useDialog()

const showDialog = () => {
  open({
    title: '提示',
    content: '确定删除？',
    onConfirm: () => {/* ... */}
  })
}
</script>
```



## 如何实现浏览器内多个标签页之间的通信？

实现多标签页通信的常用方案：

1. **LocalStorage + storage事件**（同源）

   ```javascript
   // A页修改数据
   localStorage.setItem('key', JSON.stringify(data));
   
   // B页监听
   window.addEventListener('storage', (e) => {
     console.log(e.key, e.newValue);
   });
   ```

2. **BroadcastChannel API**（现代浏览器）

   ```javascript
   // 各页创建同名字频道
   const channel = new BroadcastChannel('chat');
   channel.postMessage(data);
   channel.onmessage = (e) => { /* 处理消息 */ };
   ```

3. **SharedWorker**（复杂场景）

   ```javascript
   // Worker中维护消息中转站
   onconnect = (e) => {
     const port = e.ports[0];
     port.onmessage = (e) => {
       // 广播给所有连接的页面
     };
   };
   ```

4. **window.postMessage**（跨域场景）

   ```javascript
   // 通过 opener 引用传递
   window.open('pageB').postMessage(data, origin);
   ```

**对比建议**：简单数据用LocalStorage，实时通信用BroadcastChannel，持久化复杂数据用SharedWorker，注意同源策略限制。

## 如何实现图片的懒加载和预加载

**懒加载实现思路**：

1. 监听滚动+判断视口位置（或用IntersectionObserver）
2. 替换data-src为真实src

**预加载实现思路**：

1. 提前创建Image对象加载图片
2. 缓存到浏览器

**Vue实现示例**：

```vue
<script setup>
// 图片懒加载指令
const vLazyload = {
  mounted(el) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // 进入视口时加载图片
          el.src = el.dataset.src
          observer.unobserve(el) // 停止监听
        }
      })
    })
    observer.observe(el)
  }
}

// 图片预加载方法
const preloadImages = (urls) => {
  urls.forEach(url => {
    const img = new Image()
    img.src = url // 触发浏览器缓存
  })
}
</script>

<template>
  <!-- 懒加载使用 -->
  <img v-lazyload data-src="real-image.jpg" alt="">
  
  <!-- 预加载触发 -->
  <button @click="preloadImages(['next-page-img.jpg'])">预加载图片</button>
</template>
```

**关键点**：懒加载用观察者优化性能，预加载利用浏览器缓存机制。实际生产需加加载状态和错误处理。

## 一个列表，假设有 100000 个数据，这个该怎么办？

**核心解决方案**：虚拟滚动 + 数据分片
（避免同时渲染全部DOM）

**实现步骤**：

1. **计算可视区域高度**
2. **动态渲染可视区数据**（startIndex-endIndex）
3. **监听滚动动态更新**

**Vue3示例**：

```vue
<script setup>
import { ref, computed } from 'vue';

const itemHeight = 40; // 每项高度
const total = 100000;
const visibleCount = Math.ceil(window.innerHeight / itemHeight); // 可视区条数
const startIndex = ref(0);

// 生成模拟数据
const list = Array.from({length: total}, (_,i) => `Item ${i+1}`);

// 可视区数据切片
const visibleData = computed(() => 
  list.slice(startIndex.value, startIndex.value + visibleCount)
);

const handleScroll = (e) => {
  startIndex.value = Math.floor(e.target.scrollTop / itemHeight);
};
</script>

<template>
  <div 
    class="virtual-list" 
    @scroll="handleScroll"
    :style="{ height: `${visibleCount * itemHeight}px` }"
  >
    <div class="scroll-holder" 
         :style="{ height: `${total * itemHeight}px` }">
      <div 
        class="item" 
        v-for="(item, index) in visibleData"
        :key="index"
        :style="{ transform: `translateY(${startIndex * itemHeight}px)` }"
      >
        {{ item }}
      </div>
    </div>
  </div>
</template>

<style>
.virtual-list {
  overflow-y: auto;
}
.scroll-holder {
  position: relative;
}
.item {
  position: absolute;
  width: 100%;
  height: 40px;
  line-height: 40px;
}
</style>
```

**优化点**：

1. 只维护`visibleCount+2`个DOM节点
2. 滚动时通过transform位移代替重新渲染
3. 实际项目建议用`vue-virtual-scroller`等成熟库

## 如何实现一键Copy功能

**核心步骤**：

1. 创建隐藏的`textarea`临时元素
2. 使用`Clipboard API`或`execCommand`写入剪贴板
3. 移除临时元素并反馈结果

**Vue3实现**：

```vue
<script setup>
const copyText = async (text) => {
  try {
    // 现代API方案
    await navigator.clipboard.writeText(text)
    alert('复制成功')
  } catch {
    // 兼容方案
    const textarea = document.createElement('textarea')
    textarea.value = text
    document.body.appendChild(textarea)
    textarea.select()
    document.execCommand('copy')
    document.body.removeChild(textarea)
    alert('复制成功')
  }
}
</script>

<template>
  <button @click="copyText('要复制的内容')">一键复制</button>
</template>
```

**优化点**：

- 优先使用`Clipboard API`（更安全）
- 旧浏览器自动降级兼容
- 生产环境建议封装成指令+Toast提示

## 前端如何实现即时通讯？

**核心方案**：WebSocket 长连接 + 消息队列
（替代方案：短轮询/SSE，但实时性较差）

**实现流程**：

1. 建立 WebSocket 连接
2. 双向通信：监听消息/发送消息
3. 心跳检测保持连接
4. 异常重连机制

**Vue3 简易实现**：

```vue
<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

const ws = ref(null)
const messages = ref([])

// 1. 初始化连接
const initWebSocket = () => {
  ws.value = new WebSocket('wss://your-websocket-endpoint')

  // 2. 监听消息
  ws.value.onmessage = (e) => {
    messages.value.push(JSON.parse(e.data))
  }

  // 3. 心跳检测
  let heartTimer = setInterval(() => {
    ws.value.send('ping')
  }, 30000)

  // 4. 异常处理
  ws.value.onclose = () => {
    clearInterval(heartTimer)
    setTimeout(initWebSocket, 2000) // 断线重连
  }
}

// 发送消息
const sendMessage = (text) => {
  ws.value.send(JSON.stringify({
    type: 'text',
    content: text,
    timestamp: Date.now()
  }))
}

onMounted(initWebSocket)
onBeforeUnmount(() => {
  ws.value?.close() // 清理连接
})
</script>

<template>
  <div class="chat-box">
    <div v-for="msg in messages" :key="msg.timestamp">
      {{ msg.content }}
    </div>
    <input @keyup.enter="sendMessage" />
  </div>
</template>
```

**关键优化**：

- 消息数据格式化（JSON编解码）
- 心跳防止连接断开（Nginx默认60s超时）
- 生产环境需增加消息状态反馈/消息重发机制

## 前端如何实现截图？

**核心方案**：使用 `html2canvas` 库实现 DOM 转 Canvas
**流程**：

1. 捕获目标 DOM 元素
2. 生成 Canvas 并转图片
3. 触发下载或预览

**Vue3 实现**（需先安装 `html2canvas`）：

```vue
<script setup>
import { ref } from 'vue';
import html2canvas from 'html2canvas';

const targetRef = ref(null); // 1. 获取截图目标元素

const capture = async () => {
  // 2. 生成 Canvas
  const canvas = await html2canvas(targetRef.value, {
    useCORS: true // 处理跨域图片
  });
  
  // 3. 转图片并下载
  const link = document.createElement('a');
  link.download = 'screenshot.png';
  link.href = canvas.toDataURL();
  link.click();
};
</script>

<template>
  <!-- 截图区域 -->
  <div ref="targetRef" class="screenshot-area">
    <h1>截我！</h1>
    <p>动态内容{{ new Date().toLocaleString() }}</p>
  </div>

  <!-- 触发按钮 -->
  <button @click="capture">截图保存</button>
</template>
```

**关键点**：

- 处理跨域资源需配置 `useCORS: true`
- 复杂样式需注意 `foreignObjectRendering` 配置
- 实际项目建议结合裁剪工具（如 `cropperjs`）

## 如何实现图片裁剪上传？

**原生 Canvas 实现思路**：

1. 文件读取 → 绘制到 Canvas
2. 通过鼠标事件实现选区交互
3. 裁剪选区 → 生成新图片



**Vue3 实现**（无第三方库）：

```vue
<script setup>
import { ref } from 'vue'

const canvasRef = ref(null)
const startX = ref(0)
const startY = ref(0)
const isDrawing = ref(false)
let img = null
let scale = 1

// 1. 文件读取
const handleUpload = (e) => {
  const file = e.target.files[0]
  const reader = new FileReader()
  
  reader.onload = (e) => {
    img = new Image()
    img.onload = drawImageToCanvas
    img.src = e.target.result
  }
  reader.readAsDataURL(file)
}

// 绘制到Canvas
const drawImageToCanvas = () => {
  const canvas = canvasRef.value
  const ctx = canvas.getContext('2d')
  
  // 计算缩放比例（限制最大宽度800px）
  scale = Math.min(800 / img.width, 1)
  canvas.width = img.width * scale
  canvas.height = img.height * scale
  
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
}

// 2. 选区交互逻辑
const startDraw = (e) => {
  isDrawing.value = true
  const rect = canvasRef.value.getBoundingClientRect()
  startX.value = e.clientX - rect.left
  startY.value = e.clientY - rect.top
}

const drawing = (e) => {
  if (!isDrawing.value) return
  const rect = canvasRef.value.getBoundingClientRect()
  const currentX = e.clientX - rect.left
  const currentY = e.clientY - rect.top
  
  // 实时绘制选区框
  const ctx = canvasRef.value.getContext('2d')
  ctx.clearRect(0, 0, canvasRef.value.width, canvasRef.value.height)
  ctx.drawImage(img, 0, 0, canvasRef.value.width, canvasRef.value.height)
  ctx.strokeStyle = '#f00'
  ctx.strokeRect(
    startX.value, 
    startY.value, 
    currentX - startX.value, 
    currentY - startY.value
  )
}

// 3. 裁剪并上传
const cropImage = () => {
  const canvas = document.createElement('canvas')
  const rect = canvasRef.value.getBoundingClientRect()
  
  // 计算实际裁剪尺寸（考虑缩放比例）
  const cropWidth = (endX - startX.value) / scale
  const cropHeight = (endY - startY.value) / scale
  
  canvas.width = cropWidth
  canvas.height = cropHeight
  canvas.getContext('2d').drawImage(
    img,
    startX.value / scale,  // 原始图片X位置
    startY.value / scale,  // 原始图片Y位置
    cropWidth,            // 原始图片裁剪宽度
    cropHeight,           // 原始图片裁剪高度
    0, 0,                // 新canvas起始位置
    cropWidth, cropHeight // 新canvas尺寸
  )
  
  // 转换为Blob上传
  canvas.toBlob(blob => {
    const formData = new FormData()
    formData.append('file', blob)
    // 执行上传逻辑...
  })
}
</script>

<template>
  <input type="file" @change="handleUpload" accept="image/*">
  <canvas 
    ref="canvasRef"
    @mousedown="startDraw"
    @mousemove="drawing"
    @mouseup="cropImage"
    @mouseleave="isDrawing = false"
  ></canvas>
</template>
```

## 如何解决页面请求接口大规模并发问题？

1. **使用防抖和节流**
   防抖（Debouncing）：在一段时间内只执行最后一次请求，适用于用户输入场景。
```javascript
function debounce(func, delay) {
let timer;
return function (...args) {
clearTimeout(timer);
timer = setTimeout(() => func.apply(this, args), delay);
};
}
节流（Throttling）：限制在一定时间内执行请求，适用于限制频繁的请求。

function throttle(func, limit) {
let lastFunc;
let lastRan;
return function (...args) {
const context = this;
if (!lastRan) {
func.apply(context, args);
lastRan = Date.now();
} else {
clearTimeout(lastFunc);
lastFunc = setTimeout(function () {
if ((Date.now() - lastRan) >= limit) {
func.apply(context, args);
lastRan = Date.now();
}
}, limit - (Date.now() - lastRan));
}
};
}
```
2. **请求合并**
   请求去重：避免同一请求被重复发起，通过设置请求唯一标识来防止重复请求。
```javascript
const pendingRequests = new Map();

async function fetchData(url, options) {
const key = `${url}_${JSON.stringify(options)}`;
if (pendingRequests.has(key)) {
return pendingRequests.get(key);
}

const requestPromise = fetch(url, options).finally(() => {
pendingRequests.delete(key);
});
pendingRequests.set(key, requestPromise);
return requestPromise;
}
```
批量请求：将多个请求合并为一个请求，通过接口支持批量请求功能来减少请求数量。

3. **后端处理**
   负载均衡：使用负载均衡器将请求分发到多个服务器，避免单台服务器过载。

缓存：在后端使用缓存（如 Redis）存储重复请求的数据，减少数据库压力。

限流：在后端实施限流策略，控制每秒处理的请求数量，防止系统过载。

4. **异步处理**
   并发控制：限制并发请求的数量，通过实现并发队列来控制请求的并发数。
```javascript
class Queue {
constructor(limit) {
this.queue = [];
this.activeCount = 0;
this.limit = limit;
}

add(fn) {
return new Promise((resolve, reject) => {
this.queue.push(() => fn().then(resolve).catch(reject));
this.processQueue();
});
}

processQueue() {
if (this.activeCount < this.limit && this.queue.length > 0) {
const fn = this.queue.shift();
this.activeCount++;
fn().finally(() => {
this.activeCount--;
this.processQueue();
});
}
}
}
```
5. **前端缓存**
   使用浏览器缓存：设置缓存头（如 Cache-Control 和 ETag）来缓存请求结果，减少重复请求。

本地存储：使用 localStorage 或 sessionStorage 来缓存数据，避免重复请求。

6. **使用 Web Workers**
   Web Workers：将一些计算密集型的请求处理任务放到 Web Worker 中，避免阻塞主线程，提升用户体验。


## 使用同一个链接， 如何实现 PC 打开是 web 应用、手机打开是一个 H5 应用？

**核心方案**：设备检测 + 动态渲染
**实现步骤**：

1. 通过 `navigator.userAgent` 检测设备类型
2. 同一路由下根据设备渲染不同组件

**Vue3 示例代码**：

```vue
<script setup>
import { ref, onMounted } from 'vue'
import PcView from './PcView.vue'
import MobileView from './MobileView.vue'

const isMobile = ref(false)

// 设备检测函数
const checkDevice = () => {
  const ua = navigator.userAgent.toLowerCase()
  isMobile.value = /iphone|android|mobile/.test(ua)
}

onMounted(checkDevice)
</script>

<template>
  <!-- 动态切换组件 -->
  <component :is="isMobile ? MobileView : PcView" />
  
  <!-- 可选：提供手动切换按钮 -->
  <button @click="isMobile = !isMobile">
    {{ isMobile ? '切换PC版' : '切换移动版' }}
  </button>
</template>
```



**优化方案**：

1. **服务端识别**（SSR）：

   ```javascript
   // Node.js 中间件示例
   app.get('/', (req, res) => {
     const isMobile = /mobile/i.test(req.headers['user-agent'])
     res.render(isMobile ? 'mobile' : 'pc')
   })
   ```

2. **响应式媒体查询兜底**：

   ```css
   /* 共用基础样式 + 设备差异样式 */
   .main-content {
     padding: 20px;
     @media (max-width: 768px) {
       padding: 10px;
     }
   }
   ```



## Vue3用 ref 和 watch 实现一个防抖搜索 Hook

**Vue3 防抖搜索 Hook 实现**：

```typescript
import { ref, watch, type WatchStopHandle } from 'vue';

export function useDebounceSearch(callback: (val: string) => void, delay = 300) {
  const keyword = ref('');

  // 防抖逻辑封装
  let timer: number;
  const stopWatch = watch(keyword, (newVal) => {
    clearTimeout(timer);
    timer = window.setTimeout(() => {
      callback(newVal);
    }, delay);
  });

  // 自动清理
  const stop = () => {
    clearTimeout(timer);
    stopWatch();
  };

  return { keyword, stop };
}
```



**使用示例**：

```vue
<script setup>
import { useDebounceSearch } from './hooks';

const { keyword } = useDebounceSearch((val) => {
  console.log('搜索:', val);
  // 调用API...
}, 500);
</script>

<template>
  <input v-model="keyword" placeholder="输入搜索内容" />
</template>
```

## 如何实现请求进度监控？

**请求进度监控实现方案**：

1. **XMLHttpRequest 原生方案**

```javascript
const xhr = new XMLHttpRequest();
xhr.upload.onprogress = (e) => { // 上传进度
  const percent = (e.loaded / e.total * 100).toFixed(2)
};
xhr.onprogress = (e) => { // 下载进度
  console.log(`下载进度：${percent}%`)
};
```

1. **Axios 封装方案**

```javascript
axios.post('/upload', file, {
  onUploadProgress: progressEvent => {
    const percent = Math.round(
      (progressEvent.loaded * 100) / progressEvent.total
    )
  },
  onDownloadProgress: progressEvent => {
    // 处理下载进度
  }
})
```

1. **Fetch API 分块读取方案**

```javascript
const response = await fetch(url);
const reader = response.body.getReader();
let received = 0;

while(true) {
  const { done, value } = await reader.read();
  if(done) break;
  received += value.length;
  const total = +response.headers.get('Content-Length');
  console.log(`下载进度：${(received/total*100).toFixed(1)}%`);
}
```

## 如何实现网页加载进度条？

**核心方案**：路由守卫 + 虚拟进度模拟
**实现步骤**（Vue3 + NProgress 示例）：

1. 安装进度条库：

```bash
npm install nprogress
```

2. 封装进度条逻辑：

```javascript
// utils/progress.js
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'

NProgress.configure({ showSpinner: false })

export const start = () => NProgress.start()
export const done = () => NProgress.done()
```

3. 结合路由守卫：

```javascript
// router.js
import { start, done } from './utils/progress'

router.beforeEach(() => {
  start() // 路由切换时启动
})

router.afterEach(() => {
  setTimeout(done, 300) // 微延迟保证过渡效果
})
```

**优化点**：

- 请求拦截器集成真实加载进度
- 智能最小加载时间（至少保持200ms避免闪烁）
- 错误处理自动关闭进度条
- 自定义样式匹配品牌视觉

**原生JS实现要点**：

```javascript
// 创建进度条DOM
const progressBar = document.createElement('div')
progressBar.style.cssText = `
  position: fixed; 
  top:0; left:0; 
  height:3px; 
  background: #00a3ff;
  transition: width 0.3s ease;
`

// 更新进度函数
let progress = 0
const update = (value) => {
  progress = Math.min(Math.max(value, 0), 1)
  progressBar.style.width = `${progress * 100}%`
}

// 挂载到页面
document.body.prepend(progressBar)

// 使用示例
update(0.3) // 更新到30%
```

## 如果用户说 web 应用感觉很反应慢或者卡顿，该如何排查？
1. **性能分析**
   浏览器开发者工具：使用 Chrome DevTools 或其他浏览器的开发者工具，查看性能面板中的记录，分析 CPU 和内存使用情况。
   Performance：查看长时间的任务、回流和重绘情况，识别瓶颈。
   Memory：检查内存使用情况和垃圾回收，查找内存泄漏。
   Network：监控网络请求时间，查看是否有资源加载缓慢的情况。
2. **网络请求**
   检查加载时间：使用网络面板查看请求的响应时间和大小，找出慢请求。
   分析请求依赖：确保第三方服务和 API 响应迅速且稳定，减少请求次数和大小。
3. **代码审查**
   长时间运行的脚本：查找和优化执行时间较长的 JavaScript 代码，使用 Web Workers 处理耗时任务。
   频繁的 DOM 操作：减少 DOM 操作的次数和复杂度，批量更新 DOM。
   事件处理：优化事件处理程序，避免高频率的事件触发（如滚动、输入）。
4. **资源优化**
   资源大小：检查图片、字体和其他资源的大小，压缩和优化资源。
   异步加载：使用懒加载和异步加载技术，避免阻塞渲染。
5. **前端性能优化**
   缓存：利用浏览器缓存和 CDN 加速静态资源加载。
   代码拆分：使用 Webpack 或其他构建工具进行代码拆分，减少初始加载时间。
   CSS 和 JS 合并：合并 CSS 和 JS 文件，减少 HTTP 请求次数。
6. **用户反馈**
   重现问题：询问用户操作的具体步骤和使用环境，尝试重现问题。
   环境差异：检查不同设备、浏览器和网络环境下的表现，确保兼容性。
7. **使用监控工具**
   实时监控：使用性能监控工具（如 New Relic、Datadog）收集实时性能数据。
   错误跟踪：配置错误监控工具（如 Sentry），捕获和分析 JavaScript 错误和异常。
8. **回归测试**
   版本回退：测试最近的更改，查看是否新版本引入了性能问题。
   逐步回退：逐步回退更改，以确定性能问题的根源。

## 请你实现一个大文件上传和断点续传

**大文件上传 & 断点续传流程简述：**

1. **分片切割**：前端将大文件按固定大小（如2MB）切片。
2. **唯一标识**：根据文件内容生成hash（如使用SparkMD5），作为文件唯一标识。
3. **验证分片**：上传前调用接口，检查哪些分片已上传。
4. **并发上传**：并行上传未传分片，每个分片携带hash、索引、总片数。
5. **合并请求**：全部分片上传后，通知服务端合并。
6. **断点续传**：上传中断后，重新上传时跳过已传分片。



**Vue 简易实现（核心代码）：**

```vue
<template>
  <input type="file" @change="handleFileChange" />
  <button @click="upload">上传</button>
  
  <!-- 进度条 -->
  <div class="progress">
    <div :style="{ width: progress + '%' }">{{ progress.toFixed(1) }}%</div>
  </div>
  
  <!-- 错误提示 -->
  <div v-if="errorMsg" class="error">{{ errorMsg }}</div>
</template>

<script>
export default {
  data() {
    return {
      // ...原有数据...
      progress: 0,        // 总进度
      chunkProgress: {},  // 记录每个分片进度 { 0: 80, 1: 100... }
      retryCount: 3,      // 最大重试次数
      errorMsg: ''        // 错误信息
    };
  },
  computed: {
    // 计算总进度（根据所有分片进度）
    totalProgress() {
      const chunks = Object.values(this.chunkProgress);
      return chunks.reduce((sum, v) => sum + v, 0) / chunks.length || 0;
    }
  },
  methods: {
    async upload() {
      try {
        // ...检查已上传分片逻辑...
        
        // 并行上传（带进度和重试）
        const requests = [];
        for (let i = 0; i < chunks; i++) {
          if (uploaded.includes(i)) {
            this.chunkProgress[i] = 100; // 已传分片直接100%
            continue;
          }
          requests.push(this.uploadChunkWithRetry(i));
        }
        
        await Promise.all(requests);
        // ...合并请求...
        
      } catch (err) {
        this.errorMsg = `上传失败: ${err.message}`;
      }
    },

    // 带重试的分片上传
    async uploadChunkWithRetry(index, retry = 0) {
      try {
        const formData = new FormData();
        formData.append('chunk', await this.getChunk(index));
        // ...其他字段...
        
        await axios.post('/upload', formData, {
          // 进度监听
          onUploadProgress: e => {
            this.chunkProgress[index] = Math.floor((e.loaded / e.total) * 100);
          }
        });
        
      } catch (err) {
        if (retry < this.retryCount) {
          return this.uploadChunkWithRetry(index, retry + 1); // 重试
        }
        throw new Error(`分片${index}上传失败`);
      }
    }
  }
};
</script>

<style>
.progress { /* 简单进度条样式 */ }
.error { color: red; }
</style>
```



## 扫码登录实现方式

**扫码登录流程简述：**

1. **生成临时令牌**：服务端生成唯一临时`token`并设置有效期（如5分钟）
2. **生成二维码**：前端将`token`编码为二维码（格式：`https://xxx.com/login?token=xxx`）
3. **轮询检查状态**：前端定时轮询接口，检查该`token`是否被扫码确认
4. **移动端操作**：用户扫码后，移动端请求服务端绑定`token`与用户身份
5. **登录完成**：网页端检测到`token`状态变化后，完成登录并跳转



**Vue 简易实现（核心代码）：**

```vue
<template>
  <div ref="qrcode"></div>
  <div>{{ statusText }}</div>
</template>

<script>
import QRCode from 'qrcodejs2';
import axios from 'axios';

export default {
  data() {
    return {
      token: '',
      timer: null,
      statusText: '请扫码登录'
    };
  },
  mounted() {
    this.initQrcode();
  },
  beforeUnmount() {
    clearInterval(this.timer); // 清除轮询
  },
  methods: {
    // 1. 初始化生成二维码
    async initQrcode() {
      // 获取临时token
      const { token } = await axios.get('/api/login/qrcode');
      this.token = token;
      
      // 生成二维码
      new QRCode(this.$refs.qrcode, {
        text: `https://app.com/confirm?token=${token}`,
        width: 200,
        height: 200
      });
      
      // 2. 开始轮询检查状态
      this.startPolling();
    },

    // 3. 轮询检查登录状态
    startPolling() {
      this.timer = setInterval(async () => {
        try {
          const { status, user } = await axios.get(`/api/login/check?token=${this.token}`);
          
          if (status === 'confirmed') {
            clearInterval(this.timer);
            this.statusText = `登录成功：${user.name}`;
            // 存储登录凭证 & 跳转
            localStorage.setItem('token', user.token);
            this.$router.push('/');
          } else if (status === 'expired') {
            clearInterval(this.timer);
            this.statusText = '二维码已过期，请刷新';
          }
        } catch (err) {
          console.error('轮询异常', err);
        }
      }, 2000); // 每2秒轮询一次
    }
  }
};
</script>
```

**关键注释：**

- **临时Token**：服务端需维护`token`与用户身份的映射关系及状态（未扫描/已确认/已过期）
- **二维码内容**：通常为包含`token`的URL，移动端扫码后解析出`token`并请求绑定接口
- **轮询优化**：实际项目建议用WebSocket替代定时轮询
- **安全措施**：
  - Token需设置有效期（防止盗用）
  - 限制同一IP的频繁请求
  - 移动端扫码后需二次确认（防误扫）

**移动端处理示例流程：**

1. 扫码获取`token`
2. 调用接口`POST /api/login/confirm`发送用户凭证+`token`
3. 服务端验证后绑定`token`与用户身份

## 单点登录是什么?具体流程是什么?

**单点登录（SSO）** 是一种身份验证机制，允许用户通过一次登录访问多个相互信任的系统，无需重复输入凭证。



**核心流程（以典型Token方案为例）：**

1. **首次登录**：
   - 用户访问系统A，未登录时重定向至**统一认证中心**。
   - 用户输入账号密码完成认证，认证中心生成全局Token（如JWT）并存储关联会话。
2. **系统A登录**：
   - 认证中心将用户重定向回系统A并携带Token。
   - 系统A验证Token有效性后创建本地会话（如设置Cookie），允许访问。
3. **访问其他系统**：
   - 用户访问系统B时，系统B检测未登录，重定向至认证中心。
   - 认证中心发现用户已登录，直接返回Token给系统B。
   - 系统B验证Token后建立本地会话，用户无感登录。



**关键点**：

- **Token共享**：认证中心通过加密签名确保Token不可伪造。
- **会话同步**：各系统信任认证中心的Token，但维护独立的本地会话。
- **单点登出**：任一系统登出时，通知认证中心销毁全局会话，触发所有系统本地会话失效。



**常见实现协议**：

- **OAuth 2.0**（如Google登录）
- **SAML**（企业级应用）
- **CAS**（开源单点登录框架）

https://v.douyin.com/Wz1D4jUoOfs/

## 如何做无感token刷新？

**无感 Token 刷新实现核心步骤：**

1. **双 Token 机制**：
   - Access Token（短期有效，如2小时）
   - Refresh Token（长期有效，存储于安全位置如 HttpOnly Cookie）
2. **请求拦截**：
   - 发起请求时携带 Access Token
   - 若接口返回 `401`（Token过期），触发刷新流程
3. **刷新控制**：
   - **防并发刷新**：首个过期请求发起刷新，后续请求挂起队列
   - **刷新请求**：用 Refresh Token 请求新 Access Token
   - **更新存储**：新 Token 更新到内存及本地存储
4. **失败处理**：
   - 刷新失败则清除 Token，跳转登录页



**代码关键逻辑（Axios 拦截器示例）**：

```javascript
let isRefreshing = false; // 刷新锁
let requestsQueue = []; // 等待队列

// 响应拦截器
axios.interceptors.response.use(
  response => response,
  async error => {
    if (error.status !== 401) return Promise.reject(error);
    
    // 非重复的刷新请求
    if (!isRefreshing) {
      isRefreshing = true;
      try {
        const { newToken } = await refreshToken();
        localStorage.setItem('token', newToken);
        // 重放队列中所有请求
        requestsQueue.forEach(cb => cb(newToken));
        return axios(error.config); // 重试原请求
      } catch (e) {
        logout(); // 清除Token并跳转登录
      } finally {
        isRefreshing = false;
        requestsQueue = [];
      }
    }
    
    // 已有刷新任务时，将请求加入队列
    return new Promise(resolve => {
      requestsQueue.push(token => {
        error.config.headers.Authorization = token;
        resolve(axios(error.config));
      });
    });
  }
);
```

**关键设计点**：

- **安全存储**：Refresh Token 建议通过 HttpOnly Cookie 传输
- **滑动过期**：每次刷新重置 Refresh Token 有效期
- **心跳检测**：页面活跃时预刷新 Token 避免突然中断
- **服务端协同**：维护 Token 黑名单/白名单机制

https://v.douyin.com/XDvlASKVr94/

## 前端如何用 canvas 来做电影院选票功能，请简要说明

```vue
<template>
  <canvas ref="canvas" @click="handleClick"></canvas>
  <div>已选座位：{{ selectedSeats.join(', ') }}</div>
</template>

<script>
export default {
  data() {
    return {
      seats: [],        // 二维数组存储座位状态 0:可售 1:已选 2:已售
      seatSize: 30,     // 座位直径
      gap: 15,          // 座位间距
      selectedSeats: [] // 记录选中座位
    }
  },
  mounted() {
    this.initCanvas();
    this.generateSeats(10, 8); // 生成10排8列
    this.draw();
  },
  methods: {
    // 1. 初始化画布
    initCanvas() {
      const canvas = this.$refs.canvas;
      const dpr = window.devicePixelRatio;
      const rect = canvas.getBoundingClientRect();
      
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      this.ctx = canvas.getContext('2d');
      this.ctx.scale(dpr, dpr);
    },

    // 2. 生成座位数据（示例）
    generateSeats(rows, cols) {
      this.seats = Array.from({ length: rows }, (_, i) => 
        Array.from({ length: cols }, (_, j) => {
          if (j === 3 || j === 4) return 2; // 模拟中间走道
          return Math.random() > 0.8 ? 2 : 0; // 随机生成已售座位
        })
      );
    },

    // 3. 绘制座位图
    draw() {
      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
      
      this.seats.forEach((row, i) => {
        row.forEach((state, j) => {
          if (state === 2) return; // 已售不绘制
          
          const x = j * (this.seatSize + this.gap) + this.gap;
          const y = i * (this.seatSize + this.gap) + this.gap;
          
          // 绘制座位
          this.ctx.beginPath();
          this.ctx.arc(x, y, this.seatSize/2, 0, Math.PI*2);
          this.ctx.fillStyle = state === 1 ? '#f00' : '#4CAF50';
          this.ctx.fill();
          this.ctx.stroke();
        });
      });
    },

    // 4. 处理点击事件
    handleClick(e) {
      const rect = this.$refs.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // 坐标转行列号
      const col = Math.floor(x / (this.seatSize + this.gap));
      const row = Math.floor(y / (this.seatSize + this.gap));
      
      if (this.seats[row]?.[col] === 0) {
        this.seats[row][col] = 1; // 标记选中
        this.selectedSeats.push(`${row+1}排${col+1}座`);
      } else if (this.seats[row]?.[col] === 1) {
        this.seats[row][col] = 0; // 取消选中
        this.selectedSeats = this.selectedSeats.filter(
          s => s !== `${row+1}排${col+1}座`
        );
      }
      
      this.draw(); // 重绘画布
    }
  }
};
</script>

<style scoped>
canvas {
  width: 600px;
  height: 400px;
  border: 1px solid #ccc;
}
</style>
```

**关键实现步骤说明：**

1. **数据结构**：
   - 二维数组记录座位状态（可售/已选/已售）
   - 独立数组记录选中座位信息
2. **坐标转换**：
   - 将点击坐标转换为行列索引
   - 通过`(seatSize + gap)`计算每个座位区域
3. **绘制优化**：
   - 使用`devicePixelRatio`适配高清屏
   - 仅重新绘制变化部分（示例简化使用全量重绘）
4. **交互逻辑**：
   - 点击时切换状态并更新数据
   - 过滤不可选座位（走道/已售）

**扩展建议方向**：

- 双人座/情侣座特殊样式
- 座位分区价格差异化
- 使用离屏Canvas优化绘制性能
- 添加座位编号标注

## 一般项目里面对请求 request 都会做哪些统一封装？

**1. 基础配置**

```javascript
// axios 实例化（baseURL、超时时间、跨域凭证）
const request = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  timeout: 15000,
  withCredentials: true
});
```

**2. 请求拦截器**

```javascript
request.interceptors.request.use(config => {
  // 自动携带Token
  if (store.getters.token) {
    config.headers.Authorization = `Bearer ${store.getters.token}`;
  }
  
  // 全局Loading控制（可选）
  if (!config.silent) showLoading();
  
  // 序列化GET请求数组参数（将 [1,2] 转成 1,2）
  if (config.params) {
    config.paramsSerializer = params => qs.stringify(params, { arrayFormat: 'comma' });
  }
  
  return config;
});
```

**3. 响应拦截器**

```javascript
request.interceptors.response.use(
  response => {
    // 关闭Loading（与请求拦截器配对）
    if (!response.config.silent) hideLoading();
    
    // 处理二进制流（如文件下载）
    if (response.data instanceof Blob) {
      return response;
    }
    
    // 按后端约定结构处理（示例：{ code, data, msg }）
    const { code, data, msg } = response.data;
    if (code === 200) {
      return data; // 核心数据剥离
    } else {
      return Promise.reject(new Error(msg || '请求异常'));
    }
  },
  error => {
    hideLoading();
    const { response, code } = error;
    
    // 统一错误处理
    if (code === 'ECONNABORTED') {
      error.message = '请求超时，请检查网络';
    } else if (response?.status) {
      switch(response.status) {
        case 401: 
          router.push('/login');
          break;
        case 403:
          error.message = '无权访问';
          break;
        case 500:
          error.message = '服务器异常';
          break;
      }
    }
    
    // 非静默模式显示错误提示
    if (!error.config?.silent) {
      Message.error(error.message);
    }
    return Promise.reject(error);
  }
);
```

**4. 核心功能扩展**



```javascript
// 请求取消（防重复提交）
const cancelTokenMap = new Map();
const addCancelToken = (config) => {
  const key = `${config.method}-${config.url}`;
  config.cancelToken = new axios.CancelToken(c => {
    cancelTokenMap.set(key, c);
  });
};
```

**5. 业务层封装**

```javascript
// 统一请求方法（支持自动错误捕获）
export function http(opt) {
  return request(opt).catch(err => {
    // 主动取消的请求不报错（如路由跳转时取消pending请求）
    if (!axios.isCancel(err)) {
      throw err; // 继续抛出给业务层处理
    }
  });
}

// 示例：GET请求简化版
export function get(url, params, opt = {}) {
  return http({ method: 'get', url, params, ...opt });
}

// 示例：POST请求简化版（支持FormData自动转换）
export function post(url, data, opt = {}) {
  const isFormData = data instanceof FormData;
  return http({
    method: 'post',
    url,
    data,
    headers: isFormData ? { 'Content-Type': 'multipart/form-data' } : {},
    ...opt
  });
}
```

**6. 高级功能（按需实现）**

- **请求重试**：对特定状态码（如502）自动重试

- **缓存策略**：对GET请求添加内存缓存（`new Map()`）

- **并发控制**：限制同一接口的并行请求数量

- **Mock适配**：开发环境拦截请求返回模拟数据

- **TypeScript支持**：封装泛型请求类型

  ```typescript
  export interface Response<T = any> {
    code: number;
    data: T;
    message: string;
  }
  
  export function get<T>(url: string, params?: any): Promise<Response<T>> {
    return request.get(url, { params });
  }
  ```

**封装价值**：

1. **降低重复代码**：统一处理鉴权、错误、Loading等通用逻辑
2. **规范团队协作**：强制约定请求格式和响应处理
3. **增强可维护性**：核心逻辑集中管理，修改影响可控
4. **安全增强**：统一处理XSS防范、CSRF Token等安全策略
5. **扩展性提升**：可快速集成监控上报、性能采集等能力

[一般项目里面对请求 request 都会做哪些统一封装？](https://github.com/pro-collection/interview-question/issues/498)

## XHR 和 Fetch 是否支持取消请求?

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data');
xhr.send();

// 取消请求
xhr.abort(); 

// 监听取消事件
xhr.onabort = () => {
  console.log('请求已取消');
};


const controller = new AbortController();
const signal = controller.signal;

// 发起请求时传入 signal
fetch('/api/data', { signal })
  .then(response => response.json())
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('请求已取消');
    }
  });

// 取消请求
controller.abort(); 
```



[XHR 和 Fetch 是否支持取消请求](https://github.com/pro-collection/interview-question/issues/575)

## 应用上线后，怎么通知用户刷新当前页面？

1. WebSocket 实时推送

2. 轮询版本号接口
3. 页面可见性检查优化:监听visibilitychange → 页面从隐藏切回时触发版本检查

## 设计一个前端权限控制系统?

**前端权限控制核心流程：**

**1. 权限控制维度**

- **路由权限**：控制页面访问权限
- **操作权限**：控制按钮/功能是否展示
- **数据权限**：控制接口请求参数（通常后端处理）

**2. 实现流程**

```javascript
<template>
  <!-- 按钮级权限控制 -->
  <button v-if="hasPermission('add')">新增</button>
</template>

<script>
export default {
  data() {
    return {
      // 模拟从接口获取的权限列表
      permissionList: ['view', 'edit'] 
    }
  },
  methods: {
    // 权限校验方法
    hasPermission(code) {
      return this.permissionList.includes(code);
    }
  },
  beforeCreate() {
    // 动态路由处理（需在路由配置前完成）
    const routes = asyncRoutes.filter(route => 
      this.hasPermission(route.meta?.permission)
    );
    this.$router.addRoutes(routes);
  }
};
</script>
```

**3. 完整实现步骤**

**步骤1：定义路由权限元信息**

```javascript
// router.js
const routes = [
  {
    path: '/dashboard',
    component: Dashboard,
    meta: { permission: 'view_dashboard' } // 权限标识
  },
  // ...其他路由
];

// 异步路由（需动态加载）
export const asyncRoutes = [
  {
    path: '/admin',
    component: Admin,
    meta: { permission: 'admin_access' }
  }
];
```

**步骤2：路由守卫全局拦截**

```javascript
router.beforeEach((to, from, next) => {
  // 已登录且需要权限的路由
  if (isLogin && to.meta.permission) {
    // 从Vuex获取权限列表
    const hasPermission = store.getters.permissions.includes(to.meta.permission);
    hasPermission ? next() : next('/403');
  } else {
    next();
  }
});
```

**步骤3：Vuex存储权限数据**

```javascript
// store/modules/user.js
const state = {
  permissions: []
};

const mutations = {
  SET_PERMISSIONS(state, perms) {
    state.permissions = perms;
  }
};

// 登录成功后存储权限
actions.login = async ({ commit }, creds) => {
  const { permissions } = await api.login(creds);
  commit('SET_PERMISSIONS', permissions);
};
```

**步骤4：全局权限指令**

```javascript
vue// main.js
Vue.directive('permission', {
  inserted(el, binding, vnode) {
    const { value } = binding;
    const hasPerm = store.getters.permissions.includes(value);
    
    if (!hasPerm) {
      el.parentNode?.removeChild(el); // 直接移除DOM
    }
  }
});

// 使用方式
<button v-permission="'delete'">删除</button>
```

**4. 高级优化方案**

- **权限变更监听**：WebSocket实时同步权限变化

- **按钮级组件封装**

  ```vue
  <Permission :code="'export'">
    <button>导出数据</button>
  </Permission>
  ```

- **路由自动注册**：根据权限树自动生成前端路由

- **接口权限映射**：拦截请求验证是否有权限标识

**注意事项**

1. **前端防篡改**：后端必须做二次权限验证
2. **默认拒绝原则**：未明确授权的路由默认不可访问
3. **权限粒度控制**：建议使用RBAC（角色-权限-资源）模型
4. **敏感操作日志**：关键操作记录审计日志

通过这套方案，可以实现从路由到按钮的全链路权限控制，且通过Vue指令和组件封装保持代码简洁性。

## 设计一个无限滚动加载的列表 

1. 监听滚动事件，计算触底条件
2. 触底时异步加载数据
3. 拼接新数据并更新状态
4. 处理加载状态和边界条件

```vue
<template>
  <div class="scroll-container" @scroll="handleScroll">
    <!-- 数据列表 -->
    <div v-for="item in list" :key="item.id" class="item">{{ item.content }}</div>
    
    <!-- 加载状态提示 -->
    <div v-if="isLoading">加载中...</div>
    <div v-if="isEnd">没有更多数据了</div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      list: [],       // 已加载数据
      page: 1,        // 当前页码
      limit: 20,      // 每页条数
      isLoading: false,  // 加载锁
      isEnd: false    // 数据是否全部加载完毕
    };
  },
  mounted() {
    this.loadData();  // 初始化加载
  },
  methods: {
    // 滚动事件处理
    handleScroll(e) {
      const { scrollTop, clientHeight, scrollHeight } = e.target;
      // 距离底部 50px 触发加载（防抖已内置）
      if (scrollHeight - (scrollTop + clientHeight) < 50 && !this.isLoading && !this.isEnd) {
        this.loadData();
      }
    },
    
    // 数据加载方法
    async loadData() {
      this.isLoading = true;
      try {
        // 模拟API请求
        const { data, total } = await api.getList({
          page: this.page,
          limit: this.limit
        });
        
        this.list = [...this.list, ...data];
        // 判断是否还有更多数据
        if (this.list.length >= total) this.isEnd = true;
        this.page++;
      } catch (err) {
        console.error('加载失败', err);
      } finally {
        this.isLoading = false;
      }
    }
  }
};
</script>

<style>
.scroll-container {
  height: 500px; 
  overflow-y: auto;
  border: 1px solid #eee;
}
.item { padding: 12px; border-bottom: 1px solid #ccc; }
</style>
```



## 解释JWT（JSON Web Token）的验证流程

**1. 生成阶段（用户登录）**

- 用户提交账号密码，服务端验证通过后生成 JWT，包含：

  ```javascript
  {
    // Header（算法类型）
    "alg": "HS256",  
    "typ": "JWT"
  }
  {
    // Payload（业务数据）
    "sub": "user123",  
    "exp": 1735689600  // 过期时间
  }
  ```

- **签名生成**：使用密钥（如 `HMAC-SHA256`）对 `Header + Payload` 加密，生成签名（Signature）

- 最终组合成 `Header.Base64Url + Payload.Base64Url + Signature` 格式的 Token 返回给客户端

**2. 传输阶段**

- 客户端存储 Token（通常存于 `localStorage` 或 `Cookie`）
- 后续请求通过 `Authorization: Bearer <token>` 携带 Token

**3. 验证阶段（服务端校验）**

1. **解码验证**：
   - 分割 Token 的三部分（Header/Payload/Signature）
   - Base64Url 解码 Header 和 Payload
2. **签名校验**：
   - 用相同算法和密钥重新计算签名，比对是否与传入的 Signature 一致
   - **防篡改关键**：签名不匹配则直接拒绝请求
3. **业务校验**：
   - 检查 Payload 中的 `exp`（过期时间）是否有效
   - 验证 `sub`（用户标识）等业务字段是否合法

**4. 安全扩展**

- **密钥保护**：使用非对称加密（如 RSA）时，私钥仅服务端持有
- **黑名单机制**：如需实现主动失效，需额外维护 Token 黑名单（违背 JWT 无状态设计，慎用）
- **刷新 Token**：通过独立的 Refresh Token 延长会话，降低主 Token 泄露风险

**流程示意图**

```
客户端 → 登录 → 服务端生成JWT → 客户端存储  
客户端 → 携带JWT请求 → 服务端验签 → 返回数据  
```

**注意事项**：

- JWT **默认无加密**，敏感数据需配合 HTTPS
- Token 存储需防 XSS（推荐 `HttpOnly Cookie`）
- Payload 不宜过大（影响性能）

## 如何优化首屏加载时间到1秒以内？

**一、关键渲染路径优化（Critical Rendering Path）**

1. **内联关键CSS/JS**
   - 将首屏渲染必需的CSS（如布局、字体、关键组件样式）直接内联到HTML中，避免阻塞渲染的HTTP请求。
   - 关键JS（如初始化逻辑）可内联或通过`<script defer>`加载，避免阻塞DOM解析。
   - **工具推荐**：`critters`（提取关键CSS）、`webpack-inline-critical`。
2. **异步/延迟非关键资源**
   - 非关键JS使用`async`或`defer`，非关键CSS通过`<link rel="preload" as="style" onload="this.rel='stylesheet'">`异步加载。
   - 使用`Intersection Observer`实现图片/组件的懒加载（Lazy Load）。
3. **服务端渲染（SSR）或静态生成（SSG）**
   - 通过Next.js、Nuxt.js等框架实现SSR，或使用Gatsby、Astro生成静态HTML，减少客户端渲染耗时。

**二、资源加载优化**

1. **资源压缩与格式优化**
   - **图片**：使用WebP/AVIF格式，通过`<picture>`标签兼容旧浏览器；对图标使用SVG；设置`srcset`按屏幕分辨率加载。
   - **文本资源**：启用Gzip/Brotli压缩（Nginx配置示例：`gzip on; brotli on;`）。
   - **字体**：使用`woff2`格式，通过`font-display: swap`避免阻塞渲染，子集化字体（工具：`pyftsubset`）。
2. **CDN与缓存策略**
   - 静态资源托管到CDN，启用HTTP/2或HTTP/3（QUIC协议）。
   - 设置强缓存（`Cache-Control: max-age=31536000`）和协商缓存（`ETag`）。
3. **预加载关键资源**
   - 使用`<link rel="preload">`提前加载关键字体、图片或JS模块。
   - 预连接第三方域名：`<link rel="preconnect" href="https://cdn.example.com">`.

**三、代码与构建优化**

1. **代码分割（Code Splitting）**
   - 按路由分割代码（React的`React.lazy` + `Suspense`，Vue的异步组件）。
   - 使用Webpack的`SplitChunksPlugin`提取公共依赖。
2. **Tree Shaking与Dead Code Elimination**
   - 确保ES6模块语法（`import/export`），通过Webpack/Rollup删除未使用代码。
   - 使用`babel-plugin-lodash`按需加载工具库。
3. **减少第三方依赖**
   - 替换臃肿库（如用`date-fns`代替`moment.js`）。
   - 延迟加载非核心第三方脚本（如分析工具、广告）。

**四、浏览器渲染优化**

1. **避免布局抖动（Layout Thrashing）**
   - 批量DOM操作，使用`requestAnimationFrame`调度渲染任务。
   - 用CSS `transform`和`opacity`触发GPU加速（减少重排/重绘）。
2. **优化首屏内容可见性**
   - 使用骨架屏（Skeleton Screen）占位，优先渲染文本内容。
   - 对非首屏组件使用`<div hidden>`或CSS `content-visibility: auto`。

**五、基础设施优化**

1. **边缘渲染（Edge SSR）**
   - 使用Cloudflare Workers、Vercel Edge Functions等边缘计算平台，将SSR部署到离用户最近的节点。
2. **HTTP/3与QUIC协议**
   - 启用HTTP/3（需服务器和CDN支持），通过多路复用和0-RTT加速连接。
3. **Service Worker缓存**
   - 对核心资源实现离线缓存（Workbox工具链），支持秒开二次访问。

**六、性能监控与测试**

1. **性能指标分析**
   - 使用Lighthouse、WebPageTest测量FCP（First Contentful Paint）、LCP（Largest Contentful Paint）。
   - 通过Chrome DevTools的Performance面板分析长任务（Long Tasks）。
2. **真实用户监控（RUM）**
   - 部署Sentry、New Relic等工具监控真实用户的性能数据。

**极端优化案例（参考）**

- **Vue/Nuxt项目**：SSR + 预渲染静态页面 + 内联关键CSS + Brotli压缩 + CDN，首屏时间可压缩至400-600ms。
- **React/Next.js项目**：使用`next/dynamic`动态加载非首屏组件 + 图片懒加载 + 边缘渲染，首屏时间可达800ms以内。

**总结**

优化到1秒内的核心思路：

1. **减少关键资源体积**（HTML/CSS/JS控制在100KB以内）。
2. **最小化网络往返次数**（通过内联、预加载、HTTP/2多路复用）。
3. **优先渲染可见内容**（SSR/骨架屏 + 懒加载）。
4. **利用现代浏览器特性**（如HTTP/3、Service Worker）。

需根据实际项目通过性能分析工具定位瓶颈，针对性优化。

## vue如何封装一个支持响应式更新的富文本编辑器?

[封装 Quill 编辑器用于 Vue 3](https://juejin.cn/post/7429514987645435915)

## 请求会弹出一个toast,如何保证批量请求失败，只弹出一个toast?

要保证批量请求失败只弹出一个toast,但又不能不同消息类型都弹出一个toast,所以需要用缓存池保证当前弹出的toast类型唯一

```javascript
// utils/request.js  
const errorMap = new Map()  // 错误缓存池  
const ERROR_TTL = 5000      // 相同错误5秒内不重复提示  

axios.interceptors.response.use(null, (error) => {  
  // 1. 生成错误标识（示例逻辑）  
  const errorKey = error.response?.status || error.code || error.message  

  // 2. 判断是否需要展示  
  if (!errorMap.has(errorKey) {  
    showToast(error.message)  
    errorMap.set(errorKey, Date.now())  

    // 3. 设置过期时间  
    setTimeout(() => {  
      errorMap.delete(errorKey)  
    }, ERROR_TTL)  
  }  

  return Promise.reject(error)  
})  
```



## 如何做好前端的监控方案？

前端监控需覆盖 **错误追踪**、**性能指标**、**用户行为** 三大维度，核心方案如下：

1. **错误监控**
   - 全局捕获：`window.onerror` + `unhandledrejection`
   - 框架集成：Vue/React错误边界（Error Boundary）
   - 资源异常：监听`<img><script>`的`onerror`事件
2. **性能监控**
   - 关键指标：通过`Performance API`采集`FP/FCP/LCP/FID/CLS`
   - 接口耗时：拦截AJAX/Fetch记录响应时间与成功率
3. **用户行为**
   - PV/UV：路由切换监听（Hash/History API）
   - 点击热图：记录点击坐标与DOM路径
   - 自定义事件：关键操作埋点（如按钮点击）
4. **数据上报**
   - 节流合并：使用`sendBeacon`或`requestIdleCallback`
   - 失败重试：本地存储失败日志，定时重发

## px如何转rem?

**核心原理**

- **`rem` 单位**：相对于根元素（`<html>`）的 `font-size`。例如，若根字体为 `16px`，则 `1rem = 16px`。
- **转换公式**：rem值=px值基准字体大小rem值=基准字体大小px值

转换主要分三步：

1. **设置基准**：在HTML根元素定义 `font-size: 62.5%`（浏览器默认16px → 1rem=10px）
2. **换算规则**：设计稿px值 ÷ 基准值（如10）→ 例：24px = 2.4rem
3. **自动转换**：用PostCSS插件`postcss-pxtorem`自动编译（配置示例）：

```javascript
// postcss.config.js  
module.exports = {  
  plugins: {  
    'postcss-pxtorem': {  
      rootValue: 10,    // 基准值  
      propList: ['*'],  // 转换所有属性  
      selectorBlackList: ['.norem'] // 黑名单类不转换  
    }  
  }  
}  
```

## 如何实现面板折叠功能？

[使css高度auto支持过渡动画](https://lsj97.com/posts/article/%E4%BD%BFcss%E9%AB%98%E5%BA%A6auto%E6%94%AF%E6%8C%81%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/)

## 前端应用如何做国际化？

**回答：**
前端国际化（i18n）的核心步骤：

1. **多语言资源管理**：用 JSON 文件按语言（如 `en.json`、`zh-CN.json`）组织文案，通过工具（如 `i18next`、`vue-i18n`）动态加载。
2. **语言切换**：通过 URL 参数、本地存储或全局状态（如 Redux、Vuex）传递语言标识（如 `en-US`），触发页面渲染更新。
3. **动态内容处理**：
   - 文本：使用键值替换（如 `t('key')`），支持插值、复数形式。
   - 日期/数字：用 `Intl` API（如 `Intl.DateTimeFormat`）或库（如 `date-fns`）按语言格式化。
4. **优化实践**：提取未翻译文本（如 `i18n-extract`），按需加载语言包，兼容 RTL 语言（如阿拉伯语）。

**工具推荐**：`i18next`、`react-intl`、`vue-i18n`，结合构建工具（如 Webpack）拆分语言包。

## 用户访问页面白屏，如何排查？

用户访问页面白屏可能由多种原因引起，以下是一些可能的原因和排查步骤:

1. **网络问题**:用户的网络连接可能存在问题，无法正确加载页面内容。可以要求用户检查网络连接，或者自己尝试在不同网络环境下测试页面的加载情况。

2. **服务端问题**:服务器未正确响应用户请求，导致页面无法加载。可以检查服务器的状态、日志和错2误信息，查看是否有任何异常。同时，可以确认服务器上的相关服务是否正常运行。

3. **前端代码问题**:页面的前端代码可能存在错误或异常，导致页面无法正常渲染。可以检查浏览器的开发者工具，查看是否有任何错误信息或警告。同时，可以尝试将页面的JavaScript、CSs和HTML代码分离出来进行单独测试，以确定具体的问题所在。

4. **浏览器兼容性问题**:不同浏览器对于某些代码的支持可能不一致，导致页面在某些浏览器中无法正.常加载。可以尝试在不同浏览器中测试页面的加载情况，同时使用浏览器的开发者工具检查是否有任何错误或警告。

5. **第三方资源加载问题**:页面可能依赖于某些第三方资源(如外部脚本、样式表等)，如果这些资源
   无法加载，可能导致页面白屏。可以检查网络请求是否正常，是否有任何资源加载失败的情况。

6. **缓存问题**:浏览器可能在缓存中保存了旧版本的页面或资源，导致新版本无法加载。可以尝试清除6.
   浏览器缓存，或者通过添加随机参数或修改文件名的方式强制浏览器重新加载页面和资源。

7. **其他可能原因**:页面白屏问题还可能由于安全策略(如CSP、CORS等)限制、跨域问题、DNS解析问题等引起。可以使用浏览器的开发者工具检查网络请求和错误信息，查找可能的问题。

在排查问题时，可以根据具体情况逐步进行排查，并结合浏览器的开发者工具、服务器日志等工具来辅助定位问题所在，并且可以与用户进行进一步沟通以获取更多信息。如果问题无法解决，可以寻求专业的技术支持或咨询。

## 站点如何防止爬虫？

1. **基础防护**：设置 `robots.txt` 限制合规爬虫，后端校验请求头（如 `User-Agent`、`Referer`）。
2. **动态干扰**：页面注入随机噪声数据（如隐藏假链接），频繁操作触发验证码。
3. **反自动化**：关键接口添加加密参数（如签名 `Token`），前端点击行为校验（如轨迹监测）。
4. **深度防御**：IP 限流/黑名单，使用反爬服务（如 Cloudflare Bot Management）。

## 你是如何从零到一搭建一个项目的？

**一、需求分析与技术选型**

1. **明确需求**
   - 项目类型：SPA、SSR、静态网站、移动端H5？
   - 功能模块：是否需要路由、状态管理、数据可视化等？
   - 目标用户：兼容性要求（浏览器、分辨率、移动端适配）？
2. **技术选型**
   - **框架**：React（生态丰富）、Vue（轻量易上手）、Svelte（高性能）或纯原生。
   - **构建工具**：Vite（极速热更新）、Webpack（高度定制化）、Rollup（库开发）。
   - **状态管理**：Redux（复杂场景）、Zustand（轻量）、Pinia（Vue专属）。
   - **CSS方案**：CSS-in-JS（Styled-components）、Utility-First（Tailwind CSS）、预处理器（Sass/Less）。
   - **其他**：TypeScript（类型安全）、测试框架（Jest + Testing Library）、E2E工具（Cypress）。

**二、初始化项目**

1. **脚手架创建**
2. **安装核心依赖**

**三、项目结构设计**

**四、工程化配置**

1. **别名配置（vite.config.ts）**

2. **代码规范**

- ESLint + Airbnb规范：检查语法错误。
- Prettier：统一代码风格。
- Husky + lint-staged：提交前自动格式化。

3. **环境变量**

- 区分开发、测试、生产环境（`.env.development`, `.env.production`）。
- 敏感数据通过VITE_前缀暴露给客户端（Vite专用）。

**五、开发与联调**

1. **Mock数据**
   - 使用 Mock.js 或 json-server 快速模拟接口。
   - 示例（json-server）：
2. **代理配置（解决跨域）**

**六、性能优化**

1. **构建优化**
   - 代码分割（动态import()、路由懒加载）。
   - 压缩资源：Terser压缩JS、CSSNano压缩CSS。
   - 静态资源CDN托管。
2. **运行时优化**
   - 虚拟列表（react-window）优化长列表渲染。
   - 图片懒加载（Intersection Observer API）。
   - Web Worker处理复杂计算。

**七、部署与监控**

1. **部署流程**
   - CI/CD工具：GitHub Actions、Jenkins。
   - 容器化：Docker + Nginx（配置Gzip、缓存策略）
2. **监控与统计**
   - 错误收集：Sentry、Fundebug。
   - 性能分析：Google Lighthouse、Web Vitals。
   - 用户行为：Google Analytics、Hotjar。

**八、维护与迭代**

1. **文档管理**
   - 使用 Storybook 或 Docusaurus 编写组件文档。
2. **依赖更新**
   - 定期运行 `npm outdated` 升级依赖版本。
3. **错误处理**
   - 全局异常捕获（React Error Boundary）。

**关键注意事项**

- **版本控制**：合理设计 Git 分支策略（Git Flow/GitHub Flow）。
- **SEO优化**：SPA项目需结合预渲染（prerender-spa-plugin）或SSR。
- **安全防护**：XSS过滤、CSP配置、敏感信息加密。

## 实现视差滚动效果

实现视差滚动核心思路是**多层元素以不同速率滚动**，常用方法：

1. **纯CSS实现**（简单场景）：

   ```CSS
   .parallax-container {  
     perspective: 1px; /* 透视效果 */  
     overflow-x: hidden;  
     height: 100vh;  
   }  
   .layer {  
     transform-style: preserve-3d;  
   }  
   .layer-slow {  
     transform: translateZ(-2px) scale(3); /* 滚动更慢 */  
   }  
   .layer-fast {  
     transform: translateZ(1px) scale(0.5); /* 滚动更快 */  
   }  
   ```

2. **JavaScript动态控制**（灵活性强）：

   ```javascript
   window.addEventListener('scroll', () => {  
     const scrolled = window.pageYOffset;  
     document.querySelector('.bg-layer').style.transform =   
       `translateY(${scrolled * 0.5}px)`; // 背景层慢速移动  
     document.querySelector('.text-layer').style.transform =   
       `translateY(${scrolled * 1.2}px)`; // 文字层快速移动  
   });  
   ```

3. **使用库（如Parallax.js）**（快速集成）：

   ```HTML
   <div data-parallax="scroll" data-image-src="bg.jpg"></div>  
   <script src="parallax.min.js"></script>  
   ```

## 说说Vue封装组件的流程，需要注意些什么？你会有些什么样的原则？

- 封装Vue组件一般分为以下步骤和注意事项：

  流程：

  1. 明确职责边界，拆分可复用功能
  2. 定义props/emit接口，做好参数校验
  3. 使用插槽机制保持扩展性
  4. 添加必要的样式隔离（scoped）
  5. 编写组件文档和使用示例

  注意事项：

  - 保持单一职责原则
  - 避免直接操作父组件DOM
  - 合理处理边界情况（空状态、加载态等）
  - 提供清晰的接口文档

  设计原则：

  1. 高内聚低耦合
  2. 受控组件优先
  3. 合理的默认值配置
  4. 良好的TS类型支持
  5. 兼容性考虑（如v-model双向绑定）

## 如何判断当前脚本运行在浏览器还是 node 环境中？

```javascript
// 判断浏览器环境
const isBrowser = typeof window !== 'undefined' 
  && typeof window.document !== 'undefined'

// 判断Node环境
const isNode = typeof process !== 'undefined' 
  && process.versions 
  && process.versions.node
```



## 你在项目中遇到过哪些性能瓶颈？是如何解决的？

在项目中遇到的典型性能瓶颈及解决方案：

1. **首屏加载慢**：
   - **问题**：资源过大（如图片/JS未压缩），接口串行请求。
   - **解决**：
     - 代码分割（`Vue Router懒加载`）
     - 图片懒加载 + WebP格式
     - 接口请求合并 + HTTP2多路复用
2. **长列表渲染卡顿**：
   - **问题**：DOM节点过多导致重绘耗时。
   - **解决**：
     - 虚拟滚动（`vue-virtual-scroller`）
     - 分页加载 + 骨架屏占位
3. **内存泄漏**：
   - **问题**：全局事件监听、定时器未销毁（如弹窗组件多次挂载）。
   - **解决**：
     - 使用`beforeUnmount`移除事件/定时器
     - Chrome DevTools Memory面板定位泄漏源
4. **高频交互卡顿**：
   - **问题**：频繁触发`resize`/`scroll`导致函数重复执行。
   - **解决**：
     - 防抖/节流（`lodash.throttle`）
     - 使用`requestAnimationFrame`优化动画
5. **接口重复请求**：
   - **问题**：按钮快速点击导致重复提交。
   - **解决**：
     - 请求锁（`isLoading`状态拦截）
     - 客户端缓存（如`localStorage`短期缓存）

**优化工具**：

- Lighthouse分析性能指标
- Webpack Bundle Analyzer分析包体积
- Vue DevTools追踪组件渲染耗时

## 如何监控页面卡顿？

监控页面卡顿的核心方法：

1. **FPS检测**：通过`requestAnimationFrame`计算帧率，持续低于50FPS视为卡顿。
2. **长任务监听**：用`PerformanceObserver`捕获超过50ms的Long Tasks（主线程阻塞）。
3. **用户交互延迟**：监听点击/输入事件，统计响应时间（如从`pointerdown`到`next paint`）。
4. **框架工具**：Vue/React DevTools定位渲染耗时组件，Chrome Performance分析调用栈。

**示例代码（长任务上报）**：

```javascript
const observer = new PerformanceObserver(list => {  
  list.getEntries().forEach(entry => {  
    if (entry.duration > 50) {  
      console.log('卡顿：', entry);  
      // 上报至监控系统  
    }  
  });  
});  
observer.observe({ entryTypes: ['longtask'] });  
```

## 如何自定义鼠标右键菜单？

实现自定义右键菜单的核心步骤：

1. **阻止默认右键菜单**
   监听 `contextmenu` 事件，调用 `e.preventDefault()` 禁用浏览器默认菜单。

2. **动态创建菜单元素**
   用 JavaScript 动态生成一个 `div`，设置 CSS 样式（如 `position: absolute`、`z-index` 层级）。

3. **定位菜单**
   根据鼠标点击位置（`e.clientX` 和 `e.clientY`）设置菜单的 `left` 和 `top`，确保不超出视口边界。

4. **添加菜单项与交互**
   在菜单内插入按钮或列表项，绑定点击事件。例如：

   ```javascript
   const menu = document.createElement('div');
   menu.innerHTML = '<button>复制</button><button>粘贴</button>';
   menu.querySelector('button').addEventListener('click', handleCopy);
   ```

5. **关闭菜单逻辑**
   监听 `document` 的点击事件，点击非菜单区域时隐藏菜单。

**示例代码片段：**

```javascript
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const menu = document.getElementById('custom-menu');
  menu.style.left = `${e.pageX}px`;
  menu.style.top = `${e.pageY}px`;
  menu.style.display = 'block';
});

document.addEventListener('click', () => {
  document.getElementById('custom-menu').style.display = 'none';
});
```

**关键点：**

- 使用 `position: fixed` 防止滚动偏移
- 考虑边缘位置自适应（如贴近视口右/底部时反向定位）
- 通过事件委托优化菜单项的事件绑定

**扩展：** 结合业务动态渲染菜单项，或集成第三方库（如 `context-menu`）提升交互体验。

## 如果要设计一个转盘组件，你会考虑哪些方面？有哪些是需要和业务方确认的技术细节？另外，如何从前端的角度进行防刷？

**一、核心设计考虑因素**

1. **UI 与交互设计**

   - **视觉呈现**：转盘扇形区域布局（等分/不等分）、动态光影效果、指针/中心点设计
   - **动画效果**：旋转惯性模拟（缓动函数）、停止位置精准对齐、多段式动画（加速 → 匀速 → 减速）
   - **响应式适配**：不同屏幕尺寸下的比例缩放、横竖屏切换时的重绘策略
   - **音效反馈**：启动音效、旋转背景音、停止提示音

2. **技术实现方案**

   - **动画引擎选择**：

     - CSS3 Transform + Transition（轻量级简单场景）
     - GSAP（复杂缓动控制）
     - Canvas（高性能复杂动画）

   - **停止位置计算**：

     ```javascript
     // 示例：根据后端返回的奖品索引计算停止角度
     const stopAngle = initialAngle + (targetIndex * sectorAngle) + 360 * 5; // 多转5圈
     ```

   - **数据驱动**：动态奖品列表渲染（Vue/React 数据绑定）

3. **异常处理**

   - 网络中断时的降级提示
   - 奖品加载失败后的占位图处理
   - 抽奖接口限流后的友好提示

**二、需与业务方确认的技术细节**

| **分类**     | **需确认内容**                                               |
| :----------- | :----------------------------------------------------------- |
| **抽奖规则** | 1. 中奖概率计算方式（前端静态配置/后端动态下发） 2. 用户资格判断条件（登录态、积分、每日次数限制） |
| **奖品逻辑** | 1. 奖品类型（实物/虚拟） 2. 多级奖品嵌套逻辑（如先抽奖池再抽具体奖品） |
| **交互流程** | 1. 抽奖结果展示方式（即时弹窗/独立页面） 2. 重复抽奖冷却时间 |
| **数据对接** | 1. 奖品列表接口格式 2. 抽奖动作的API触发时机（动画前预请求/动画后请求） |
| **安全要求** | 1. 是否需要前端加密参数 2. 防刷策略的严格程度                |

**三、前端防刷方案**

1. **基础防护层**

   - **频率限制**：

     ```javascript
     let isClickable = true;
     startButton.addEventListener('click', () => {
       if (!isClickable) return;
       isClickable = false;
       setTimeout(() => { isClickable = true; }, 3000); // 3秒冷却
     });
     ```

   - **操作验证**：

     - 添加图形验证码（如旋转拼图）
     - 行为验证（检测连续点击间隔是否异常）

2. **请求安全层**

   - **参数混淆**：

     - 使用动态 token（由后端生成临时令牌）
     - 时间戳 + 随机数签名（防止重放攻击）

   - **加密传输**：

     ```javascript
     // 示例：使用 AES 加密抽奖请求参数
     const encryptedData = CryptoJS.AES.encrypt(JSON.stringify(data), secretKey).toString();
     ```

3. **环境检测层**

   - **设备指纹**：

     - 通过 `navigator.userAgent` + Canvas 指纹生成唯一标识

   - **脚本检测**：

     - 检测常见自动化工具特征（如 Puppeteer 的 Headless 模式）

     ```javascript
     const isHeadless = !('onshow' in window) || navigator.webdriver; 
     if (isHeadless) blockRequest();
     ```

4. **日志监控层**

   - 上报用户点击坐标轨迹（检测机械式点击模式）
   - 记录抽奖时间间隔分布（识别高频异常行为）

**四、推荐技术组合**

| **模块**   | **推荐方案**                                                 |
| :--------- | :----------------------------------------------------------- |
| 动画引擎   | GSAP + CSS Custom Properties（精准控制贝塞尔曲线）           |
| 数据通信   | Axios 拦截器 + JWT 动态令牌                                  |
| 防刷基础库 | @fingerprintjs/fingerprintjs（设备指纹） + crypto-js（参数加密） |
| 异常监控   | Sentry（错误日志） + 自定义行为分析埋点                      |

**五、注意事项**

1. **动画性能**：
   - 避免频繁重绘，使用 `will-change: transform` 开启 GPU 加速
   - 采用 `requestAnimationFrame` 替代 setTimeout 实现平滑动画
2. **安全兜底**：
   - 前端防刷仅为辅助手段，核心防护需依赖后端（如IP限流、用户行为分析模型）
3. **法律合规**：
   - 明确公示中奖概率（需符合当地法律法规要求）

## 写出一个函数trans，将数字转换成汉语的输出

```javascript
 function toChineseNumber(num) {
      //  四位四位的进行分割
      const parts = num
        .toString()
        .replace(/(?=(\d{4})+$)/g, ',')
        .split(',')
        .filter(Boolean)
 
      const map = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九']
      const units = ['', '十', '百', '千']
      // 把连续的零给去掉 合并为1个零  当零在末尾的时候去掉
      function _handleZero(str) {
        return str.replace(/零+/g, '零').replace(/零$/, '')
      }
      function _transform(n) {
        let result = ''
        for (let i = 0; i < n.length; i++) {
          const c = map[n[i]]
          let u = units[n.length - i - 1]
          if (c === '零') {
            u = ''
          }
          result += c + u
        }
        result = _handleZero(result)
        return result
      }
      const bigUnits = ['', '万', '亿']
      let result = ''
      for (let i = 0; i < parts.length; i++) {
        const p = parts[i]
        const c = _transform(p)
        const u = bigUnits[parts.length - i - 1]
        if (c === '') {
          result += '零'
          continue
        }
        result += c + u
      }
      result = _handleZero(result)
      return result
    }

```

## 怎么预防用户快速连续点击，造成数据多次提交？

- css设置 `pointer-events` 为 `none`
- 增加变量控制，当变量满足条件时才执行点击事件的后续代码（比如给按钮的点击事件增加防抖）
- 如果按钮使用 button 标签实现，可以使用 `disabled` 属性
- 加遮罩层，比如一个全屏的loading，避免触发按钮的点击事件

## 有一个新的前端项目需要部署到线上，你有什么思路？

1. **项目准备阶段**：

- **检查项目构建配置**：确保项目的构建配置文件（如 `webpack.config.js` 或 `vite.config.js`）已准备好并针对生产环境进行了优化（如代码压缩、Tree Shaking 等）。
- **环境变量**：配置环境变量，确保生产环境下的 API 地址和其他配置项正确。
- **依赖检查**：确保所有依赖项在 `package.json` 中已定义并通过 `npm install` 正确安装。

2. **构建项目**：

- **打包构建**：使用构建命令（如 `npm run build`）生成生产环境的静态文件。
- **打包产物检查**：检查打包后的文件，确保体积、性能、加载顺序等方面都正常。检查生成的 `index.html`、CSS 和 JS 文件等是否按预期生成。
- 也可使用流水线进行构建

3. **选择部署平台**：

- **静态服务器（Nginx/Apache）**：如需要自托管，选择 Nginx 或 Apache 来托管静态文件。为单页面应用（SPA）做好路由回退配置。
- **云服务平台**：如 AWS S3、阿里云 OSS 等静态托管服务。
- **部署平台**：如 Vercel、Netlify，这类平台支持自动化部署，并提供 CI/CD 集成。

4. **上传构建文件**：

- 自托管服务器：
  - 通过 FTP、SCP 或 Rsync 上传打包后的静态文件到服务器上的指定目录。
  - 如果使用 Docker，可以通过 Docker 容器化前端应用，并将其部署到云服务器上。
- 云服务平台：
  - 使用对应的 SDK 或 CLI 工具（如 AWS CLI、OSS CLI）上传文件到云存储。
- 平台自动化部署：
  - 如使用 Vercel 或 Netlify，可连接 Git 仓库，设置自动化构建和部署。

5. **配置服务器**：

- **Nginx 配置**：配置 Nginx 或其他服务器，指向项目的根目录，并处理 SPA 的路由问题。
- **缓存优化**：配置 HTTP 缓存策略（如 `Cache-Control` 和 `ETag`），优化文件的缓存和加载速度。
- **CDN 配置**：如果有全球用户，考虑使用 CDN 分发静态文件，提升加载速度。

6. **设置域名和 HTTPS**：

- **绑定域名**：确保域名已解析到服务器的 IP 地址或绑定到云平台。
- **HTTPS 支持**：通过 Let’s Encrypt 或购买 SSL 证书，确保项目可以通过 HTTPS 访问。

7. **自动化部署（可选）**：

- **CI/CD 集成**：集成 CI/CD 工具（如 GitHub Actions、Jenkins），自动完成构建、测试和部署流程。
- **钩子配置**：如使用 Vercel/Netlify 等平台，配置 Webhooks，确保每次代码变更后自动部署。

8. **测试和监控**：

- **测试部署环境**：在生产环境下进行全面的功能测试，确保所有 API 调用、页面加载和用户交互正常。
- **性能监控**：引入监控工具（如 Google Analytics、Sentry）监控性能和错误日志。
- **定期更新和维护**：定期检查项目性能、修复潜在问题，并根据业务需求进行定期更新。

## Vue实现下拉菜单,要求点击区域外能关闭组件

在 Vue 中实现点击外部关闭下拉菜单，可以通过以下步骤实现：

```javascript
<template>
  <div class="dropdown" v-click-outside="close">
    <button @click="toggle">打开菜单</button>
    <div v-show="isOpen" class="dropdown-menu">
      <!-- 菜单内容 -->
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return { isOpen: false }
  },
  methods: {
    toggle() {
      this.isOpen = !this.isOpen
    },
    close() {
      if (this.isOpen) this.isOpen = false
    }
  },
  directives: {
    // 自定义指令检测外部点击
    'click-outside': {
      bind(el, binding, vnode) {
        el.clickOutsideEvent = (event) => {
          if (!(el === event.target || el.contains(event.target))) {
            vnode.context[binding.expression]()
          }
        }
        document.addEventListener('click', el.clickOutsideEvent)
      },
      unbind(el) {
        document.removeEventListener('click', el.clickOutsideEvent)
      }
    }
  }
}
</script>
```

**核心要点**：

1. 使用自定义指令 `v-click-outside` 检测外部点击
2. 通过事件委托绑定全局点击监听
3. 在组件销毁时移除事件监听（内存管理）
4. 使用 `contains()` 方法判断点击目标是否在容器内

**实现优势**：

- 指令可复用
- 自动处理事件解绑
- 兼容动态生成的DOM元素

## 如何封装一个请求，让其多次调用的时候，实际只发起一个请求的时候，返回同一份结果？

可以通过 **请求缓存池 + Promise 复用** 实现：

```javascript
const cache = new Map();

function createSingletonRequest(fn) {
  return async (...args) => {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key); // 返回已有 Promise
    }

    const promise = fn(...args).finally(() => {
      cache.delete(key); // 请求完成清理缓存
    });

    cache.set(key, promise);
    return promise;
  };
}

// 使用示例
const request = createSingletonRequest(axios.get);
request('/api/data'); // 实际发送请求
request('/api/data'); // 返回同一 Promise
```

**核心原理**：

1. 用 `Map` 存储请求标识与对应 Promise
2. 相同参数的请求返回缓存中的 Promise
3. `finally` 确保请求结束后清除缓存

**优势**：

- 避免重复请求
- 自动处理并发场景
- 适配任意请求库（Axios/Fetch 等）

## 如何在浏览器中实现 PDF 文件的预览？

1. **原生嵌入**

```html
<embed :src="pdfUrl" type="application/pdf" width="100%" height="600px">
```

*特点*：浏览器自带预览，但样式不可控，移动端兼容性差

2. **PDF.js 方案**

```javascript
// 安装 pdfjs-dist 后
import * as pdfjsLib from 'pdfjs-dist/webpack';

async function renderPDF(url, canvasContainer) {
  const loadingTask = pdfjsLib.getDocument(url);
  const pdf = await loadingTask.promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({ scale: 1.5 });
  const canvas = document.createElement('canvas');
  canvas.height = viewport.height;
  canvas.width = viewport.width;
  canvasContainer.appendChild(canvas);
  page.render({ canvasContext: canvas.getContext('2d'), viewport });
}
```

*优势*：完全自定义渲染，支持文本选择/搜索，需处理分页加载

3. **服务端转换**
通过后端将PDF转为图片序列（如用libreoffice/ghostscript），前端用swiper等组件展示
*适用场景*：需要严格保持跨平台样式一致

## 如何监控前端页面的崩溃？

监控前端页面的崩溃通常涉及捕获和报告 JavaScript 错误、性能问题以及页面状态。

以下是一些常见的方法和工具来实现这些监控：

**1. 使用 `window.onerror`**

- **定义**：`window.onerror` 是一个全局事件处理程序，用于捕获 JavaScript 执行时的错误。

- 实现

  ：

  ```javascript
  window.onerror = function(message, source, lineno, colno, error) {
    // 处理错误信息，例如发送到服务器
    console.error('Error captured:', { message, source, lineno, colno, error });
    // 可以通过 HTTP 请求将错误信息发送到日志服务器
  };
  ```

**2. 使用 `window.addEventListener('unhandledrejection')`**

- **定义**：捕获未处理的 Promise 拒绝（rejections）。

- 实现

  ：

  ```javascript
  window.addEventListener('unhandledrejection', function(event) {
    // 处理 Promise 拒绝，例如发送到服务器
    console.error('Unhandled rejection:', event.reason);
    // 可以通过 HTTP 请求将错误信息发送到日志服务器
  });
  ```

**3. 使用 `try...catch`**

- **定义**：在可能出现错误的代码块中使用 `try...catch` 捕获异常。

- 实现

  ：

  ```javascript
  try {
    // 可能会抛出错误的代码
  } catch (error) {
    // 处理错误，例如发送到服务器
    console.error('Caught error:', error);
    // 可以通过 HTTP 请求将错误信息发送到日志服务器
  }
  ```

**4. 使用错误监控工具**

- **Sentry**：捕获前端错误并提供详细的堆栈跟踪和上下文信息。
- **New Relic**：提供全面的前端性能监控和错误捕获。
- **Rollbar**：实时捕获和报告 JavaScript 错误和异常。
- **LogRocket**：记录用户会话并捕获前端错误。

**5. 性能监控和日志**

- **浏览器开发者工具**：使用 DevTools 监控网络请求、性能和资源使用。
- **Web Vitals**：跟踪核心 Web Vitals 指标（如 LCP、FID、CLS）来发现性能问题。
- **Custom Logging**：自定义日志记录功能，将应用程序状态和错误发送到日志服务器。

**6. 网络请求监控**

- **自定义错误日志**：在 JavaScript 错误处理程序中，通过 HTTP 请求将错误信息发送到远程服务器进行存储和分析。
- **日志服务器**：维护一个后端日志服务器，用于存储和分析前端错误和崩溃数据。



## 实现一个批量请求函数，要求能够限制并发量

```javascript
function multiRequest(urls = [], maxNum) {
    // 请求总数量
    const sum = urls.length;
    // 根据请求数量创建一个数组来保存请求的结果
    const result = new Array(sum).fill(false);
    // 当前完成的数量
    let count = 0;

    return new Promise((resolve, reject) => {
        // 请求maxNum个
        while (count < maxNum) {
            next();
        }
        function next() {
            let current = count++;
            // 处理边界条件
            if (current >= sum) {
                // 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回
                !result.includes(false) && resolve(result);
                return;
            }
            const url = urls[current];
            console.log(`开始 ${current}`, new Date().toLocaleString());
            fetch(url).then(res => {
                // 保存请求结果
                result[current] = res;
                console.log(`完成 ${current}`, new Date().toLocaleString());
                // 请求没有全部完成, 就递归
                if (current < sum) {
                    next();
                }
            }).catch(err => {
                console.log(`结束 ${current}`, new Date().toLocaleString());
                result[current] = err;
                // 请求没有全部完成, 就递归
                if (current < sum) {
                    next();
                }
            });
        }
    });
}

const url = `https://www.baidu.com/s?wd=javascript`;
const urls = new Array(100).fill(url);

(async () => {
    const res = await multiRequest(urls, 10);
    console.log(res);
})();
```

