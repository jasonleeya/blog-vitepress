---
category: 网络
order: 10
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/article/前端面试题合集/read.html">
</nav-head>

# 网络

## HTTP/1.1 与 HTTP/2 的核心区别

- **多路复用**：HTTP/2 允许在一个 TCP 连接上并行传输多个请求/响应，解决队头阻塞问题12。
- **二进制分帧**：数据以二进制帧传输，提升解析效率16。
- **头部压缩**：HPACK 算法减少冗余头部传输16。
- **服务器推送**：服务端可主动推送资源（如 CSS/JS），减少请求延迟16。

## HTTP 2.0 和 3.0 有什么区别？

- HTTP/2.0 采用二进制格式传输数据，采用多路复用技术，可以只通过一个 TCP 连接传输所有的请求数据。采用头部压缩技术，解决了 HTTP/1.0 的 header 里携带的内容过大的问题。但是如果在传输的过程中存在丢包的情况的话，那么整个 TCP 就得重新传输，后面资源就会被阻塞。
- HTTP/3.0 放弃了 TCP 协议而是改用了 QUIC 协议，此协议基于传输层 UDP 协议。UDP 协议无需三次握手四次挥手，所以传输速率更高。并且它改善了多路复用产生的问题，如果出现丢包的情况，不需要整个重新发送，只需要重发丢掉的包就可以。HTTP/3.0 具有更低的延迟，效率甚至要比 HTTP/1.1 快 3 倍以上。 

## 你知道哪些常见的网络协议？

## 解释 HTTP/3 的底层协议 QUIC 的核心优势

## HTTP 和 HTTPS 有什么区别？



1. `HTTPS` 协议需要到 `CA` （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。

2. `HTTP` 是超文本传输协议，信息是明文传输，`HTTPS` 则是具有安全性的 `SSL` 加密传输协议。

3. `HTTP` 和 `HTTPS` 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是`443`。

4. `HTTP` 的连接很简单，是无状态的。`HTTPS` 协议是由 `SSL+HTTP` 协议构建的可进行加密传输、身份认证的网络协议，比 `HTTP` 协议安全。

## 简述 HTTPS 的加密原理和优点

HTTPS 通过 **SSL/TLS 协议**实现传输层加密，采用**混合加密机制**（非对称加密交换密钥 + 对称加密传输数据），确保数据机密性、完整性和身份认证，解决 HTTP 明文传输的安全风险。  

**加密原理**  

1. **混合加密机制**：  
   - **非对称加密**（如 RSA/ECC）：  
     - 客户端通过服务器公钥加密随机生成的**对称密钥**，安全传输给服务器；  
     - 服务器用私钥解密获取对称密钥，后续通信使用该密钥对称加密数据。  
   - **对称加密**（如 AES）：  
     - 双方使用共享密钥加解密数据，效率高，适合大数据量传输。  

2. **数字证书与身份认证**：  
   - **CA 证书**：服务器向权威机构（CA）申请证书，包含公钥、域名、有效期等信息；  
   - **证书验证**：客户端验证证书合法性（是否过期、域名匹配、CA 签名可信），防止中间人攻击。  

3. **完整性校验**：  
   - 使用 **HMAC** 或 **消息摘要算法**（如 SHA-256）生成数据指纹，确保传输内容未被篡改。  

**TLS 握手流程（简化版）**  

1. **Client Hello**：客户端发送支持的加密套件列表和随机数；  
2. **Server Hello**：服务器选择加密套件并返回证书和随机数；  
3. **密钥交换**：客户端验证证书，生成预主密钥并用服务器公钥加密发送；  
4. **生成会话密钥**：双方基于随机数和预主密钥生成对称密钥；  
5. **加密通信**：使用对称密钥加密后续数据传输。  

**核心优点**  

1. **数据机密性**：加密传输防止窃听（如抓包工具无法解析敏感信息）；  
2. **身份认证**：CA 证书验证服务器身份，避免钓鱼网站；  
3. **数据完整性**：校验机制确保数据未被篡改（如植入广告或恶意代码）；  
4. **SEO 优化**：搜索引擎优先收录 HTTPS 网站；  
5. **合规要求**：满足 GDPR、PCI DSS 等数据安全法规。  

**对比 HTTP 的改进**  

| **维度**     | **HTTP**             | **HTTPS**                           |
| ------------ | -------------------- | ----------------------------------- |
| **传输方式** | 明文传输             | 加密传输                            |
| **默认端口** | 80                   | 443                                 |
| **安全性**   | 易被劫持、篡改、监听 | 防窃听、防篡改、身份认证            |
| **性能开销** | 无                   | 增加握手延迟（可通过 TLS 1.3 优化） |

**应用场景**  

- 用户登录、支付交易等敏感操作；  
- 企业内网 API 接口通信；  
- 所有现代浏览器强制要求的 Web 服务（如 PWA、WebRTC）。  

**总结**：HTTPS 是 Web 安全的基石，通过混合加密与证书体系，解决了 HTTP 的三大安全隐患（窃听、篡改、伪装），是构建可信网络服务的必备条件。

## 对称加密和非对称加密的区别

## https 的证书验证过程是什么样的

HTTPS 的证书验证过程是确保用户与服务器之间的安全通信的关键步骤。

以下是证书验证过程的详细步骤：

**1. 客户端发起连接**

1. **客户端请求**：
   - 客户端（如浏览器）发起一个 HTTPS 请求，连接到服务器。

**2. 服务器响应**

1. **服务器发送证书**：
   - 服务器将 SSL/TLS 证书发送给客户端。证书包含了服务器的公钥和由受信任的证书颁发机构（CA）签名的信息。

**3. 客户端验证证书**

1. **验证证书链**：
   - **检查证书有效性**：
     - 客户端检查证书是否在有效期内。
   - **验证证书签名**：
     - 客户端使用 CA 的公钥验证证书的签名，以确保证书未被篡改。
   - **检查证书颁发机构**：
     - 客户端检查证书是否由受信任的 CA 颁发。浏览器内置了受信任的 CA 列表，用于验证证书的有效性。
2. **验证证书用途**：
   - **检查证书用途**：
     - 客户端检查证书是否适用于其目的（例如服务器身份验证）。
3. **验证域名**：
   - **域名匹配**：
     - 客户端检查证书中的域名是否与请求的域名匹配。证书中的“主体”字段（Common Name）或“主题备用名称”字段（Subject Alternative Name）应与请求的 URL 匹配。

**4. 生成和交换密钥**

1. **密钥交换**：
   - **客户端生成密钥**：
     - 客户端生成一个对称密钥（Session Key），用于加密会话数据。
   - **加密密钥**：
     - 客户端用服务器的公钥加密生成的对称密钥，并将其发送到服务器。
   - **服务器解密密钥**：
     - 服务器用私钥解密客户端发送的对称密钥。

**5. 加密通信**

1. **建立安全通道**：
   - **数据加密**：
     - 服务器和客户端使用对称密钥加密和解密数据，确保通信内容的机密性和完整性。
   - **数据传输**：
     - 所有后续的通信数据都通过加密的通道传输。

**6. 完成握手**

1. **握手完成**：
   - 一旦安全通道建立，客户端和服务器就可以安全地交换数据，握手过程结束。

## HTTPS 加密算法和加解密过程是啥？

HTTPS 使用 SSL/TLS 协议来加密传输的数据，确保数据的机密性和完整性。HTTPS 的加解密过程主要包括以下几个步骤和算法：

**1. 加密算法和密钥类型**

- **对称加密算法**：使用相同的密钥进行加密和解密。常见的对称加密算法包括 AES（Advanced Encryption Standard）和 3DES（Triple Data Encryption Standard）。
- **非对称加密算法**：使用一对密钥（公钥和私钥），公钥用于加密，私钥用于解密。常见的非对称加密算法包括 RSA（Rivest-Shamir-Adleman）和 ECC（Elliptic Curve Cryptography）。
- **哈希算法**：用于生成数据的摘要，以确保数据完整性。常见的哈希算法包括 SHA-256（Secure Hash Algorithm 256-bit）和 MD5（Message Digest Algorithm 5，虽然 MD5 不再安全）。

**2. SSL/TLS 握手过程**

**握手阶段**

1. **客户端发起连接**
   - 客户端发送一个 “ClientHello” 消息，包含客户端支持的 TLS 版本、加密套件（加密算法组合）、压缩方法和其他信息。
2. **服务器响应**
   - 服务器回应一个 “ServerHello” 消息，选择客户端支持的加密套件和 TLS 版本。
   - 服务器发送其数字证书给客户端。数字证书包含服务器的公钥，由证书颁发机构（CA）签名。
3. **证书验证**
   - 客户端验证服务器的数字证书的有效性和真实性。如果证书有效，客户端继续执行。
   - 客户端生成一个随机的“pre-master secret”并用服务器的公钥加密，然后发送给服务器。这个“pre-master secret”将在后续的步骤中用于生成对称加密密钥。
4. **密钥交换**
   - 服务器使用其私钥解密“pre-master secret”并生成一个对称加密密钥（session key）。
   - 客户端和服务器使用“pre-master secret”生成相同的对称加密密钥（session key），用于加密后续的通信数据。
5. **完成握手**
   - 双方用对称加密密钥加密并交换“Finished”消息，表示握手过程完成。
   - 从这一点开始，客户端和服务器使用对称加密密钥加密和解密数据。

**3. 数据加密和传输**

- **对称加密**：客户端和服务器使用之前生成的对称加密密钥来加密和解密数据。对称加密算法确保数据在传输过程中是机密的。
- **数据完整性**：除了加密，TLS 还使用消息认证码（MAC）来确保数据在传输过程中没有被篡改。常见的 MAC 算法包括 HMAC（Hash-based Message Authentication Code）。

**4. 连接关闭**

- **优雅关闭**：当通信完成时，客户端和服务器通过发送“close_notify”消息来优雅地关闭连接，确保所有的数据都被正确传输。

**常见的加密套件**

在 TLS 握手过程中，客户端和服务器会协商一个加密套件（cipher suite），这是一个加密算法的组合。常见的加密套件包括：

- **TLS_AES_128_GCM_SHA256**：使用 AES 进行对称加密，GCM（Galois/Counter Mode）用于加密模式，SHA-256 用于消息认证。
- **TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384**：使用 ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）进行密钥交换，RSA 进行身份验证，AES-256-GCM 进行对称加密，SHA-384 进行消息认证。

## 请简述 HTTP 请求的过程

HTTP 请求的过程包括从客户端发起请求到服务器响应的完整流程。以下是简述的步骤：

**1. DNS 解析**

客户端将域名（如 `www.example.com`）解析为 IP 地址。这个过程通常通过 DNS（域名系统）完成。

**2. 建立 TCP 连接**

客户端与服务器建立 TCP 连接，通常通过三次握手过程（SYN, SYN-ACK, ACK）。

**3. 发送 HTTP 请求**

客户端通过 TCP 连接向服务器发送 HTTP 请求。HTTP 请求包括以下部分：

- **请求行**：包含 HTTP 方法（如 GET、POST）、请求的资源路径和 HTTP 版本。

  ```
  GET /index.html HTTP/1.1
  ```

- **请求头**：包含关于客户端、请求的内容和其他元数据的信息。

  ```
  Host: www.example.com
  User-Agent: Mozilla/5.0
  ```

- **请求体（可选**）：在某些方法（如 POST）中包含要发送到服务器的数据。

  ```
  {"name": "John", "age": 30}
  ```

**4. 服务器处理请求**

服务器接收到 HTTP 请求后，解析请求行和请求头，处理请求，并根据请求的资源生成响应。这个过程包括：

- 解析请求头
- 执行相关的逻辑（如访问数据库、处理数据）
- 生成响应内容

**5. 服务器发送 HTTP 响应**

服务器通过 TCP 连接将 HTTP 响应返回给客户端。HTTP 响应包括以下部分：

- **状态行**：包含 HTTP 版本、状态码和状态描述。

  ```
  HTTP/1.1 200 OK
  ```

- **响应头**：包含关于响应的元数据（如内容类型、内容长度等）。

  ```
  Content-Type: text/html
  Content-Length: 1234
  ```

- **响应体**：包含实际的响应数据（如 HTML 页面、JSON 数据等）。

  ```
  <html>...</html>
  ```

**6. 关闭 TCP 连接（或保持连接）**

客户端和服务器可以选择关闭 TCP 连接（如果 HTTP 版本是 1.0 或未设置 `Connection: keep-alive`）或保持连接以供后续请求（如果 HTTP 版本是 1.1 或设置了 `Connection: keep-alive`）。

**7. 客户端处理响应**

客户端接收到 HTTP 响应后，解析状态行、响应头和响应体，进行进一步处理（如更新页面内容）。

## HTTP Header 中有哪些信息？

**请求头（Request Headers）**

1. **Accept**：指定客户端能够接受的内容类型。例如：`Accept: application/json, text/html`.
2. **Accept-Encoding**：指定客户端能够接受的编码格式。例如：`Accept-Encoding: gzip, deflate`.
3. **Accept-Language**：指定客户端能够接受的语言。例如：`Accept-Language: en-US, en;q=0.9`.
4. **Authorization**：用于身份验证的头部。例如：`Authorization: Bearer <token>`.
5. **Cookie**：发送给服务器的 cookie 信息。例如：`Cookie: sessionId=abc123`.
6. **Host**：指定请求的目标主机和端口。例如：`Host: www.example.com`.
7. **User-Agent**：标识发出请求的用户代理（通常是浏览器）。例如：`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36`.

**响应头（Response Headers）**

1. **Content-Type**：响应体的内容类型。例如：`Content-Type: text/html; charset=UTF-8`.
2. **Content-Length**：响应体的长度（字节数）。例如：`Content-Length: 1234`.
3. **Date**：响应被发送的日期和时间。例如：`Date: Mon, 16 Aug 2024 12:00:00 GMT`.
4. **Server**：服务器的软件信息。例如：`Server: Apache/2.4.41 (Ubuntu)`.
5. **Set-Cookie**：用于在客户端设置 cookie。例如：`Set-Cookie: sessionId=abc123; Path=/; HttpOnly`.
6. **Cache-Control**：指定缓存策略。例如：`Cache-Control: no-cache, no-store, must-revalidate`.

**通用头（General Headers）**

1. **Connection**：指定是否保持连接或关闭连接。例如：`Connection: keep-alive`.
2. **Upgrade**：用于升级协议。例如：`Upgrade: websocket`.
3. **Via**：标识请求/响应经过的中间代理。例如：`Via: 1.1 example.com`.

**其他头部信息**

1. **Location**：在重定向响应中，指定重定向的目标 URL。例如：`Location: https://www.example.com/new-page`.
2. **ETag**：资源的标识符，用于缓存控制。例如：`ETag: "12345"`.
3. **If-Modified-Since**：请求中指定的时间，服务器只在资源在此时间之后被修改时才返回资源。例如：`If-Modified-Since: Mon, 16 Aug 2024 10:00:00 GMT`.

## HTTP 报文结构是怎样的？

## 为什么说 HTTP 是无状态的协议？

## 请求 Header 中的 Content-Type ，有哪些常见的值?

请求头中的 `Content-Type` 用于指明请求体中数据的格式，以下是常见的 `Content-Type` 值：

1. **application/json**
   - **用途**：传输 JSON 格式的数据，是前后端交互的常见选择。
   - **示例**：`{ "key": "value" }`
2. **application/x-www-form-urlencoded**
   - **用途**：表单数据的默认格式，将数据以键值对的形式传递，通常在简单表单提交中使用。
   - **格式**：`key1=value1&key2=value2`
3. **multipart/form-data**
   - **用途**：上传文件时常用的格式，允许在一个请求中包含文本字段和文件字段。
   - **格式**：数据被分段发送，每段包含字段信息，适合文件和表单混合数据的提交。
4. **text/plain**
   - **用途**：发送未经编码的纯文本内容，适用于简单的文本数据传输。
   - **示例**：`plain text`
5. **application/xml**
   - **用途**：用于传输 XML 格式的数据，通常用于某些旧系统或特定接口。
   - **示例**：`<note><to>User</to></note>`
6. **application/octet-stream**
   - **用途**：用于传输任意的二进制数据，常用于文件下载或上传，表示未知的文件类型。
   - **特点**：数据以字节流的形式传递，适合音视频、图片等多媒体数据。
7. **application/javascript**
   - **用途**：用于传输 JavaScript 代码或脚本内容。
   - **场景**：在接口返回的响应头中更常见，适合动态生成和执行的脚本数据。
8. **text/html**
   - **用途**：传输 HTML 文档，适合网页内容的传输。
   - **特点**：常用于返回页面内容，浏览器会将其识别为 HTML 并渲染。
9. **image/png**、**image/jpeg**、**image/gif**
   - **用途**：传输图像文件，`Content-Type` 中会包含图像的具体格式。
   - **场景**：用于直接访问图片 URL 或上传图像。

## 说说网络分层里七层模型是哪七层

网络七层模型（OSI）是国际标准化组织定义的网络通信分层框架，从物理传输到应用服务逐层抽象。  

**具体分层**：  
1. **物理层**：传输原始比特流（如网线、光纤）；  
2. **数据链路层**：帧传输与MAC地址寻址（如交换机）；  
3. **网络层**：IP寻址与路由选择（如路由器）；  
4. **传输层**：端到端连接与可靠性（TCP/UDP）；  
5. **会话层**：建立/管理会话（如RPC）；  
6. **表示层**：数据格式转换与加密（如SSL/TLS）；  
7. **应用层**：用户接口与协议（HTTP/FTP）。  

前端开发主要关注**应用层（HTTP/WebSocket）**和**传输层（TCP）**。



## 	TCP/IP 四层模型是什么？



## 说说对 TCP/IP 协议的了解

`TCP/IP`（`Transmission Control Protocol/Internet Protocol`，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由 `FTP、SMTP、TCP、UDP、IP`等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。

TCP/IP传输协议是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP/IP传输协议是严格来说是一个四层的体系结构，**应用层** 、**传输层**、**网络层** 和 **数据链路层** 都包含其中。

TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为:

- 应用层:应用程序间沟通的层，如简单电子邮件传输(SMTP)、文件传输协议(FTP)、网络远程访问协议(Telnet)等。
- 传输层:在此层中，它提供了节点间的数据传送，应用程序之间的通信服务，主要功能是数据格式化、数据确认和丢失重传等。如传输控制协议(TCP)、用户数据报协议(UDP)等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。
- 网络层:负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机(但不检查是否被正确接收)，如网际协议(IP)。
- 数据链路层(主机-网络层):接收IP数据报并进行传输，从网络上接收物理帧，抽取IP数据报转交给下一层，对实际的网络媒体的管理，定义如何使用实际网络(如Ethernet、Serial Line等)来传送数据。

## TCP 和 UDP 有什么区别？

TCP和UDP的核心区别在于**可靠性、连接方式及传输效率**，分别适用于不同场景。  

**具体差异**：  
1. **连接性**：  
   - **TCP**：面向连接（三次握手/四次挥手），确保可靠传输。  
   - **UDP**：无连接，直接发送数据包，无连接开销。  

2. **可靠性**：  
   - **TCP**：保证数据顺序、完整性，自动重传丢包。  
   - **UDP**：不保证送达，可能丢包或乱序。  

3. **传输效率**：  
   - **TCP**：因校验、重传、拥塞控制等机制，延迟较高。  
   - **UDP**：无额外控制，传输速度快，实时性高。  

4. **头部开销**：  
   - **TCP**：头部较大（20-60字节），包含序列号、确认号等字段。  
   - **UDP**：头部固定8字节，仅含端口和长度。  

**应用场景**：  
- **TCP**：HTTP/HTTPS、文件传输（FTP）、邮件（SMTP）等需可靠性的场景。  
- **UDP**：视频通话（如WebRTC）、直播流、DNS查询、在线游戏等实时性优先的场景。  

**总结**：需要可靠传输选TCP，追求实时高效选UDP。

## TCP 粘包是什么？

TCP 粘包（TCP packet sticking）是一种在 TCP 协议中常见的现象，指的是接收方在读取数据时，可能会将来自多个发送包的数据合并在一起，或者将一个发送包的数据拆分成多个接收包进行读取。这种现象与 TCP 的数据传输机制有关，而 TCP 协议本身并不保留消息边界，只关心字节流的可靠传输。

**粘包和拆包的原因**

1. **流式协议**：
   - TCP 是一个流式协议，数据在网络上传输时被看作一个连续的字节流，没有明确的消息边界。这意味着发送的数据包在接收端可能会被合并，也可能被拆分。
2. **网络延迟和缓冲**：
   - TCP 可能会将多个小的数据包合并成一个较大的数据包发送，或者将一个较大的数据包拆分成多个小的包进行发送。这取决于网络状况和 TCP 实现的缓冲策略。
3. **发送和接收缓冲区**：
   - 发送方的缓冲区可能会在发送数据时合并多个数据块，而接收方的缓冲区可能会将这些数据块合并成一个完整的消息进行读取。

**解决方案**

1. **协议设计**：
   - 在应用层设计协议时，通常会在数据流中添加分隔符或消息长度字段，以明确消息的边界。例如，可以在每个消息前面加上固定长度的消息头，表示消息的长度。
2. **数据标识**：
   - 在数据传输过程中使用特定的标识符或分隔符来区分不同的消息。这种方法可以帮助接收方识别和处理不同的数据包。
3. **分段和重组**：
   - 在应用层进行分段和重组操作，确保从 TCP 流中提取出完整的消息。例如，可以使用协议来处理粘包和拆包问题，确保接收到的数据能够被正确解析。

## 为什么 TCP 挥手需要有 TIME_WAIT 状态?

## TCP 超时重传机制是为了解决什么问题？

## TCP 滑动窗口的作用是什么？

## 一个 TCP 连接能发几个 http 请求？

一个 TCP 连接可以发多个 HTTP 请求，具体取决于使用的 HTTP 版本：

**1. HTTP/1.0**

- **每个请求独立**：HTTP/1.0 默认使用非持久连接（每个请求都需要建立新的 TCP 连接）。因此，每个 HTTP 请求需要一个新的 TCP 连接。

**2. HTTP/1.1**

- **持久连接**：HTTP/1.1 引入了持久连接（Connection: keep-alive），使得一个 TCP 连接可以发送多个 HTTP 请求和响应。在默认情况下，一个 TCP 连接可以支持多个 HTTP 请求，直到连接被关闭。
- **并发请求**：HTTP/1.1 还支持管道化（pipelining），允许在等待响应的同时发送多个请求。但是，管道化有一些限制，如请求顺序和响应顺序。

**3. HTTP/2**

- **多路复用**：HTTP/2 使用多路复用（multiplexing）技术，允许多个请求和响应在一个 TCP 连接上并发进行，而不会阻塞彼此。每个请求和响应通过流（stream）进行管理，可以有效地减少延迟和提高性能。

**4. HTTP/3**

- **基于 QUIC 协议**：HTTP/3 使用 QUIC 协议，它在用户数据报协议（UDP）上实现了类似于 HTTP/2 的多路复用功能。它在一个连接上支持多个请求和响应，进一步优化了网络性能。

## HTTP状态码及其含义

HTTP状态码用于表示请求的处理结果，分为五类，通过三位数字快速定位问题类型。  

**常见状态码**：  
1. **1xx（信息）**：请求已接收，继续处理（如101协议切换）。  
2. **2xx（成功）**：请求正常处理（200 OK，201 Created）。  
3. **3xx（重定向）**：需额外操作完成请求（301永久重定向，304缓存未修改）。  
4. **4xx（客户端错误）**：请求有误（400参数错误，401未授权，403禁止访问，404未找到资源）。  
5. **5xx（服务端错误）**：服务器处理失败（500内部错误，502网关错误，503服务不可用）。  

**前端关注重点**：  
- **200**：成功获取资源；  
- **304**：缓存生效，减少请求；  
- **404/403**：检查资源路径/权限；  
- **500/503**：提示用户或重试。

## 304 状态码用于什么场景

**304 状态码**表示“未修改”（Not Modified），用于缓存机制中。它告知客户端缓存的资源仍然有效，无需重新下载。

**场景**：

- **缓存优化**：当客户端请求一个资源时，服务器可以通过 `If-Modified-Since` 或 `If-None-Match` 头部判断该资源是否被修改。如果资源未修改，服务器返回 304 状态码，客户端继续使用缓存中的资源。

**好处**：

1. **减少带宽消耗**：避免重复传输未改变的资源，节省了网络带宽。
2. **提高加载速度**：客户端可以使用缓存资源，减少了服务器的响应时间。
3. **降低服务器负载**：减少了对服务器的请求处理，降低了负载。

**坏处**：

1. **缓存问题**：如果缓存策略设置不当，可能会导致客户端获取到过时的资源。
2. **复杂性**：需要正确配置缓存头部和验证机制，增加了开发和维护的复杂性。
3. **可能的延迟**：在一些网络环境中，验证资源是否修改的请求和响应可能导致额外的延迟，尽管这个延迟通常较小。

## 强缓存和协商缓存分别是什么？

这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。

浏览器缓存主要有以下几个优点：

- 减少重复数据请求，避免通过网络再次加载资源，节省流量。
- 降低服务器的压力，提升网站性能。
- 加快客户端加载网页的速度， 提升用户体验。

浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：

- 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。
- 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox中，from cache 状态码是 304.

**请求流程**

浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：

- 浏览器会获取该缓存资源的 header 中的信息，根据 response header 中的 expires 和 cache-control 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。
- 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 IF-Modified-Since 或者 IF-None-Match, 它们的值分别是第一次请求返回 Last-Modified或者 Etag，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。

**强缓存**

强缓存是根据返回头中的 Expires 或者 Cache-Control 两个字段来控制的，都是表示资源的缓存有效时间。

- Expires 是 http 1.0 的规范，值是一个GMT 格式的时间点字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 Expires 在实际使用中会带来一些麻烦。
- Cache-Control这个字段是 http 1.1 的规范，一般常用该字段的 max-age 值来进行判断，它是一个相对时间，比如 .Cache-Control:max-age=3600 代表资源的有效期是 3600 秒。并且返回头中的 Date 表示消息发送的时间，表示当前资源在 Date ~ Date +3600s 这段时间里都是有效的。不过我在实际使用中常常遇到设置了 max-age 之后，在 max-age 时间内重新访问资源却会返回 304 not modified ，这是由于服务器的时间与本地的时间不同造成的。当然 Cache-Control 还有其他几个值可以设置， 不过相对来说都很少用了：
  - no-cache 不使用本地缓存。需要使用协商缓存。
  - no-store直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 network 中的 disabled cache。
  - public 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
  - private 只能被终端用户的浏览器缓存。

如果 Cache-Control与 Expires 同时存在的话， Cache-Control 的优先级高于 Expires 。

**协商缓存**

协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, Last-Modified 或者 Etag，则后续请求则会带上对应的请求字段 If-Modified-Since或者 If-None-Match，若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。

- Last-Modified/If-Modified-Since 二者的值都是 GMT 格式的时间字符串， Last-Modified 标记最后文件修改时间， 下一次请求时，请求头中会带上 If-Modified-Since 值就是 Last-Modified 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 304 Not Modified ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加的 Last-Modified 去试图更新本地缓存的 Last-Modified， 因为既然资源没有变化，那么 Last-Modified 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 Last-Modified 会在 response header 返回，并在下次请求之前更新本地缓存的 Last-Modified，下次请求时，If-Modified-Since会启用更新后的 Last-Modified。
- Etag/If-None-Match， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 ETag字段返回给浏览器，接收到 If-None-Match 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于在服务器上ETag 重新计算过，response header中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。

HTTP 中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。

## 说是 TCP 的三次握手四次挥手

TCP的三次握手和四次挥手是建立与断开可靠连接的核心机制，确保数据传输的完整性和有序性。  

**三次握手（建立连接）**：  
1. **SYN**：客户端发送SYN（同步）报文，包含初始序列号（Seq=x）。  
2. **SYN-ACK**：服务端响应SYN+ACK（确认）报文，确认号=x+1，携带自身序列号（Seq=y）。  
3. **ACK**：客户端发送ACK（确认）报文，确认号=y+1，双方进入连接状态。  

**四次挥手（断开连接）**：  
1. **FIN**：主动方（如客户端）发送FIN（结束）报文，进入FIN_WAIT_1状态。  
2. **ACK**：被动方（如服务端）返回ACK确认，进入CLOSE_WAIT状态；主动方收到后进入FIN_WAIT_2状态。  
3. **FIN**：被动方处理完数据后发送FIN报文，进入LAST_ACK状态。  
4. **ACK**：主动方回复ACK确认，进入TIME_WAIT（等待2MSL确保对方收到），双方关闭连接。  

**关键点**：  
- **三次握手**：防止历史重复连接初始化（两次无法确认双方收发能力）。  
- **四次挥手**：TCP全双工特性需双向独立关闭，且确保数据完整传输（如服务端可能仍有数据发送）。



**通俗易懂版：**

TCP的三次握手和四次挥手就像两个人打电话时的沟通流程，确保双方都能正常交流后再开始对话，以及礼貌地结束通话后再挂断。

**三次握手（建立连接）**  

1. **第一次握手**：  
   - 客户端发送“打招呼”信号（SYN）：“我要和你通话，能听到吗？”  
   - 好比你打电话给朋友，先问：“喂，你在吗？”  

2. **第二次握手**：  
   - 服务端回复“收到”（SYN-ACK）：“我听到了！你能听到我吗？”  
   - 朋友回答：“我在！你能听到我吗？”  

3. **第三次握手**：  
   - 客户端确认“收到回复”（ACK）：“能听到，开始聊吧！”  
   - 你回应：“能听到，说吧！”  
   - **连接建立**，双方开始传输数据。

**为什么是三次？**  
- 避免网络延迟导致的“重复拨号”。比如你第一次问“在吗？”没回应，又重复问，如果对方只回一次，两次握手可能误判连接已建立。

**四次挥手（断开连接）**  

假设客户端主动挂断：  
1. **第一次挥手**：  
   - 客户端说：“我说完了，准备挂电话了。”（FIN）  
   - 比如你说：“今天先聊到这，我挂了啊。”  

2. **第二次挥手**：  
   - 服务端回复：“好的，知道了。”（ACK）  
   - 朋友说：“行，等我确认一下还有没有要说的。”  

3. **第三次挥手**：  
   - 服务端确认后也说：“我也说完了，可以挂了。”（FIN）  
   - 朋友补充：“对了，最后一点…好了，挂吧！”  

4. **第四次挥手**：  
   - 客户端最后确认：“收到，拜拜！”（ACK）  
   - 你回答：“好的，拜拜！”  
   - **连接关闭**，双方结束通话。

**为什么是四次？**  
- 因为挂电话要双方都确认。比如你说完挂断意图后，对方可能还有话要说，需要等对方说完再互相确认。

**总结**  

- **三次握手**：互相确认“能听清吗？”，防止自说自话。  
- **四次挥手**：互相确认“都说完了吗？”，防止突然挂断漏话。  

这种机制确保网络传输像真实对话一样可靠，不丢数据、不乱顺序。

## 什么是 HTTP 的队头阻塞?

## 为什么 TCP 需要三次握手，两次可以吗？

## 常见的HTTP请求方法

1. **GET**：请求指定的页面信息，并返回实体主体。这是最常用的请求方法，通常用于请求服务器发送资源（如HTML页面）。GET请求的数据会附加在URL之后（即“查询字符串”），以`?`分隔URL和传输数据，多个参数用`&`连接。
2. **POST**：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。POST请求的数据被包含在请求体中。POST请求相比GET请求，更适合发送大量数据。
3. **PUT**：向指定资源位置上传其最新内容（即更新资源）。PUT请求通常用于上传或更新服务器上的资源。
4. **DELETE**：请求服务器删除指定的页面。DELETE请求通常用于删除服务器上的资源。
5. **HEAD**：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。HEAD请求常用于检查资源的最新状态或是否存在，而不传输实际内容。
6. **OPTIONS**：允许客户端查看服务器的性能。它描述了服务器支持的通信选项。例如，它可以被用来确定服务器支持哪些HTTP方法或者是否支持某些特定类型的“内容协商”。
7. **CONNECT**：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的连接（经由非加密的HTTP代理服务器）。
8. **TRACE**：回显服务器收到的请求，主要用于测试或诊断。然而，由于安全原因（它可能暴露敏感信息），许多服务器默认禁用TRACE请求。
9. **PATCH**：是对资源进行部分修改。与PUT请求不同，PATCH请求用于对资源进行局部更新，而不是替换整个资源。



## Cookie、Session、Token 之间有什么区别？

## **HTTP GET 和 POST 请求有什么区别？**

HTTP GET 和 POST 请求的核心区别在于**用途、数据传输方式及安全性**，分别适用于获取资源和提交数据。  

**具体差异**：  
1. **用途**：  
   - **GET**：获取资源（如加载网页、查询数据），**幂等且可缓存**。  
   - **POST**：提交资源（如表单提交、文件上传），**非幂等且不缓存**。  

2. **数据传输**：  
   - **GET**：参数通过URL拼接（如 `?key=value`），**长度受限**（约2048字符）。  
   - **POST**：数据放在请求体（Body）中，**支持更大数据量和多种格式**（JSON、文件等）。  

3. **安全性**：  
   - **GET**：参数暴露在URL中，易被记录或泄露（如浏览器历史、日志）。  
   - **POST**：数据隐藏于Body，**相对安全**（但未加密时仍可被截获）。  

4. **幂等性**：  
   - **GET**：多次请求结果相同（如刷新页面）。  
   - **POST**：多次提交可能产生副作用（如重复下单）。  

**应用场景**：  
- **GET**：搜索、分页、静态资源加载。  
- **POST**：登录、注册、支付等敏感操作。  

**总结**：取数据用GET，传数据用POST；敏感信息避免GET，大数据量优先POST。

## get 和 post 请求在缓存方面有什么区别？

## get 请求是否限制了传参长度？

1. HTTP 协议未规定 GET 和 POST 的长度限制
2. GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度
3. 不同的浏览器和 WEB 服务器，限制的最大长度不一样
4. 要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte

## 解释 RESTful API 的设计原则

## 介绍下 WebSocket

1. **WebSocket 是什么**

WebSocket是HTML5提供的一种浏览器与服务器进行**全双工通讯**的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。

WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：**服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。**

**WebSocket原理** ：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。

**2. WebSocket 特点**

- 支持双向通信，实时性更强
- 可以发送文本，也可以发送二进制数据‘’
- 建立在TCP协议之上，服务端的实现比较容易
- 数据格式比较轻量，性能开销小，通信高效
- 没有同源限制，客户端可以与任意服务器通信
- 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL
- 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

## Websoket 和 HTTP 有什么区别？

WebSocket 和 HTTP 的核心区别在于**通信模式与实时性**，前者支持全双工实时交互，后者基于短连接的请求-响应模式。  

**具体差异**：  
1. **连接方式**：  
   - **HTTP**：短连接，每次请求需重新建立TCP连接（HTTP/1.1后支持Keep-Alive，但本质仍是串行请求）。  
   - **WebSocket**：长连接，一次握手后保持连接，双方可主动推送数据。  

2. **通信模式**：  
   - **HTTP**：客户端发起请求 → 服务端响应（单向，实时性差）。  
   - **WebSocket**：客户端/服务端均可主动发送消息（双向实时通信）。  

3. **头部开销**：  
   - **HTTP**：每次请求携带完整头部（如Cookie、User-Agent），冗余开销大。  
   - **WebSocket**：建立连接后数据帧头部仅2~14字节，传输效率高。  

4. **适用场景**：  
   - **HTTP**：静态资源加载、RESTful API、传统网页交互。  
   - **WebSocket**：实时聊天、在线游戏、股票行情推送、协同编辑。  

5. **协议关系**：  
   - **WebSocket**：基于HTTP协议升级（握手阶段使用HTTP），建立后独立于HTTP运行。  

**总结**：需实时双向通信（如消息推送）用WebSocket，传统数据交互用HTTP。



## 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？

短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。



**短轮询的基本思路是** 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。



**长轮询的基本思路是** 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。



**SSE 的基本思想是** 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。



**WebSocket** 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。



**上面的四个通信协议，前三个都是基于HTTP协议的。** 对于这四种即使通信协议，从性能的角度来看： **WebSocket > 长连接（SEE） > 长轮询 > 短轮询** 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： **短轮询 > 长轮询 > 长连接（SEE） > WebSocket** 所以，还是要根据具体的使用场景来判断使用哪种方式。

## http 中的 post 请求发生了两次（多了一次 options 请求）的原因

浏览器在发送某些跨域POST请求前会先发送**OPTIONS预检请求**，以确认服务器是否允许实际请求的方法和头信息，这是由CORS（跨域资源共享）安全机制触发的。  

**具体原因**：  
1. **非简单请求**：当POST请求满足以下任一条件时，触发预检：  
   - 自定义头部（如`Authorization`、`X-Custom-Header`）；  
   - `Content-Type`非简单值（如`application/json`）；  
   - 其他非安全方法或配置（如`DELETE`请求）。  

2. **预检流程**：  
   - **OPTIONS请求**：浏览器自动发送，询问服务器是否支持实际请求的方法和头；  
   - **服务器响应**：需返回`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers`等CORS头；  
   - **正式POST请求**：预检通过后，浏览器发送真实POST请求。  

**解决方案**：  
- **服务器配置**：正确处理OPTIONS请求，返回允许的跨域头；  
- **简化请求**：避免自定义头，使用简单`Content-Type`（如`application/x-www-form-urlencoded`）。

## 介绍下 HTTPS 中间人攻击

HTTPS中间人攻击（MITM）是攻击者伪装成通信双方拦截并篡改数据的行为，其核心绕过HTTPS的安全机制窃取敏感信息。  

**攻击过程与防御**：  
1. **攻击步骤**：  
   - **劫持连接**：攻击者通过ARP欺骗、恶意WiFi等手段成为通信中间代理。  
   - **伪造证书**：使用自签名证书或非法CA证书欺骗客户端（如用户忽略浏览器警告）。  
   - **解密中转**：拦截客户端与服务端的TLS握手，分别建立加密连接，明文获取数据。  

2. **HTTPS防御机制**：  
   - **证书链校验**：浏览器验证证书是否由可信CA签发，域名是否匹配，是否过期或被吊销。  
   - **加密传输**：通过非对称加密交换密钥，后续数据由对称加密保护（如AES-256）。  

3. **前端注意事项**：  
   - **禁用混合内容**：确保页面内所有资源（图片、脚本）均为HTTPS，避免降级攻击。  
   - **启用HSTS**：通过HTTP头`Strict-Transport-Security`强制浏览器仅使用HTTPS。  
   - **用户教育**：提示用户切勿在浏览器证书告警页面继续访问。  

**真实案例**：公共WiFi中攻击者伪造银行网站，诱导用户输入账号密码。HTTPS若正确配置可拦截此类攻击，但用户主动忽略证书错误仍会中招。

## DNS 协议了解多少？

DNS协议是互联网中将域名转换为IP地址的核心系统，确保用户通过易记的域名访问网络资源。  

**核心要点**：  
1. **核心功能**：  
   - **域名解析**：将`www.example.com`转换为`93.184.216.34`（IPv4）或`2606:2800:220:1:248:1893:25c8:1946`（IPv6）。  
   - **分层结构**：  
     - **根域名服务器**：全球13组，指向顶级域（如`.com`）。  
     - **顶级域（TLD）服务器**：管理`.com`、`.org`等后缀。  
     - **权威域名服务器**：托管具体域名的IP记录（如`example.com`）。  
     - **本地DNS服务器**：由ISP或企业提供，缓存查询结果。  

2. **查询流程**（以访问`www.example.com`为例）：  
   - **递归查询**（客户端→本地DNS）：  
     1. 客户端向本地DNS请求解析。  
     2. 本地DNS依次查询根→`.com`→`example.com`权威服务器，最终返回IP。  
   - **迭代查询**（本地DNS自主完成多级查询）。  

3. **记录类型**：  
   - **A记录**：IPv4地址。  
   - **AAAA记录**：IPv6地址。  
   - **CNAME**：域名别名（如将`blog.example.com`指向`example.com`）。  
   - **MX记录**：邮件服务器地址（如`mail.example.com`）。  
   - **TXT记录**：文本信息（如SPF反垃圾邮件配置）。  

4. **协议细节**：  
   - **传输协议**：默认UDP 53端口（快速），数据超512字节或区域传输时用TCP。  
   - **缓存机制**：TTL（生存时间）控制缓存有效期，减少重复查询。  

5. **安全性**：  
   - **DNS劫持**：篡改解析结果（如恶意WiFi）。  
   - **DNSSEC**：通过数字签名验证响应真实性，防篡改。  
   - **DoH/DoT**：DNS over HTTPS/TLS加密查询，防窃听。  

**前端相关**：  
- **性能优化**：减少DNS查询次数（合并域名、预解析`<link rel="dns-prefetch">`）。  
- **CDN加速**：通过智能DNS解析用户至最近节点。  

**示例命令**：  

```bash  
nslookup www.example.com      # 查询A记录  
dig example.com MX            # 查询MX记录  
```

**总结**：DNS是互联网的“电话簿”，其高效解析依赖分层架构与缓存，安全性需结合DNSSEC和加密协议保障。



## 什么是 DNS 预解析？如何实现？

**DNS优化**

在介绍`dns-prefetch`之前，先要提下当前对于DNS优化主流方法。

一般来说，一次DNS解析需要耗费 20-120ms，所以为了优化DNS，我们可以考虑两个方向：

1. 减少DNS请求次数
2. 缩短DNS解析时间`dns-prefetch`

**什么是dns-prefetch？**

`dns-prefetch`(**DNS预获取**)是前端网络性能优化的一种措施。它根据浏览器定义的规则，**提前解析**之后可能会用到的域名，使解析结果**缓存到系统缓存**中，缩短DNS解析时间，进而提高网站的访问速度。

**为什么要用dns-prefetch？**

每当浏览器从（第三方）服务器发送一次请求时，都要先通过**DNS解析**将该跨域域名解析为 IP地址，然后浏览器才能发出请求。

如果某一时间内，有多个请求都发送给同一个服务器，那么DNS解析会多次并且重复触发。这样会导致整体的网页加载有延迟的情况。

我们知道，虽然DNS解析占用不了多大带宽，但是它会产生很高的延迟，尤其是对于移动网络会更为明显。

因此，为了减少DNS解析产生的延迟，我们可以通过`dns-prefetch`预解析技术有效地缩短DNS解析时间。

```
<link rel="dns-prefetch" href="https://baidu.com/"> 
```

**dns-prefetch背后原理**

当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。 在解析过程中，按照:

- 浏览器缓存
- 系统缓存
- 路由器缓存
- ISP(运营商)DNS缓存
- 根域名服务器
- 顶级域名服务器
- 主域名服务器

的顺序逐步读取缓存，直到拿到IP地址。

`dns-prefetch`就是在**将解析后的IP缓存在系统中**。

这样，`dns-prefetch`就有效地缩短了DNS解析时间。因为，在本地操作系统做了DNS缓存，使得DNS在解析的过程中，提前在系统缓存中找到了对应IP。

这样一来， 后续的解析步骤就不用执行了，进而也就缩短了DNS解析时间。

假如浏览器**首次将一个域名解析为IP地址**，并**缓存至操作系统**，那么下一次DNS解析时间可以低至**0-1ms**。

倘若结果不缓存在系统，那么就需要读取**路由器的缓存**，进而后续的解析时间最小也要约**15ms**。

如果路由器缓存也不存在，则需要读取**ISP（运营商）DNS缓存**，一般像`taobao.com`、`baidu.com`这些常见的域名，读取ISP（运营商）DNS缓存需要的时间在**80-120ms**，如果是不常见的域名，平均需要**200-300ms**。

一般来说，大部分的网站到运营商这块都能找到IP。

那也就是说，`dns-prefetch`可以给DNS解析过程带来15-300ms的提升，尤其是一些大量引用很多其他域名资源的网站，提升效果就更加明显了

**浏览器DNS缓存与dns-prefetch**

现代浏览器为了优化DNS解析，也设有了浏览器DNS缓存。

每当在首次DNS解析后会对其IP进行缓存。至于缓存时长，每种浏览器都不一样，比如Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。

> Tip:
>  每当Chrome浏览器启动的时候，就会自动的快速解析浏览器最近一次启动时记录的前10个域名。所以经常访问的网址就不存在DNS解析的延迟，进而打开速度更快。

而`dns-prefetch` 相当于在浏览器缓存之后，在本地操作系统中做了DNS缓存，个人理解，为的是给浏览器缓存做保障，尽量让DNS解析出本地，以此来做了又一层DNS解析优化。

一般来说，DNS在系统的缓存时间是大于浏览器的。

**浏览器与系统DNS缓存时间**

> TTL(Time-To-Live)，就是一条域名解析记录在DNS服务器中的存留时间

- **浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关**, 它的缓存时间取决于浏览器自身设置。
- **系统缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值**。

国内和国际上很多平台的TTL值都是以秒为单位的，很多的默认值都是3600，也就是默认缓存1小时。

**`dns-prefetch`缺点**

`dns-prefetch`最大的缺点就是使用它太多。

过多的预获取会导致过量的DNS解析，对网络是一种负担。

**最佳实践**

请记住以下三点：

1. `dns-prefetch` 仅对[跨域](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)域上的 DNS查找有效，因此请避免使用它来指向相同域。这是因为，到浏览器看到提示时，您站点域背后的IP已经被解析。
2. 除了link 还可以通过使用 [HTTP链接字段](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Link)将 `dns-prefetch`（以及其他资源提示）指定为 [HTTP标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)：

```
Link: <https://fonts.gstatic.com/>; rel=dns-prefetch
```

1. 考虑将 `dns-prefetch` 与 `preconnect(`预连接`)`提示配对。

由于`dns-prefetch` 仅执行 DNS查找，不像`preconnect` 会建立与服务器的连接。

如果站点是通过HTTPS服务的，两者的组合会涵盖DNS解析，建立TCP连接以及执行TLS握手。将两者结合起来可提供进一步减少[跨域请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)的感知延迟的机会。如下所示：

```
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link rel="dns-prefetch" href="https://fonts.gstatic.com/">
```

**Note**: 如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。 `preconnect` 提示最好仅用于最关键的连接。对于其他的，只需使用 `<link rel="dns-prefetch">` 即可节省第一步的时间DNS查找。



## 谈谈你对 Nginx 的了解

## 如何配置反向代理解决前端跨域问题？

## Nginx 如何处理前端路由（如 Vue/React 的 History 模式）？

## 什么是正向代理，反向代理?

正向代理是**客户端**的代理，帮助客户端访问外部资源；反向代理是**服务端**的代理，替服务器接收并分发客户端请求。  

**正向代理（Forward Proxy）**  

**特点**：  
- **代理对象**：代表客户端（如浏览器）访问目标服务器。  
- **隐藏客户端**：目标服务器只知道代理的IP，无法识别真实用户。  
- **用途**：  
  - 突破访问限制（如科学上网）；  
  - 统一控制客户端访问权限（如企业内网过滤）；  
  - 缓存资源加速访问（如代理服务器缓存静态文件）。  
  **示例工具**：Shadowsocks、Squid、Charles（开发调试）。  

**反向代理（Reverse Proxy）**  

**特点**：  
- **代理对象**：代表服务端接收客户端请求，转发到内部服务器。  
- **隐藏服务端**：客户端不知道真实服务器IP，仅与代理交互。  
- **用途**：  
  - 负载均衡（如Nginx轮询分发请求到多台服务器）；  
  - 安全防护（如隐藏后端服务，防御DDoS攻击）；  
  - 统一SSL加密（由代理处理HTTPS，降低后端压力）；  
  - 路由分发（如根据URL路径指向不同服务）。  
  **示例工具**：Nginx、HAProxy、Cloudflare CDN。  

**对比总结**  

| **特征**       | 正向代理               | 反向代理                   |
| -------------- | ---------------------- | -------------------------- |
| **代理方向**   | 客户端→代理→外部服务器 | 客户端→代理→内部服务器     |
| **隐藏对象**   | 客户端IP               | 服务端IP和架构             |
| **客户端感知** | 需配置代理地址         | 无感知，代理对客户端透明   |
| **典型场景**   | 内网翻墙、缓存加速     | 负载均衡、SSL卸载、API网关 |

**前端应用场景**：  
- **正向代理**：本地开发中配置Webpack代理解决跨域（如`devServer.proxy`）；  
- **反向代理**：生产环境用Nginx转发请求，实现动静分离或接口聚合。

## 什么是 JWT

JWT（JSON Web Token）是一种**开放标准（RFC 7519）的轻量级身份验证和授权协议**，通过JSON格式安全传输信息，通常用于无状态的用户身份验证。

**核心组成**  

1. **Header（头部）**：  
   - 声明令牌类型（`typ: "JWT"`）和签名算法（如`alg: "HS256"`）。  
   - 示例：`{"alg": "HS256", "typ": "JWT"}` → Base64编码。  

2. **Payload（载荷）**：  
   - 携带用户身份数据（如用户ID、角色）和其他声明（如过期时间`exp`、签发者`iss`）。  
   - 示例：`{"sub": "123", "name": "Alice", "exp": 1717020000}` → Base64编码。  

3. **Signature（签名）**：  
   - 对前两部分拼接后的字符串，通过密钥（如`secretKey`）和指定算法（如HMAC SHA256）生成签名，防止数据篡改。  
   - 公式：`签名 = HMACSHA256(base64(Header) + "." + base64(Payload), secretKey)`  

**工作流程**  

1. **登录认证**：  
   - 用户提交凭证（如账号密码），服务端验证通过后生成JWT返回客户端。  
2. **携带令牌**：  
   - 客户端后续请求在`Authorization`头中添加`Bearer <JWT>`。  
3. **服务端验证**：  
   - 解析JWT签名是否有效，校验载荷（如是否过期）后授权访问。  

**优点**  

- **无状态**：服务端无需存储会话（如Session），适合分布式系统。  
- **跨域支持**：轻松实现单点登录（SSO）。  
- **数据自包含**：减少数据库查询（如直接从Payload读取用户ID）。  

**缺点与注意事项**  

- **无法主动失效**：令牌在过期前有效（可通过黑名单或短有效期缓解）。  
- **数据暴露风险**：Payload仅Base64编码，敏感信息需加密（如JWE）。  
- **存储安全**：前端需防XSS攻击（避免`localStorage`，优先`HttpOnly Cookie`）。  

**前端应用示例**  

```javascript  
// 存储JWT  
localStorage.setItem('token', jwt);  

// 请求时携带  
fetch('/api/data', {  
  headers: {  
    'Authorization': `Bearer ${localStorage.getItem('token')}`  
  }  
});  
```

**总结**：JWT适用于无状态、跨服务的认证场景，但需结合业务权衡安全性与便利性。

## 如何避免缓存问题导致的资源更新失败？

避免缓存导致资源更新失败的核心策略是**强制客户端获取最新版本**，可通过文件名哈希、版本号或缓存控制头实现。  

**具体方法**：  
1. **文件名哈希**：  
   - 构建工具（如Webpack）为资源生成唯一哈希（如`app.a3b4c5.js`），文件内容变化则哈希改变，直接更新引用路径。  

2. **查询参数版本化**：  
   - 在资源URL后添加版本参数（如`style.css?v=2.0.0`），更新版本号即可刷新缓存。  

3. **HTTP缓存头控制**：  
   - **HTML文件**：设置`Cache-Control: no-cache`或`max-age=0`，确保始终验证更新。  
   - **静态资源**：设置长缓存`Cache-Control: max-age=31536000`，依赖文件名哈希（内容变则URL变）。  

4. **服务端配置**：  
   - CDN或Nginx配置`ETag`/`Last-Modified`，结合内容变化自动刷新缓存。  

**示例**：  
```html  
<!-- 文件名哈希 -->  
<script src="/app.3e4f5a.js"></script>  

<!-- 查询参数 -->  
<link href="/styles.css?v=20231001" rel="stylesheet">  
```

**总结**：哈希文件名是生产环境最佳实践，开发环境可结合禁用缓存（如Chrome DevTools禁用缓存选项）快速调试。

## 什么是 ETag 和 Last-Modified？它们的优先级如何？

## HTTPS 中的 SSL/TLS 是什么？

HTTPS（Hypertext Transfer Protocol Secure）是HTTP的安全版本，它通过SSL/TLS协议对数据进行加密，确保数据在传输过程中保持机密性和完整性。下面是对SSL和TLS的详细介绍：

**SSL（Secure Sockets Layer）**

- **定义**：SSL是最早的安全协议，用于在网络上加密传输的数据。它确保数据在客户端和服务器之间的传输是安全的。
- **历史**：SSL最初由Netscape开发，主要包括SSL 2.0和SSL 3.0两个版本。由于SSL 2.0和SSL 3.0存在一些安全漏洞，它们已经被淘汰。

**TLS（Transport Layer Security）**

- **定义**：TLS是SSL的继任者，是一种用于保护网络通信的加密协议。TLS对数据进行加密，确保数据在传输过程中不被窃取或篡改。
- **版本**：TLS 从 TLS 1.0 开始，到当前的 TLS 1.3。每个版本都在前一个版本的基础上进行改进，增强了安全性和性能。

**SSL/TLS 工作原理**

1. **握手过程（Handshake）**
   - **客户端发起连接**：客户端向服务器发送一个“ClientHello”消息，包含了客户端支持的加密算法、TLS版本等信息。
   - **服务器响应**：服务器回应一个“ServerHello”消息，选择加密算法、TLS版本并发送服务器的数字证书。
   - **证书验证**：客户端使用服务器提供的证书验证服务器的身份。如果证书有效，客户端会生成一个“pre-master secret”并用服务器的公钥加密后发送给服务器。
   - **密钥交换**：服务器使用其私钥解密“pre-master secret”，双方使用这个密钥生成对称加密密钥（session key），用于加密后续的通信数据。
2. **数据加密和传输**
   - **加密数据**：客户端和服务器使用会话密钥对数据进行加密，然后进行数据传输。
   - **数据完整性**：数据不仅被加密，还通过消息认证码（MAC）进行完整性检查，防止数据被篡改。
3. **连接关闭**
   - **关闭连接**：当通信结束时，双方会通过“close_notify”消息来优雅地关闭连接，确保所有的数据都被正确传输。

**SSL/TLS 主要功能**

- **加密**：SSL/TLS通过对数据进行加密，保护数据在传输过程中不被窃取。
- **身份验证**：通过数字证书验证服务器的身份，防止中间人攻击。
- **数据完整性**：通过消息认证码（MAC）确保数据在传输过程中没有被篡改。

**常见的 SSL/TLS 证书类型**

- **自签名证书**：由证书持有者自己签发的证书，通常用于开发和测试环境，不被浏览器信任。
- **域名验证证书（DV）**：验证申请者对域名的控制权，适合个人和小型网站。
- **组织验证证书（OV）**：验证申请者的身份和组织合法性，适合企业和组织。
- **扩展验证证书（EV）**：提供最高级别的身份验证和信任，显示公司名称在地址栏中。

## 前端单页应用 History 路由模式， 需要如何配置 nginx？

前端单页应用使用 History 路由模式，需要将路由的控制交给前端，而不是后端处理，因此需要配置 nginx 让其将所有请求都指向 index.html 页面，让前端来处理路由。

具体配置可以参考以下 nginx 配置：

```
bashCopy codeserver {
    listen       80;
    server_name  example.com; # 域名或 IP 地址

    location / {
        root   /path/to/your/app; # 项目根目录
        index  index.html;
        try_files $uri $uri/ /index.html; # 将所有请求都指向 index.html 页面
    }
}
```

以上配置中，`try_files` 指令会尝试将请求映射到对应的文件，如果找不到，则会将请求转发到 `/index.html` 页面，由前端来处理路由。同时，`root` 指令需要指向前端应用的根目录。

## HTTP Header 中有哪些信息？

## 什么是 CDN？它的工作原理是什么？

## CORS 是如何实现跨域的？

CORS（Cross-Origin Resource Sharing）是一种用于实现跨域请求的机制，允许浏览器和服务器之间在不同源之间共享资源。CORS 通过在 HTTP 头部添加特定的字段来控制跨域访问。以下是 CORS 的工作原理及实现细节：

**1. CORS 工作原理**

**1.1 浏览器发起跨域请求**

当浏览器发起一个跨域请求时，它会先发送一个预检请求（preflight request），以检查服务器是否允许实际请求。这是通过发送一个 `OPTIONS` 请求来实现的，主要用于确认目标服务器是否允许跨域请求。

**1.2 服务器响应**

服务器需要在响应中包含适当的 CORS 头部，以指示是否允许跨域请求。主要的 CORS 头部包括：

- **`Access-Control-Allow-Origin`**：指定允许的源。可以是具体的域名，如 `https://example.com`，或通配符 `*`（允许所有源）。
- **`Access-Control-Allow-Methods`**：指定允许的方法，如 `GET`, `POST`, `PUT`, `DELETE`。
- **`Access-Control-Allow-Headers`**：指定允许的请求头，如 `Content-Type`, `Authorization`。
- **`Access-Control-Allow-Credentials`**：指示是否允许发送带有凭据（如 Cookies）的请求。
- **`Access-Control-Max-Age`**：指示预检请求的结果可以缓存的时间（以秒为单位）。

**1.3 客户端处理响应**

- **简单请求**：如果请求满足 CORS 规则（如使用 `GET` 或 `POST` 方法，且请求头仅包括简单头部），浏览器会直接发送实际请求并处理响应。
- **预检请求**：对于复杂请求（如使用 `PUT` 方法或带有自定义头部），浏览器会先发送 `OPTIONS` 请求，然后根据服务器的响应决定是否发送实际请求。

**2. 请求类型**

**2.1 简单请求**

满足以下条件的请求被认为是简单请求，不需要预检请求：

- 方法：`GET`, `POST`, `HEAD`
- 请求头：`Accept`, `Accept-Language`, `Content-Language`, `Content-Type`（值为 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`）

**2.2 复杂请求**

不符合简单请求条件的请求会被认为是复杂请求，需要先发送预检请求。复杂请求包括：

- 方法：`PUT`, `DELETE`, `OPTIONS`
- 请求头：`Authorization`, `Content-Type`（值为其他非简单值）

**3. 服务器设置**

**3.1 响应 CORS 头部**

服务器需要在响应中包含必要的 CORS 头部。例如：

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type, Authorization
```

**3.2 处理预检请求**

对于预检请求，服务器需要回应适当的 CORS 头部：

```
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 3600
```

**4. CORS 的安全性**

- **`Access-Control-Allow-Origin`**：避免使用通配符 `*`，特别是当使用 `Credentials` 时，以确保跨域请求只被信任的源访问。
- **`Access-Control-Allow-Credentials`**：当设置为 `true` 时，`Access-Control-Allow-Origin` 不能为 `*`，必须为具体的源。
- **`Access-Control-Allow-Headers`** 和 **`Access-Control-Allow-Methods`**：应限制仅允许必要的头部和方法，以减少安全风险。

## JSONP 是如何实现跨域的?

JSONP 的实现原理是通过添加一个 script 标签，指定 src 属性为跨域请求的 URL，而这个 URL 返回的不是 JSON 数据，而是一段可执行的 JavaScript 代码，这段代码会调用一个指定的函数，并且将 JSON 数据作为参数传入函数中。

例如，假设我们从 `http://example.com` 域名下请求数据，我们可以通过在 `http://example.com` 中添加如下代码实现 JSONP 请求：

```
function handleData(data) {
  // 处理获取到的数据
}

const script = document.createElement('script');
script.src = 'http://example.org/api/data?callback=handleData';
document.head.appendChild(script);
```

其中，我们指定了一个名为 `handleData` 的回调函数，并将这个函数名作为参数传递给了跨域请求的 URL 中的 callback 参数。服务器端返回的数据将会被包装在这个回调函数中，例如：

```
handleData({"name": "John", "age": 30});
```

在这个例子中，我们可以在 handleData 函数中处理获取到的数据。需要注意的是，在使用 JSONP 时，**需要保证服务器端返回的数据是一个可执行的 JavaScript 代码，并且必须使用指定的回调函数名来包装数据，否则无法正确处理数据。**

**如何获取 jsonp 的相应参数**

获取 JSONP 响应结果的方法有两种，**一种是通过回调函数参数获取**，**另一种是通过 script 标签加载完成后解析全局变量获取**。

假设服务器返回以下 JSONP 响应：

```javascript
callback({"name": "Alice", "age": 20});
```

其中 callback 是客户端定义的回调函数名，用于指定返回数据的处理方式。

我们可以使用以下两种方式获取响应结果：

**1. 通过回调函数参数获取** 在客户端定义一个全局函数作为回调函数，服务器返回的数据会作为回调函数的参数传入，这个参数可以在回调函数中处理。

```javascript
function handleResponse(data) {
  console.log(data.name); // Alice
  console.log(data.age); // 20
}

// 创建 script 标签
const script = document.createElement('script');
script.src = 'http://example.com/api?callback=handleResponse';

// 插入到文档中开始加载数据
document.body.appendChild(script);
```

**2. 通过全局变量获取** 在客户端定义一个全局函数作为回调函数，服务器返回的数据会作为一个全局变量赋值给该函数所在的对象，我们可以在 script 标签加载完成后解析全局变量获取响应结果。

```javascript
function handleResponse() {
  console.log(myData.name); // Alice
  console.log(myData.age); // 20
}

// 创建 script 标签
const script = document.createElement('script');
script.src = 'http://example.com/api?callback=handleResponse';

// 插入到文档中开始加载数据
document.body.appendChild(script);

// script 标签加载完成后解析全局变量
window.myData = {};
script.onload = () => {
  delete window.myData; // 删除全局变量
};
```

注意，使用 JSONP 时要注意安全问题，应该对返回的数据进行验证，避免接收到恶意代码。此外，JSONP **只能发送 GET 请求**，无法发送 POST 请求，**也无法使用 HTTP 请求头和请求体传递数据**。

## 什么是 HTTP 的持久连接？它的作用是什么？

（Keep-Alive）

## 简单请求和非简单请求的区别是什么？

（预检请求 Preflight）

## 什么是 XSS 攻击？如何防御？

## 什么是 CSRF 攻击？如何防御？

## 什么是 DDOS 攻击？如何防御？

## 什么是中间人攻击（MITM）？HTTPS 如何防止它？

## 如何防止点击劫持？相关 HTTP 头部是什么？

## 如何理解“同源策略”？如何解决跨域问题？

## 描述从输入 URL 到页面加载完成的整个过程

## WebSocket 和 HTTP 长轮询的区别是什么？

## WebRTC 是什么？它基于哪些协议？

## 什么是 SSE ？它与 WebSocket 有何区别？

## 什么是 JWT ？它的结构包含哪些部分？

## 什么是关键渲染路径？如何优化？

## 如何通过 preload、prefetch、preconnect 优化资源加载？

## 什么是 Brotli 压缩？与 Gzip 相比有何优势？

## 如何实现 HTTP 的链路复用？HTTP/2 如何支持它？

## 什么是负载均衡？

客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。将服务器接收到的请求按照规则分发的过程，称为负载均衡。

负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种。

- 硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动、中国联通这样的公司才会选择硬负载进行操作；
- 更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。
