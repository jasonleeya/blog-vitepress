---
category: 网络
order: 9
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>

# 网络

## HTTP/1.1 与 HTTP/2 的核心区别

- **多路复用**：HTTP/2 允许在一个 TCP 连接上并行传输多个请求/响应，解决队头阻塞问题12。
- **二进制分帧**：数据以二进制帧传输，提升解析效率16。
- **头部压缩**：HPACK 算法减少冗余头部传输16。
- **服务器推送**：服务端可主动推送资源（如 CSS/JS），减少请求延迟16。

## HTTP 2.0 和 3.0 有什么区别？

- HTTP/2.0 采用二进制格式传输数据，采用多路复用技术，可以只通过一个 TCP 连接传输所有的请求数据。采用头部压缩技术，解决了 HTTP/1.0 的 header 里携带的内容过大的问题。但是如果在传输的过程中存在丢包的情况的话，那么整个 TCP 就得重新传输，后面资源就会被阻塞。
- HTTP/3.0 放弃了 TCP 协议而是改用了 QUIC 协议，此协议基于传输层 UDP 协议。UDP 协议无需三次握手四次挥手，所以传输速率更高。并且它改善了多路复用产生的问题，如果出现丢包的情况，不需要整个重新发送，只需要重发丢掉的包就可以。HTTP/3.0 具有更低的延迟，效率甚至要比 HTTP/1.1 快 3 倍以上。 

## HTTP 和 HTTPS 有什么区别？



1. `HTTPS` 协议需要到 `CA` （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。

2. `HTTP` 是超文本传输协议，信息是明文传输，`HTTPS` 则是具有安全性的 `SSL` 加密传输协议。

3. `HTTP` 和 `HTTPS` 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是`443`。

4. `HTTP` 的连接很简单，是无状态的。`HTTPS` 协议是由 `SSL+HTTP` 协议构建的可进行加密传输、身份认证的网络协议，比 `HTTP` 协议安全。

## HTTPS 加密算法和加解密过程是啥？

**HTTPS 加密算法与加解密过程**  

HTTPS 通过 **混合加密机制** 保障安全性，结合非对称加密（密钥交换）和对称加密（数据传输），同时依赖数字证书认证身份。以下是核心流程和算法：

**一、核心加密算法**  

1. **非对称加密**（密钥交换）  
   - **算法**：RSA、ECDHE（椭圆曲线迪菲-赫尔曼）  
   - **用途**：安全协商对称密钥（如AES密钥），防止中间人窃听。  

2. **对称加密**（数据传输）  
   - **算法**：AES（128/256位）、ChaCha20  
   - **用途**：加密实际传输的HTTP数据，效率高且安全性强。  

3. **哈希算法**（完整性校验）  
   - **算法**：SHA-256、SHA-384  
   - **用途**：生成消息摘要，验证数据未被篡改。  

4. **数字签名**（身份认证）  
   - **算法**：RSA、ECDSA  
   - **用途**：CA机构对服务器证书签名，客户端验证证书合法性。  

**二、HTTPS 加解密流程（以TLS 1.3为例）**  

**1. TCP 三次握手**  

- 建立基础通信连接（明文）。  

**2. TLS 握手阶段**  
- **Client Hello**  
  - 客户端发送支持的TLS版本、加密套件列表、随机数（Client Random）。  

- **Server Hello**  
  - 服务端选择加密套件（如`TLS_AES_128_GCM_SHA256`），返回随机数（Server Random）、数字证书。  

- **证书验证**  
  - 客户端验证证书有效性（CA链校验、有效期、域名匹配等）。  

- **密钥交换**（ECDHE流程）  
  - 服务端发送椭圆曲线参数和公钥（Server Params），并签名保证真实性。  
  - 客户端生成临时密钥对，发送客户端公钥（Client Params）。  
  - 双方通过ECDHE算法生成 **预主密钥（Pre-Master Secret）**。  

- **生成会话密钥**  
  - 客户端和服务端基于 `Client Random`、`Server Random`、`Pre-Master Secret`，通过哈希算法生成 **对称密钥（Session Key）**。  

**3. 加密通信阶段**  
- 使用对称密钥（如AES）加密HTTP数据，通过哈希算法校验完整性。  

**三、关键步骤详解**  

1. **数字证书验证**  
   - 证书包含服务器公钥、域名、CA签名等信息。  
   - 浏览器内置信任的CA根证书，逐级验证证书链，确保服务器身份合法。  

2. **前向安全性（Forward Secrecy）**  
   - 使用ECDHE等临时密钥算法，每次会话生成独立密钥，即使长期私钥泄露，历史通信仍安全。  

3. **对称密钥生成**  
   - 通过HKDF（HMAC-based Key Derivation Function）扩展生成实际加密密钥。  

**四、前端相关实践**  

1. **配置强制HTTPS**  
   - HTTP 响应头添加 `Strict-Transport-Security (HSTS)`，强制浏览器使用HTTPS。  
2. **混合内容处理**  
   - 避免页面中混合加载HTTP资源（图片、脚本），否则浏览器会标记“不安全”。  
3. **证书监控**  
   - 使用工具（如Lighthouse）检测证书有效期和配置错误。  

**总结**  

HTTPS通过 **非对称加密交换密钥 + 对称加密传输数据 + 数字证书认证身份** 的三重机制，解决数据机密性、完整性和身份可信问题。  
**核心优势**：在高效传输的同时，抵御窃听、篡改和中间人攻击，是前端安全通信的基石。

## 说说网络分层里七层模型是哪七层

网络七层模型（OSI）是国际标准化组织定义的网络通信分层框架，从物理传输到应用服务逐层抽象。  

**具体分层**：  
1. **物理层**：传输原始比特流（如网线、光纤）；  
2. **数据链路层**：帧传输与MAC地址寻址（如交换机）；  
3. **网络层**：IP寻址与路由选择（如路由器）；  
4. **传输层**：端到端连接与可靠性（TCP/UDP）；  
5. **会话层**：建立/管理会话（如RPC）；  
6. **表示层**：数据格式转换与加密（如SSL/TLS）；  
7. **应用层**：用户接口与协议（HTTP/FTP）。  

前端开发主要关注**应用层（HTTP/WebSocket）**和**传输层（TCP）**。

## TCP 和 UDP 有什么区别？

TCP和UDP的核心区别在于**可靠性、连接方式及传输效率**，分别适用于不同场景。  

**具体差异**：  
1. **连接性**：  
   - **TCP**：面向连接（三次握手/四次挥手），确保可靠传输。  
   - **UDP**：无连接，直接发送数据包，无连接开销。  

2. **可靠性**：  
   - **TCP**：保证数据顺序、完整性，自动重传丢包。  
   - **UDP**：不保证送达，可能丢包或乱序。  

3. **传输效率**：  
   - **TCP**：因校验、重传、拥塞控制等机制，延迟较高。  
   - **UDP**：无额外控制，传输速度快，实时性高。  

4. **头部开销**：  
   - **TCP**：头部较大（20-60字节），包含序列号、确认号等字段。  
   - **UDP**：头部固定8字节，仅含端口和长度。  

**应用场景**：  
- **TCP**：HTTP/HTTPS、文件传输（FTP）、邮件（SMTP）等需可靠性的场景。  
- **UDP**：视频通话（如WebRTC）、直播流、DNS查询、在线游戏等实时性优先的场景。  

**总结**：需要可靠传输选TCP，追求实时高效选UDP。

## HTTP状态码及其含义

HTTP状态码用于表示请求的处理结果，分为五类，通过三位数字快速定位问题类型。  

**常见状态码**：  
1. **1xx（信息）**：请求已接收，继续处理（如101协议切换）。  
2. **2xx（成功）**：请求正常处理（200 OK，201 Created）。  
3. **3xx（重定向）**：需额外操作完成请求（301永久重定向，304缓存未修改）。  
4. **4xx（客户端错误）**：请求有误（400参数错误，401未授权，403禁止访问，404未找到资源）。  
5. **5xx（服务端错误）**：服务器处理失败（500内部错误，502网关错误，503服务不可用）。  

**前端关注重点**：  
- **200**：成功获取资源；  
- **304**：缓存生效，减少请求；  
- **404/403**：检查资源路径/权限；  
- **500/503**：提示用户或重试。

## 说是TCP的三次握手四次挥手

TCP的三次握手和四次挥手是建立与断开可靠连接的核心机制，确保数据传输的完整性和有序性。  

**三次握手（建立连接）**：  
1. **SYN**：客户端发送SYN（同步）报文，包含初始序列号（Seq=x）。  
2. **SYN-ACK**：服务端响应SYN+ACK（确认）报文，确认号=x+1，携带自身序列号（Seq=y）。  
3. **ACK**：客户端发送ACK（确认）报文，确认号=y+1，双方进入连接状态。  

**四次挥手（断开连接）**：  
1. **FIN**：主动方（如客户端）发送FIN（结束）报文，进入FIN_WAIT_1状态。  
2. **ACK**：被动方（如服务端）返回ACK确认，进入CLOSE_WAIT状态；主动方收到后进入FIN_WAIT_2状态。  
3. **FIN**：被动方处理完数据后发送FIN报文，进入LAST_ACK状态。  
4. **ACK**：主动方回复ACK确认，进入TIME_WAIT（等待2MSL确保对方收到），双方关闭连接。  

**关键点**：  
- **三次握手**：防止历史重复连接初始化（两次无法确认双方收发能力）。  
- **四次挥手**：TCP全双工特性需双向独立关闭，且确保数据完整传输（如服务端可能仍有数据发送）。



**通俗易懂版：**

TCP的三次握手和四次挥手就像两个人打电话时的沟通流程，确保双方都能正常交流后再开始对话，以及礼貌地结束通话后再挂断。

**三次握手（建立连接）**  

1. **第一次握手**：  
   - 客户端发送“打招呼”信号（SYN）：“我要和你通话，能听到吗？”  
   - 好比你打电话给朋友，先问：“喂，你在吗？”  

2. **第二次握手**：  
   - 服务端回复“收到”（SYN-ACK）：“我听到了！你能听到我吗？”  
   - 朋友回答：“我在！你能听到我吗？”  

3. **第三次握手**：  
   - 客户端确认“收到回复”（ACK）：“能听到，开始聊吧！”  
   - 你回应：“能听到，说吧！”  
   - **连接建立**，双方开始传输数据。

**为什么是三次？**  
- 避免网络延迟导致的“重复拨号”。比如你第一次问“在吗？”没回应，又重复问，如果对方只回一次，两次握手可能误判连接已建立。

**四次挥手（断开连接）**  

假设客户端主动挂断：  
1. **第一次挥手**：  
   - 客户端说：“我说完了，准备挂电话了。”（FIN）  
   - 比如你说：“今天先聊到这，我挂了啊。”  

2. **第二次挥手**：  
   - 服务端回复：“好的，知道了。”（ACK）  
   - 朋友说：“行，等我确认一下还有没有要说的。”  

3. **第三次挥手**：  
   - 服务端确认后也说：“我也说完了，可以挂了。”（FIN）  
   - 朋友补充：“对了，最后一点…好了，挂吧！”  

4. **第四次挥手**：  
   - 客户端最后确认：“收到，拜拜！”（ACK）  
   - 你回答：“好的，拜拜！”  
   - **连接关闭**，双方结束通话。

**为什么是四次？**  
- 因为挂电话要双方都确认。比如你说完挂断意图后，对方可能还有话要说，需要等对方说完再互相确认。

**总结**  

- **三次握手**：互相确认“能听清吗？”，防止自说自话。  
- **四次挥手**：互相确认“都说完了吗？”，防止突然挂断漏话。  

这种机制确保网络传输像真实对话一样可靠，不丢数据、不乱顺序。

## **HTTP GET 和 POST 请求有什么区别？**

HTTP GET 和 POST 请求的核心区别在于**用途、数据传输方式及安全性**，分别适用于获取资源和提交数据。  

**具体差异**：  
1. **用途**：  
   - **GET**：获取资源（如加载网页、查询数据），**幂等且可缓存**。  
   - **POST**：提交资源（如表单提交、文件上传），**非幂等且不缓存**。  

2. **数据传输**：  
   - **GET**：参数通过URL拼接（如 `?key=value`），**长度受限**（约2048字符）。  
   - **POST**：数据放在请求体（Body）中，**支持更大数据量和多种格式**（JSON、文件等）。  

3. **安全性**：  
   - **GET**：参数暴露在URL中，易被记录或泄露（如浏览器历史、日志）。  
   - **POST**：数据隐藏于Body，**相对安全**（但未加密时仍可被截获）。  

4. **幂等性**：  
   - **GET**：多次请求结果相同（如刷新页面）。  
   - **POST**：多次提交可能产生副作用（如重复下单）。  

**应用场景**：  
- **GET**：搜索、分页、静态资源加载。  
- **POST**：登录、注册、支付等敏感操作。  

**总结**：取数据用GET，传数据用POST；敏感信息避免GET，大数据量优先POST。

## Websoket 和HTTP有什么区别？

WebSocket 和 HTTP 的核心区别在于**通信模式与实时性**，前者支持全双工实时交互，后者基于短连接的请求-响应模式。  

**具体差异**：  
1. **连接方式**：  
   - **HTTP**：短连接，每次请求需重新建立TCP连接（HTTP/1.1后支持Keep-Alive，但本质仍是串行请求）。  
   - **WebSocket**：长连接，一次握手后保持连接，双方可主动推送数据。  

2. **通信模式**：  
   - **HTTP**：客户端发起请求 → 服务端响应（单向，实时性差）。  
   - **WebSocket**：客户端/服务端均可主动发送消息（双向实时通信）。  

3. **头部开销**：  
   - **HTTP**：每次请求携带完整头部（如Cookie、User-Agent），冗余开销大。  
   - **WebSocket**：建立连接后数据帧头部仅2~14字节，传输效率高。  

4. **适用场景**：  
   - **HTTP**：静态资源加载、RESTful API、传统网页交互。  
   - **WebSocket**：实时聊天、在线游戏、股票行情推送、协同编辑。  

5. **协议关系**：  
   - **WebSocket**：基于HTTP协议升级（握手阶段使用HTTP），建立后独立于HTTP运行。  

**总结**：需实时双向通信（如消息推送）用WebSocket，传统数据交互用HTTP。

## http中的post请求发生了两次（多了一次options请求）的原因

浏览器在发送某些跨域POST请求前会先发送**OPTIONS预检请求**，以确认服务器是否允许实际请求的方法和头信息，这是由CORS（跨域资源共享）安全机制触发的。  

**具体原因**：  
1. **非简单请求**：当POST请求满足以下任一条件时，触发预检：  
   - 自定义头部（如`Authorization`、`X-Custom-Header`）；  
   - `Content-Type`非简单值（如`application/json`）；  
   - 其他非安全方法或配置（如`DELETE`请求）。  

2. **预检流程**：  
   - **OPTIONS请求**：浏览器自动发送，询问服务器是否支持实际请求的方法和头；  
   - **服务器响应**：需返回`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers`等CORS头；  
   - **正式POST请求**：预检通过后，浏览器发送真实POST请求。  

**解决方案**：  
- **服务器配置**：正确处理OPTIONS请求，返回允许的跨域头；  
- **简化请求**：避免自定义头，使用简单`Content-Type`（如`application/x-www-form-urlencoded`）。

## 介绍下 HTTPS 中间人攻击

HTTPS中间人攻击（MITM）是攻击者伪装成通信双方拦截并篡改数据的行为，其核心绕过HTTPS的安全机制窃取敏感信息。  

**攻击过程与防御**：  
1. **攻击步骤**：  
   - **劫持连接**：攻击者通过ARP欺骗、恶意WiFi等手段成为通信中间代理。  
   - **伪造证书**：使用自签名证书或非法CA证书欺骗客户端（如用户忽略浏览器警告）。  
   - **解密中转**：拦截客户端与服务端的TLS握手，分别建立加密连接，明文获取数据。  

2. **HTTPS防御机制**：  
   - **证书链校验**：浏览器验证证书是否由可信CA签发，域名是否匹配，是否过期或被吊销。  
   - **加密传输**：通过非对称加密交换密钥，后续数据由对称加密保护（如AES-256）。  

3. **前端注意事项**：  
   - **禁用混合内容**：确保页面内所有资源（图片、脚本）均为HTTPS，避免降级攻击。  
   - **启用HSTS**：通过HTTP头`Strict-Transport-Security`强制浏览器仅使用HTTPS。  
   - **用户教育**：提示用户切勿在浏览器证书告警页面继续访问。  

**真实案例**：公共WiFi中攻击者伪造银行网站，诱导用户输入账号密码。HTTPS若正确配置可拦截此类攻击，但用户主动忽略证书错误仍会中招。

## DNS 协议了解多少？

DNS协议是互联网中将域名转换为IP地址的核心系统，确保用户通过易记的域名访问网络资源。  

**核心要点**：  
1. **核心功能**：  
   - **域名解析**：将`www.example.com`转换为`93.184.216.34`（IPv4）或`2606:2800:220:1:248:1893:25c8:1946`（IPv6）。  
   - **分层结构**：  
     - **根域名服务器**：全球13组，指向顶级域（如`.com`）。  
     - **顶级域（TLD）服务器**：管理`.com`、`.org`等后缀。  
     - **权威域名服务器**：托管具体域名的IP记录（如`example.com`）。  
     - **本地DNS服务器**：由ISP或企业提供，缓存查询结果。  

2. **查询流程**（以访问`www.example.com`为例）：  
   - **递归查询**（客户端→本地DNS）：  
     1. 客户端向本地DNS请求解析。  
     2. 本地DNS依次查询根→`.com`→`example.com`权威服务器，最终返回IP。  
   - **迭代查询**（本地DNS自主完成多级查询）。  

3. **记录类型**：  
   - **A记录**：IPv4地址。  
   - **AAAA记录**：IPv6地址。  
   - **CNAME**：域名别名（如将`blog.example.com`指向`example.com`）。  
   - **MX记录**：邮件服务器地址（如`mail.example.com`）。  
   - **TXT记录**：文本信息（如SPF反垃圾邮件配置）。  

4. **协议细节**：  
   - **传输协议**：默认UDP 53端口（快速），数据超512字节或区域传输时用TCP。  
   - **缓存机制**：TTL（生存时间）控制缓存有效期，减少重复查询。  

5. **安全性**：  
   - **DNS劫持**：篡改解析结果（如恶意WiFi）。  
   - **DNSSEC**：通过数字签名验证响应真实性，防篡改。  
   - **DoH/DoT**：DNS over HTTPS/TLS加密查询，防窃听。  

**前端相关**：  
- **性能优化**：减少DNS查询次数（合并域名、预解析`<link rel="dns-prefetch">`）。  
- **CDN加速**：通过智能DNS解析用户至最近节点。  

**示例命令**：  
```bash  
nslookup www.example.com      # 查询A记录  
dig example.com MX            # 查询MX记录  
```

**总结**：DNS是互联网的“电话簿”，其高效解析依赖分层架构与缓存，安全性需结合DNSSEC和加密协议保障。

## 什么是正向代理，反向代理?

正向代理是**客户端**的代理，帮助客户端访问外部资源；反向代理是**服务端**的代理，替服务器接收并分发客户端请求。  

**正向代理（Forward Proxy）**  

**特点**：  
- **代理对象**：代表客户端（如浏览器）访问目标服务器。  
- **隐藏客户端**：目标服务器只知道代理的IP，无法识别真实用户。  
- **用途**：  
  - 突破访问限制（如科学上网）；  
  - 统一控制客户端访问权限（如企业内网过滤）；  
  - 缓存资源加速访问（如代理服务器缓存静态文件）。  
  **示例工具**：Shadowsocks、Squid、Charles（开发调试）。  

**反向代理（Reverse Proxy）**  

**特点**：  
- **代理对象**：代表服务端接收客户端请求，转发到内部服务器。  
- **隐藏服务端**：客户端不知道真实服务器IP，仅与代理交互。  
- **用途**：  
  - 负载均衡（如Nginx轮询分发请求到多台服务器）；  
  - 安全防护（如隐藏后端服务，防御DDoS攻击）；  
  - 统一SSL加密（由代理处理HTTPS，降低后端压力）；  
  - 路由分发（如根据URL路径指向不同服务）。  
  **示例工具**：Nginx、HAProxy、Cloudflare CDN。  

**对比总结**  

| **特征**       | 正向代理               | 反向代理                   |
| -------------- | ---------------------- | -------------------------- |
| **代理方向**   | 客户端→代理→外部服务器 | 客户端→代理→内部服务器     |
| **隐藏对象**   | 客户端IP               | 服务端IP和架构             |
| **客户端感知** | 需配置代理地址         | 无感知，代理对客户端透明   |
| **典型场景**   | 内网翻墙、缓存加速     | 负载均衡、SSL卸载、API网关 |

**前端应用场景**：  
- **正向代理**：本地开发中配置Webpack代理解决跨域（如`devServer.proxy`）；  
- **反向代理**：生产环境用Nginx转发请求，实现动静分离或接口聚合。

## 什么是 JWT

JWT（JSON Web Token）是一种**开放标准（RFC 7519）的轻量级身份验证和授权协议**，通过JSON格式安全传输信息，通常用于无状态的用户身份验证。

**核心组成**  

1. **Header（头部）**：  
   - 声明令牌类型（`typ: "JWT"`）和签名算法（如`alg: "HS256"`）。  
   - 示例：`{"alg": "HS256", "typ": "JWT"}` → Base64编码。  

2. **Payload（载荷）**：  
   - 携带用户身份数据（如用户ID、角色）和其他声明（如过期时间`exp`、签发者`iss`）。  
   - 示例：`{"sub": "123", "name": "Alice", "exp": 1717020000}` → Base64编码。  

3. **Signature（签名）**：  
   - 对前两部分拼接后的字符串，通过密钥（如`secretKey`）和指定算法（如HMAC SHA256）生成签名，防止数据篡改。  
   - 公式：`签名 = HMACSHA256(base64(Header) + "." + base64(Payload), secretKey)`  

**工作流程**  

1. **登录认证**：  
   - 用户提交凭证（如账号密码），服务端验证通过后生成JWT返回客户端。  
2. **携带令牌**：  
   - 客户端后续请求在`Authorization`头中添加`Bearer <JWT>`。  
3. **服务端验证**：  
   - 解析JWT签名是否有效，校验载荷（如是否过期）后授权访问。  

**优点**  

- **无状态**：服务端无需存储会话（如Session），适合分布式系统。  
- **跨域支持**：轻松实现单点登录（SSO）。  
- **数据自包含**：减少数据库查询（如直接从Payload读取用户ID）。  

**缺点与注意事项**  

- **无法主动失效**：令牌在过期前有效（可通过黑名单或短有效期缓解）。  
- **数据暴露风险**：Payload仅Base64编码，敏感信息需加密（如JWE）。  
- **存储安全**：前端需防XSS攻击（避免`localStorage`，优先`HttpOnly Cookie`）。  

**前端应用示例**  

```javascript  
// 存储JWT  
localStorage.setItem('token', jwt);  

// 请求时携带  
fetch('/api/data', {  
  headers: {  
    'Authorization': `Bearer ${localStorage.getItem('token')}`  
  }  
});  
```

**总结**：JWT适用于无状态、跨服务的认证场景，但需结合业务权衡安全性与便利性。

## 如何避免缓存问题导致的资源更新失败？

避免缓存导致资源更新失败的核心策略是**强制客户端获取最新版本**，可通过文件名哈希、版本号或缓存控制头实现。  

**具体方法**：  
1. **文件名哈希**：  
   - 构建工具（如Webpack）为资源生成唯一哈希（如`app.a3b4c5.js`），文件内容变化则哈希改变，直接更新引用路径。  

2. **查询参数版本化**：  
   - 在资源URL后添加版本参数（如`style.css?v=2.0.0`），更新版本号即可刷新缓存。  

3. **HTTP缓存头控制**：  
   - **HTML文件**：设置`Cache-Control: no-cache`或`max-age=0`，确保始终验证更新。  
   - **静态资源**：设置长缓存`Cache-Control: max-age=31536000`，依赖文件名哈希（内容变则URL变）。  

4. **服务端配置**：  
   - CDN或Nginx配置`ETag`/`Last-Modified`，结合内容变化自动刷新缓存。  

**示例**：  
```html  
<!-- 文件名哈希 -->  
<script src="/app.3e4f5a.js"></script>  

<!-- 查询参数 -->  
<link href="/styles.css?v=20231001" rel="stylesheet">  
```

**总结**：哈希文件名是生产环境最佳实践，开发环境可结合禁用缓存（如Chrome DevTools禁用缓存选项）快速调试。

## HTTPS 中的 SSL/TLS 是什么？

HTTPS（Hypertext Transfer Protocol Secure）是HTTP的安全版本，它通过SSL/TLS协议对数据进行加密，确保数据在传输过程中保持机密性和完整性。下面是对SSL和TLS的详细介绍：

**SSL（Secure Sockets Layer）**

- **定义**：SSL是最早的安全协议，用于在网络上加密传输的数据。它确保数据在客户端和服务器之间的传输是安全的。
- **历史**：SSL最初由Netscape开发，主要包括SSL 2.0和SSL 3.0两个版本。由于SSL 2.0和SSL 3.0存在一些安全漏洞，它们已经被淘汰。

**TLS（Transport Layer Security）**

- **定义**：TLS是SSL的继任者，是一种用于保护网络通信的加密协议。TLS对数据进行加密，确保数据在传输过程中不被窃取或篡改。
- **版本**：TLS 从 TLS 1.0 开始，到当前的 TLS 1.3。每个版本都在前一个版本的基础上进行改进，增强了安全性和性能。

**SSL/TLS 工作原理**

1. **握手过程（Handshake）**
   - **客户端发起连接**：客户端向服务器发送一个“ClientHello”消息，包含了客户端支持的加密算法、TLS版本等信息。
   - **服务器响应**：服务器回应一个“ServerHello”消息，选择加密算法、TLS版本并发送服务器的数字证书。
   - **证书验证**：客户端使用服务器提供的证书验证服务器的身份。如果证书有效，客户端会生成一个“pre-master secret”并用服务器的公钥加密后发送给服务器。
   - **密钥交换**：服务器使用其私钥解密“pre-master secret”，双方使用这个密钥生成对称加密密钥（session key），用于加密后续的通信数据。
2. **数据加密和传输**
   - **加密数据**：客户端和服务器使用会话密钥对数据进行加密，然后进行数据传输。
   - **数据完整性**：数据不仅被加密，还通过消息认证码（MAC）进行完整性检查，防止数据被篡改。
3. **连接关闭**
   - **关闭连接**：当通信结束时，双方会通过“close_notify”消息来优雅地关闭连接，确保所有的数据都被正确传输。

**SSL/TLS 主要功能**

- **加密**：SSL/TLS通过对数据进行加密，保护数据在传输过程中不被窃取。
- **身份验证**：通过数字证书验证服务器的身份，防止中间人攻击。
- **数据完整性**：通过消息认证码（MAC）确保数据在传输过程中没有被篡改。

**常见的 SSL/TLS 证书类型**

- **自签名证书**：由证书持有者自己签发的证书，通常用于开发和测试环境，不被浏览器信任。
- **域名验证证书（DV）**：验证申请者对域名的控制权，适合个人和小型网站。
- **组织验证证书（OV）**：验证申请者的身份和组织合法性，适合企业和组织。
- **扩展验证证书（EV）**：提供最高级别的身份验证和信任，显示公司名称在地址栏中。

## 前端单页应用 History 路由模式， 需要如何配置 nginx？

前端单页应用使用 History 路由模式，需要将路由的控制交给前端，而不是后端处理，因此需要配置 nginx 让其将所有请求都指向 index.html 页面，让前端来处理路由。

具体配置可以参考以下 nginx 配置：

```
bashCopy codeserver {
    listen       80;
    server_name  example.com; # 域名或 IP 地址

    location / {
        root   /path/to/your/app; # 项目根目录
        index  index.html;
        try_files $uri $uri/ /index.html; # 将所有请求都指向 index.html 页面
    }
}
```

以上配置中，`try_files` 指令会尝试将请求映射到对应的文件，如果找不到，则会将请求转发到 `/index.html` 页面，由前端来处理路由。同时，`root` 指令需要指向前端应用的根目录。
