---
category: 算法
order: 6
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 算法

## 说说你对算法的理解，应用场景？

我对算法的理解是**用高效、明确的步骤解决特定问题**。在前端开发中，算法常用于以下场景：

1. **性能优化**：如虚拟滚动通过计算可视区域动态渲染，减少DOM操作；
2. **数据处理**：如复杂表单联动时，用拓扑排序解决依赖关系校验；
3. **交互逻辑**：如拖拽排序结合稳定排序算法，保证用户体验一致性；
4. **框架底层**：如虚拟DOM Diff策略减少渲染开销。
   我习惯在需求中识别算法切入点，例如曾用LRU缓存策略优化H5页面资源加载速度，并持续通过LeetCode保持逻辑敏感度。

## 说说你对数据结构的理解？有哪些？区别？

**数据结构是数据组织和操作的逻辑模型**，核心在于**平衡存储效率与操作性能**。常见类型及区别：  

1. **线性结构**  
   - **数组**：连续内存，通过索引快速访问，但插入/删除成本高（需移动元素）；  
   - **链表**：节点离散存储，通过指针连接，增删高效但查询需遍历；  
   - **栈（LIFO）**：函数调用栈、撤销操作；  
   - **队列（FIFO）**：异步任务队列、浏览器事件循环。  

2. **非线性结构**  
   - **树**：层级关系，如DOM树、组件树，B+树用于数据库索引；  
   - **图**：多对多关联，如社交网络关系、依赖分析（Webpack模块图）；  
   - **哈希表**：键值映射（JS的`Map`），通过哈希函数快速存取，冲突用拉链法/开放寻址解决。  

**前端典型场景**：  
- 虚拟DOM用树结构比对差异；  
- 路由历史管理用栈结构；  
- 防抖/节流任务调度用队列；  
- LocalStorage缓存淘汰策略（如LRU）依赖哈希表+双向链表。

## 什么是时间复杂度，空间复杂度？

**时间复杂度**衡量算法执行时间随数据规模增长的趋势，**空间复杂度**衡量算法内存消耗的增速，二者都用大O表示法描述。

**前端典型场景**：

- **时间复杂度**：
  - 遍历数组操作 → O(n)
  - 双重循环比对节点 → O(n²)（需警惕性能瓶颈）
  - 虚拟DOM Diff优化 → 通过Key策略降为O(n)
- **空间复杂度**：
  - 递归调用层级 → O(n)（可能栈溢出）
  - 深拷贝对象 → O(n)（内存翻倍需谨慎）
  - 状态管理库内存占用 → 关注数据缓存策略

理解复杂度能帮助在编码时权衡性能，例如用哈希表（O(1)查询）替代数组遍历（O(n)）来优化高频操作。

## 什么是链表？如何实现一个简单的单链表？

**链表**是由节点组成的线性数据结构，每个节点包含**数据域**和**指针域**（指向下个节点），内存非连续存储。与数组相比，链表插入/删除高效（O(1)~O(n)），但随机访问低效（O(n)）。

**JavaScript实现单链表**：

```javascript
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
  }

  // 尾部添加节点
  append(value) {
    const newNode = new Node(value);
    if (!this.head) {
      this.head = newNode;
      return;
    }
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = newNode;
  }

  // 删除匹配的第一个节点
  delete(value) {
    if (!this.head) return;
    if (this.head.value === value) {
      this.head = this.head.next;
      return;
    }
    let current = this.head;
    while (current.next) {
      if (current.next.value === value) {
        current.next = current.next.next;
        return;
      }
      current = current.next;
    }
  }
}

// 示例
const list = new LinkedList();
list.append(1);
list.append(2);
list.delete(1); // 删除头节点
```

**关键点**：

1. **插入**：遍历到尾节点修改指针（O(n)）；
2. **删除**：需定位前驱节点（如删除头节点特殊处理）；
3. **应用场景**：React Fiber架构中任务调度队列、浏览器历史记录管理等。

## 说说你对树的理解？应用场景？

**树是层级化的非线性数据结构**，核心特征是节点间存在父子关系且无循环。前端典型场景：

1. **DOM树**：浏览器解析HTML生成的节点树，前端框架（如React/Vue）通过虚拟DOM Diff算法比对树结构差异，高效更新视图。
2. **组件树**：React Fiber架构将组件关系抽象为树，实现任务优先级调度和异步渲染。
3. **路由配置**：嵌套路由用树形结构管理（如Vue Router的children），动态生成导航菜单。
4. **数据结构优化**：
   - 二叉搜索树：快速查找（时间复杂度O(logn)）
   - Trie树：自动补全/关键词过滤（前缀匹配）
   - 决策树：可视化配置工具的条件分支逻辑

**实现示例（二叉树遍历）**：

```javascript
class TreeNode {  
  constructor(value) {  
    this.value = value;  
    this.left = null;  
    this.right = null;  
  }  
}  

// 前序遍历（根-左-右）  
function preorder(root) {  
  if (!root) return [];  
  return [root.value, ...preorder(root.left), ...preorder(root.right)];  
}  

// 应用场景：克隆组件树结构  
const cloneTree = (node) => {  
  if (!node) return null;  
  const newNode = new TreeNode(node.value);  
  newNode.left = cloneTree(node.left);  
  newNode.right = cloneTree(node.right);  
  return newNode;  
};  
```

树的优势在于**天然映射层级关系**，适合处理嵌套数据和递归逻辑，但需警惕深层次遍历的性能问题（如栈溢出）。

## 说说你对堆，栈，队列的理解？应用场景？

**堆、栈、队列是三种基础数据结构**，核心区别在于**操作规则与使用场景**：  

**1. 栈（Stack）**  

- **特性**：后进先出（LIFO），仅允许在栈顶操作（push/pop）。  
- **前端应用**：  
  - **函数调用栈**：执行上下文压栈/弹栈（递归调用时的堆栈溢出问题）；  
  - **撤销操作**：编辑器或表单的Undo/Redo（如用两个栈实现历史记录）；  
  - **路由管理**：浏览器History API的`pushState`和`popState`；  
  - **算法场景**：括号匹配、DFS非递归实现。  

**代码示例**：  
```javascript  
// 用数组模拟栈实现撤销功能  
class UndoStack {  
  constructor() {  
    this.stack = [];  
    this.index = -1;  
  }  
  push(action) {  
    this.stack[++this.index] = action;  
    this.stack.length = this.index + 1; // 截断后续记录  
  }  
  undo() {  
    if (this.index < 0) return null;  
    return this.stack[this.index--];  
  }  
  redo() {  
    if (this.index >= this.stack.length - 1) return null;  
    return this.stack[++this.index];  
  }  
}  
```

**2. 队列（Queue）**  

- **特性**：先进先出（FIFO），队尾入队（enqueue）、队头出队（dequeue）。  
- **前端应用**：  
  - **事件循环**：宏任务队列（如setTimeout）、微任务队列（Promise）；  
  - **异步请求控制**：并发请求队列（如限制同时最多5个请求）；  
  - **动画调度**：保证动画执行顺序（如GSAP的TweenMax队列）；  
  - **算法场景**：BFS层级遍历、缓存淘汰策略（如最近最少使用队列）。  

**代码示例**：  
```javascript  
// 请求并发控制队列  
class RequestQueue {  
  constructor(concurrency) {  
    this.queue = [];  
    this.concurrency = concurrency;  
    this.running = 0;  
  }  
  add(requestFn) {  
    return new Promise((resolve, reject) => {  
      this.queue.push({ requestFn, resolve, reject });  
      this.next();  
    });  
  }  
  next() {  
    while (this.running < this.concurrency && this.queue.length) {  
      const { requestFn, resolve, reject } = this.queue.shift();  
      this.running++;  
      requestFn().then(resolve).catch(reject).finally(() => {  
        this.running--;  
        this.next();  
      });  
    }  
  }  
}  
```

**3. 堆（Heap）**  

- **特性**：完全二叉树结构，根节点为极值（最大堆/最小堆）。  
- **前端应用**：  
  - **优先级队列**：React Scheduler中的任务调度（高优先级任务优先执行）；  
  - **Top K问题**：日志系统中统计高频报错类型；  
  - **性能监控**：统计页面加载时间的P90/P99分位值（无需全排序）；  
  - **算法场景**：堆排序、合并K个有序链表。  

**逻辑示例（React Scheduler中的堆应用）**：  
```javascript  
// 简化版最小堆实现任务优先级调度  
class MinHeap {  
  constructor() {  
    this.heap = [];  
  }  
  push(task) {  
    this.heap.push(task);  
    this.bubbleUp(this.heap.length - 1);  
  }  
  pop() {  
    const min = this.heap[0];  
    const end = this.heap.pop();  
    if (this.heap.length > 0) {  
      this.heap[0] = end;  
      this.sinkDown(0);  
    }  
    return min;  
  }  
  // 上浮与下沉操作（具体实现略）  
}  

// 任务调度器使用堆管理任务  
const scheduler = new MinHeap();  
scheduler.push({ priority: 1, task: renderComponentA });  
scheduler.push({ priority: 0, task: urgentUpdateB }); // 更高优先级  
const nextTask = scheduler.pop(); // 优先执行priority 0的任务  
```

**总结**  

- **栈**：LIFO，适合对称性操作（如函数调用）；  
- **队列**：FIFO，保证顺序公平性（如异步任务）；  
- **堆**：动态极值获取，优化高频查询场景（如优先级调度）。

## 什么是图？

**图（Graph）** 是由 **节点（顶点）** 和 **边** 组成的非线性数据结构，用于描述多对多关系。其核心特点是能表达复杂关联性，主要分两类：  
- **有向图**：边有方向（如A→B），如任务依赖关系、微博关注网络；  
- **无向图**：边无方向（如A-B），如社交好友关系、地铁线路图。  

**前端典型应用场景**  

1. **依赖分析**  
   - Webpack 模块依赖图：解析文件间的`import/require`关系，构建有向图进行打包顺序优化；  
   - 循环依赖检测：通过遍历图判断是否存在环（如使用DFS+路径记录）。  

2. **可视化工具**  
   - 低代码平台的节点连线（如流程图设计器）；  
   - 组织架构图、知识图谱渲染。  

3. **状态管理**  
   - 复杂表单的字段关联关系（如某个选项触发多个字段显隐）；  
   - 前端路由权限的节点访问控制（如角色与页面的关联图）。  

**代码示例（邻接表实现图）**  

```javascript  
class Graph {  
  constructor() {  
    this.nodes = new Map(); // 节点表：key为节点ID，value为相邻节点集合  
  }  

  // 添加节点  
  addNode(node) {  
    if (!this.nodes.has(node)) {  
      this.nodes.set(node, new Set());  
    }  
  }  

  // 添加有向边（A→B）  
  addDirectedEdge(from, to) {  
    if (this.nodes.has(from) && this.nodes.has(to)) {  
      this.nodes.get(from).add(to);  
    }  
  }  

  // 检测循环依赖（DFS）  
  hasCycle() {  
    const visited = new Map();  
    const recursionStack = new Map();  

    const dfs = (node) => {  
      if (recursionStack.get(node)) return true;  
      if (visited.get(node)) return false;  

      visited.set(node, true);  
      recursionStack.set(node, true);  

      const neighbors = this.nodes.get(node);  
      for (const neighbor of neighbors) {  
        if (dfs(neighbor)) return true;  
      }  

      recursionStack.set(node, false);  
      return false;  
    };  

    for (const [node] of this.nodes) {  
      if (dfs(node)) return true;  
    }  
    return false;  
  }  
}  

// 示例：检测模块依赖是否有环  
const graph = new Graph();  
graph.addNode('A');  
graph.addNode('B');  
graph.addNode('C');  
graph.addDirectedEdge('A', 'B');  
graph.addDirectedEdge('B', 'C');  
graph.addDirectedEdge('C', 'A'); // 形成A→B→C→A的环  
console.log(graph.hasCycle()); // true  
```

**图的算法与前端结合**  

- **最短路径**：可视化地图路径规划（如Dijkstra算法）；  
- **拓扑排序**：构建任务执行顺序（如Vite的插件执行顺序）；  
- **连通性检测**：判断组件树的子模块是否可独立卸载。  

图的优势在于 **灵活表达复杂关系**，但需注意大规模数据下的性能问题（如遍历优化、内存占用）。

## 什么是哈希表？如何使用对象实现一个简单的哈希表？

**哈希表（Hash Table）** 是通过哈希函数将键映射到存储位置的数据结构，实现高效查找（理想时间复杂度O(1)）。核心是解决**哈希冲突**，常见方法有链地址法和开放寻址法。  

**JavaScript实现简单哈希表（链地址法）**  

```javascript  
class HashTable {  
  constructor(size = 32) {  
    this.buckets = new Array(size).fill(null).map(() => []); // 每个桶用数组存键值对  
    this.size = size;  
  }  

  // 哈希函数（简单示例：ASCII码累加取模）  
  _hash(key) {  
    let hash = 0;  
    const strKey = String(key);  
    for (let i = 0; i < strKey.length; i++) {  
      hash += strKey.charCodeAt(i);  
    }  
    return hash % this.size;  
  }  

  // 插入/更新键值对  
  set(key, value) {  
    const index = this._hash(key);  
    const bucket = this.buckets[index];  
    const existing = bucket.find((pair) => pair[0] === key);  
    if (existing) {  
      existing[1] = value; // 更新已有键  
    } else {  
      bucket.push([key, value]); // 新增键值对  
    }  
  }  

  // 获取值  
  get(key) {  
    const index = this._hash(key);  
    const bucket = this.buckets[index];  
    const pair = bucket.find((pair) => pair[0] === key);  
    return pair ? pair[1] : undefined;  
  }  

  // 删除键  
  delete(key) {  
    const index = this._hash(key);  
    const bucket = this.buckets[index];  
    const pairIndex = bucket.findIndex((pair) => pair[0] === key);  
    if (pairIndex >= 0) {  
      bucket.splice(pairIndex, 1);  
      return true;  
    }  
    return false;  
  }  
}  

// 使用示例  
const table = new HashTable();  
table.set('name', 'Alice');  
table.set('age', 30);  
console.log(table.get('name')); // Alice  
table.delete('age');  
console.log(table.get('age')); // undefined  
```

**关键点解析**  

1. **哈希函数设计**：  
   - 目标：均匀分布键以减少冲突；  
   - 示例中用ASCII码累加取模，实际生产环境需更复杂算法（如djb2）。  

2. **冲突处理**：  
   - **链地址法**：同一索引的键值对存入数组/链表，查找时遍历；  
   - **开放寻址法**：冲突时探测下一个空位（如线性探测）。  

3. **前端应用场景**：  
   - 快速缓存数据（如React Fiber节点的缓存查询）；  
   - 路由参数解析（键值对存储）；  
   - 状态管理库（如Redux中的快速状态索引）。  

4. **性能优化**：  
   - **动态扩容**：当负载因子（元素数/桶数）超过阈值时，倍增桶数并重新哈希；  
   - **哈希函数优化**：减少碰撞概率（如使用质数模数）。  

**哈希表与JavaScript对象的差异**  

- **键类型**：对象仅支持字符串/Symbol键，哈希表可支持任意类型（需序列化处理）；  
- **顺序性**：ES6后对象保留插入顺序，哈希表通常无序；  
- **冲突处理**：对象内部使用更复杂的优化策略（如V8引擎的隐藏类）。  

通过手动实现哈希表，能更深入理解数据结构原理及其在前端性能优化中的潜在价值。

## 如何实现深度优先搜索（DFS）和广度优先搜索（BFS）？


**深度优先搜索（DFS）**  

**核心思想**：尽可能深地遍历分支，直到末端再回溯。  

**实现方式**：  
1. **递归法**（隐式调用栈）：  
```javascript  
function dfs(node) {  
  if (!node) return;  
  console.log(node.value); // 处理当前节点  
  node.children.forEach(child => dfs(child));  
}  
```
2. **迭代法**（显式使用栈）：  
```javascript  
function dfs(root) {  
  const stack = [root];  
  while (stack.length) {  
    const node = stack.pop();  
    console.log(node.value);  
    // 子节点逆序入栈以保证顺序正确（如左→右）  
    node.children.slice().reverse().forEach(child => stack.push(child));  
  }  
}  
```
**应用场景**：  
- DOM树遍历（如查找嵌套组件）；  
- 路径探索（如迷宫问题）；  
- 依赖解析（Webpack模块循环检测）。  

**广度优先搜索（BFS）**  

**核心思想**：逐层遍历，先处理离根节点最近的节点。  

**实现方式**（使用队列）：  
```javascript  
function bfs(root) {  
  const queue = [root];  
  while (queue.length) {  
    const node = queue.shift(); // 改用索引（如指针）优化性能  
    console.log(node.value);  
    node.children.forEach(child => queue.push(child));  
  }  
}  
```
**优化队列**（避免`shift`低效）：  
```javascript  
function bfsOptimized(root) {  
  const queue = [root];  
  let index = 0; // 手动维护指针  
  while (index < queue.length) {  
    const node = queue[index++];  
    console.log(node.value);  
    node.children.forEach(child => queue.push(child));  
  }  
}  
```
**应用场景**：  
- 最短路径问题（如社交网络好友层级）；  
- 按层级渲染组件（如树形表格）；  
- 任务调度（如异步请求并发控制）。  

**关键对比**  

| 特性             | DFS                | BFS                 |
| ---------------- | ------------------ | ------------------- |
| **数据结构**     | 栈（LIFO）         | 队列（FIFO）        |
| **空间复杂度**   | O(h)（h为树高度）  | O(w)（w为最大宽度） |
| **适用场景**     | 深层遍历、路径探索 | 层级遍历、最短路径  |
| **前端典型应用** | 递归组件渲染       | 路由权限层级校验    |

**图的遍历注意事项**  

若处理图结构（含循环引用），需记录已访问节点：  
```javascript  
// DFS（图）  
function dfsGraph(node, visited = new Set()) {  
  if (visited.has(node)) return;  
  visited.add(node);  
  console.log(node.value);  
  node.neighbors.forEach(neighbor => dfsGraph(neighbor, visited));  
}  

// BFS（图）  
function bfsGraph(startNode) {  
  const queue = [startNode];  
  const visited = new Set([startNode]);  
  while (queue.length) {  
    const node = queue.shift();  
    console.log(node.value);  
    node.neighbors.forEach(neighbor => {  
      if (!visited.has(neighbor)) {  
        visited.add(neighbor);  
        queue.push(neighbor);  
      }  
    });  
  }  
}  
```

**总结**  

- **DFS** 通过栈实现深度探索，适合解决“是否存在路径”问题；  
- **BFS** 通过队列实现层级扩展，适合解决“最短路径”问题；  
- 根据业务场景选择算法，例如前端组件树遍历多用DFS，权限校验层级多用BFS。

## 说说你对二分查找的理解？应用场景？


**二分查找理解**  

二分查找是**针对有序数据的高效搜索算法**，核心通过 **“折半淘汰”** 缩小范围，时间复杂度 **O(logn)**。关键点：  
1. **前提条件**：数据必须有序（或可间接排序）；  
2. **核心操作**：取中间值比较，动态调整左右边界；  
3. **终止条件**：左边界超过右边界。  

**前端应用场景**  

1. **性能优化**  
   - 日志时间戳快速定位（如监控系统按时间排序的日志）；  
   - 长列表渲染时计算可视区域起始索引（虚拟列表优化）。  

2. **功能实现**  
   - 自动补全建议词匹配（有序词库中查找前缀）；  
   - 版本号比较（如语义化版本数组中找到最近的兼容版本）。  

3. **框架底层**  
   - React Scheduler 中任务优先级排序；  
   - Babel 插件按条件范围匹配 AST 节点。  

**代码实现（JavaScript）**  

```javascript  
function binarySearch(sortedArray, target) {  
  let left = 0;  
  let right = sortedArray.length - 1;  

  while (left <= right) {  
    const mid = Math.floor((left + right) / 2);  
    const midVal = sortedArray[mid];  

    if (midVal === target) {  
      return mid; // 找到目标  
    } else if (midVal < target) {  
      left = mid + 1; // 淘汰左半区  
    } else {  
      right = mid - 1; // 淘汰右半区  
    }  
  }  
  return -1; // 未找到  
}  

// 示例  
const arr = [1, 3, 5, 7, 9];  
console.log(binarySearch(arr, 5)); // 2  
```

**边界与变种问题**  

1. **重复元素**：  
   - 查找第一个/最后一个匹配项（如LeetCode 34题）；  
2. **非显式有序**：  
   - 旋转排序数组查找（如LeetCode 33题）；  
3. **抽象场景**：  
   - 数值范围二分（如求平方根）。  

**注意事项**  

- **数值溢出**：`mid = left + (right - left) >> 1` 替代 `(left+right)/2`；  
- **浮点处理**：精度控制（如保留小数位）；  
- **业务结合**：数据是否频繁变动（决定是否维护排序成本）。  

二分查找的价值在于 **用有序性换时间效率**，适合前端大数据量下的性能敏感场景。

## 说说你对动态规划的理解？应用场景？

**动态规划（DP）** 是通过 **拆解子问题+复用中间解** 解决复杂问题的策略，核心是 **状态转移方程** 和 **最优子结构**。  

**前端应用场景**  

1. **性能优化**  
   - 虚拟DOM Diff中最小化操作（如最长公共子序列算法优化移动逻辑）；  
   - 资源预加载策略（按依赖关系动态规划加载顺序）。  

2. **交互逻辑**  
   - 富文本差异比对（如协同编辑的OT算法中状态合并）；  
   - 动画路径规划（贝塞尔曲线关键帧的最优插值计算）。  

3. **数据处理**  
   - 文本相似度计算（如Levenshtein最短编辑距离）；  
   - 动态表单校验（多步骤校验结果复用）。  

**代码示例（最短编辑距离）**  

```javascript  
function minEditDistance(strA, strB) {  
  const [m, n] = [strA.length, strB.length];  
  const dp = Array(m+1).fill().map(() => Array(n+1).fill(0));  

  // 初始化边界条件  
  for (let i = 0; i <= m; i++) dp[i][0] = i;  
  for (let j = 0; j <= n; j++) dp[0][j] = j;  

  for (let i = 1; i <= m; i++) {  
    for (let j = 1; j <= n; j++) {  
      if (strA[i-1] === strB[j-1]) {  
        dp[i][j] = dp[i-1][j-1]; // 字符相同无需操作  
      } else {  
        dp[i][j] = Math.min(  
          dp[i-1][j] + 1,   // 删除  
          dp[i][j-1] + 1,   // 插入  
          dp[i-1][j-1] + 1  // 替换  
        );  
      }  
    }  
  }  
  return dp[m][n];  
}  

console.log(minEditDistance("kitten", "sitting")); // 3  
```

**关键点**  

- **状态定义**：明确`dp[i][j]`含义（如`i/j`表示子串长度）；  
- **转移方程**：根据业务逻辑推导递推关系；  
- **空间优化**：滚动数组压缩（如二维DP转一维）。  

动态规划的价值在于 **用空间换时间的高效复杂决策**，适合前端高复杂度且可拆解的交互场景。

## 说说你对贪心算法，回溯算法的理解？应用场景？


**贪心算法**  

**理解**：每一步选择当前最优解，期望得到全局最优。**特点**是高效但不保证全局最优，需验证贪心策略是否成立。  

**前端应用场景**：  
1. **资源分配**  
   - 按需加载优先级（如首屏关键资源优先加载）；  
   - 图片懒加载顺序（按视口距离动态计算加载顺序）。  
2. **调度优化**  
   - React Scheduler 中高优先级任务插队（如用户交互优先于渲染）；  
   - 请求并发控制（优先处理耗时短的任务）。  
3. **近似解场景**  
   - 离线缓存策略（如Service Worker按访问频率缓存资源）。  

**代码示例（找零问题-贪心）**：  
```javascript  
function greedyCoinChange(coins, amount) {  
  coins.sort((a, b) => b - a); // 降序排序  
  let count = 0;  
  for (const coin of coins) {  
    while (amount >= coin) {  
      amount -= coin;  
      count++;  
    }  
  }  
  return amount === 0 ? count : -1; // 仅适用特定币种（如人民币）  
}  
console.log(greedyCoinChange([1, 5, 10], 28)); // 10+10+5+1+1+1 → 6枚  
```

**回溯算法**  

**理解**：通过试错遍历所有可能解，走不通时回退（剪枝）。**特点**是暴力穷举，时间复杂度高但能找所有解。  

**前端应用场景**：  
1. **组合问题**  
   - 动态表单多条件联动校验（如某选项触发后续字段显隐组合校验）；  
   - 权限路由树生成（遍历角色权限组合生成可用路由）。  
2. **路径探索**  
   - 低代码平台节点连线合法性校验（如禁止循环依赖）；  
   - 游戏类页面解谜逻辑（如迷宫路径回溯渲染）。  
3. **决策场景**  
   - 可视化配置工具的条件分支生成（如嵌套`if-else`规则树）。  

**代码示例（全排列-回溯）**：  
```javascript  
function permute(nums) {  
  const res = [];  
  const backtrack = (path, used) => {  
    if (path.length === nums.length) {  
      res.push([...path]);  
      return;  
    }  
    for (let i = 0; i < nums.length; i++) {  
      if (used[i]) continue;  
      used[i] = true;  
      path.push(nums[i]);  
      backtrack(path, used);  
      path.pop();  
      used[i] = false;  
    }  
  };  
  backtrack([], []);  
  return res;  
}  
console.log(permute([1, 2, 3])); // [[1,2,3],[1,3,2],...]  
```

**对比与选型**  

| 特性             | 贪心算法               | 回溯算法               |
| ---------------- | ---------------------- | ---------------------- |
| **时间复杂度**   | 通常较低（O(n)~O(n²)） | 较高（O(n!)或指数级）  |
| **解的质量**     | 局部最优，未必全局最优 | 精确解（全解或最优解） |
| **适用场景**     | 高效近似解             | 小规模精确解           |
| **前端典型应用** | 性能优化调度           | 配置类工具逻辑         |

**注意事项**  

- **贪心算法**需验证策略正确性（如找零问题中币种是否满足贪心条件）；  
- **回溯算法**必须剪枝（如路径记录`used`数组避免重复计算），否则易性能爆炸。  

两者在前端中虽不常用，但在解决特定复杂交互逻辑时能提供清晰的算法模型。

## 冒泡排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/冒泡排序.webp)

```javascript
function bubbleSort(arr){
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if(arr[j]>arr[j+1]){
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return arr
}
```

## 选择排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/选择排序.webp)

```javascript
function selectSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[min]) {
        min = j
      }
    }
    [arr[i], arr[min]] = [arr[min], arr[i]]
  }
}
```

## 插入排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/插入排序.webp)

```javascript
function insertSort(arr) {
  // 从第 2 个元素开始遍历序列
  for (let i = 1; i < arr.length; i++) {
    let j = i;
    //记录要插入的目标元素
    let target = arr[j];
    //从 target 所在位置向前遍历，直至找到一个比目标元素小的元素，目标元素插入到该元素之后的位置
    while (j > 0 && arr[j - 1] > target) {
      //移动前一个元素的位置，将其向后移动一个位置
      arr[j] = arr[j - 1];
      j--;
    }
    arr[j] = target;
  }
  return arr;
}
```

## 快速排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/快速排序.webp)

```javascript
function quickSort(arr) {
  if(arr.length <= 1) return arr
  let pivot = arr[0]
  let left = []
  let right = []
  for (let i = 1; i < arr.length; i++) {
    if(arr[i] < pivot) {
      left.push(arr[i])
    }else {
      right.push(arr[i])
    }
  }
  return [...quickSort(left), pivot, ...quickSort(right)]
}
```



```javascript
function quickSort(array, start, end) {
  if (start >= end) {
    return;
  }
  let pivot = array[start];
  let left = start + 1;
  let right = end;
  while (left < right) {
    while (left < right && array[left] <= pivot) {
      left++;
    }
    while (left < right && array[right] >= pivot) {
      right--;
    }
    if (left < right) {
      let temp = array[left];
      array[left] = array[right];
      array[right] = temp;
    }
  }
  array[start] = array[right];
  array[right] = pivot;
  quickSort(array, start, right - 1);
  quickSort(array, right + 1, end);
  return array
}
```



## 归并排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/归并排序.webp)

```javascript
function MergeSort(array) {
  let len = array.length;

  // 当每个子序列中仅有1个元素时返回
  if (len <= 1) {
    return array;
  }
  // 将给定的列表分为两半
  let num = Math.floor(len / 2);
  let left = MergeSort(array.slice(0, num));
  let right = MergeSort(array.slice(num, array.length));
  return merge(left, right);

  function merge(left, right) {
    let [l, r] = [0, 0];
    let result = [];
    // 从 left 和 right 区域中各个取出第一个元素，比较它们的大小
    while (l < left.length && r < right.length) {
      // 将较小的元素添加到result中，然后从较小元素所在的区域内取出下一个元素，继续进行比较；
      if (left[l] < right[r]) {
        result.push(left[l]);
        l++;
      } else {
        result.push(right[r]);
        r++;
      }
    }
    // 如果 left 或者 right 有一方为空，则直接将另一方的所有元素依次添加到result中
    result = result.concat(left.slice(l, left.length));
    result = result.concat(right.slice(r, right.length));
    return result;
  }
}
```




## 反转链表

```javascript
function reverseLinkList(head) {
  let pre = null
  let cur = head
  while (cur) {
    let next = cur.next
    cur.next = pre
    pre = cur
    cur = next
  }
}

```

## 二叉树的遍历  


**二叉树遍历的核心类型**  

1. **前序遍历（根→左→右）**  
2. **中序遍历（左→根→右）**  
3. **后序遍历（左→右→根）**  
4. **层次遍历（BFS逐层访问）**  

**代码实现（JavaScript）**  

1. 前序遍历  

**递归实现**：  
```javascript  
function preorder(root) {  
  if (!root) return [];  
  return [root.val, ...preorder(root.left), ...preorder(root.right)];  
}  
```
**迭代实现（栈模拟递归）**：  

```javascript  
function preorderIterative(root) {  
  const stack = [root], res = [];  
  while (stack.length) {  
    const node = stack.pop();  
    if (!node) continue;  
    res.push(node.val);  
    stack.push(node.right); // 右先入栈，保证左先出栈  
    stack.push(node.left);  
  }  
  return res;  
}  
```

2. 中序遍历  

**递归实现**：  
```javascript  
function inorder(root) {  
  if (!root) return [];  
  return [...inorder(root.left), root.val, ...inorder(root.right)];  
}  
```
**迭代实现**：  
```javascript  
function inorderIterative(root) {  
  const stack = [], res = [];  
  let curr = root;  
  while (curr || stack.length) {  
    while (curr) {  
      stack.push(curr);  
      curr = curr.left; // 左子树全部入栈  
    }  
    curr = stack.pop();  
    res.push(curr.val);  
    curr = curr.right; // 转向右子树  
  }  
  return res;  
}  
```

3. 后序遍历  

**递归实现**：  
```javascript  
function postorder(root) {  
  if (!root) return [];  
  return [...postorder(root.left), ...postorder(root.right), root.val];  
}  
```
**迭代实现（逆序技巧）**：  
```javascript  
function postorderIterative(root) {  
  const stack = [root], res = [];  
  while (stack.length) {  
    const node = stack.pop();  
    if (!node) continue;  
    res.push(node.val);  
    stack.push(node.left); // 调整入栈顺序，结果逆序即为后序  
    stack.push(node.right);  
  }  
  return res.reverse();  
}  
```

4. 层次遍历（BFS队列实现）  

```javascript  
function levelOrder(root) {  
  const queue = [root], res = [];  
  while (queue.length) {  
    const levelSize = queue.length, level = [];  
    for (let i = 0; i < levelSize; i++) {  
      const node = queue.shift();  
      if (!node) continue;  
      level.push(node.val);  
      queue.push(node.left);  
      queue.push(node.right);  
    }  
    if (level.length) res.push(level);  
  }  
  return res;  
}  
```

**前端应用场景**  

1. **DOM树操作**  
   - **前序**：克隆DOM树结构（先复制当前节点再处理子节点）  
   - **后序**：批量移除子节点（先清空子节点再删除父节点）  

2. **组件树处理**  
   - **中序**：表单联动校验（如左侧树控件选中后更新中间表单）  
   - **层次遍历**：按优先级渲染组件（如弹窗层级管理）  

3. **状态管理**  
   - **后序**：Redux中间件执行顺序（先子中间件后父级）  
   - **前序**：依赖注入（先父组件提供数据再子组件消费）  

4. **性能优化**  
   - **中序**：AST语法树分析（Babel插件转换代码）  
   - **层次遍历**：虚拟列表可视区域计算（分块渲染）  

**注意事项**  

1. **递归风险**：深层次树可能导致栈溢出，建议用迭代法处理大数据量；  
2. **遍历顺序**：前/中/后序本质是 **处理当前节点的时机不同**；  
3. **框架应用**：React Fiber架构的遍历策略结合了DFS和优先级调度。  

遍历方法的选择需结合业务目标，例如需要 **快速定位叶子节点** 时优先考虑后序，**按层级渲染** 则必须用BFS。

## 二叉树搜索


**二叉搜索树（BST）核心特性**  

1. **有序性**：左子树节点值 < 根节点值 < 右子树节点值；  
2. **高效性**：查找/插入/删除平均时间复杂度 **O(logn)**（树平衡时）；  
3. **中序遍历**：可直接输出有序数据序列。  

**基本操作实现（JavaScript）**  

1. 查找  

```javascript  
function searchBST(root, target) {  
  if (!root) return null;  
  if (root.val === target) return root;  
  return target < root.val  
    ? searchBST(root.left, target)  
    : searchBST(root.right, target);  
}  
```

2. 插入  

```javascript  
function insertBST(root, val) {  
  if (!root) return new TreeNode(val);  
  if (val < root.val) {  
    root.left = insertBST(root.left, val);  
  } else if (val > root.val) {  
    root.right = insertBST(root.right, val);  
  }  
  return root; // 忽略重复值  
}  
```

3. 删除（最复杂）  

```javascript  
function deleteBST(root, key) {  
  if (!root) return null;  
  if (key < root.val) {  
    root.left = deleteBST(root.left, key);  
  } else if (key > root.val) {  
    root.right = deleteBST(root.right, key);  
  } else {  
    // 找到目标节点  
    if (!root.left) return root.right; // 无左子树  
    if (!root.right) return root.left;  // 无右子树  
    // 找右子树最小节点替代  
    let minNode = root.right;  
    while (minNode.left) minNode = minNode.left;  
    root.val = minNode.val;  
    root.right = deleteBST(root.right, minNode.val); // 删除替代节点  
  }  
  return root;  
}  
```

**前端应用场景**  

1. **数据快速检索**  
   - 大型表单中按用户ID快速查询（替代数组遍历的O(n)）；  
   - 前端缓存有序数据（如商品价格区间筛选）。  

2. **框架底层优化**  
   - React Fiber任务优先级调度（按过期时间组织任务树）；  
   - 富文本编辑器光标位置管理（按文本偏移量组织节点）。  

3. **可视化工具**  
   - 组织架构图按层级排序渲染；  
   - 时间轴工具按时间戳排序事件节点。  

**BST的局限性及解决方案**  

| 问题               | 后果               | 解决方案                   |
| ------------------ | ------------------ | -------------------------- |
| **不平衡树**       | 退化为链表（O(n)） | 自平衡树（AVL/红黑树）     |
| **内存开销**       | 节点存储指针       | 数组模拟树结构（堆式存储） |
| **范围查询效率低** | 需多次遍历         | 跳表或B+树                 |

**验证BST合法性（高频面试题）**  

```javascript  
function isValidBST(root, min = -Infinity, max = Infinity) {  
  if (!root) return true;  
  if (root.val <= min || root.val >= max) return false;  
  return isValidBST(root.left, min, root.val) &&  
         isValidBST(root.right, root.val, max);  
}  
// 示例：通过中序遍历验证是否严格递增  
function isValidBSTInOrder(root) {  
  let prev = -Infinity;  
  const inorder = (node) => {  
    if (!node) return true;  
    if (!inorder(node.left)) return false;  
    if (node.val <= prev) return false;  
    prev = node.val;  
    return inorder(node.right);  
  };  
  return inorder(root);  
}  
```

**总结**  

BST在前端中虽不常用，但在处理 **有序数据高频检索** 时能显著优化性能。实际开发中需注意：  
1. 优先使用语言内置结构（如`Map`/`Set`）；  
2. 数据量较大时考虑平衡树变种或跳表；  
3. 结合业务场景选择数据结构，避免过度设计。



## 二叉树diff算法


**二叉树 Diff 算法核心思路**  

二叉树 Diff 的目标是 **高效识别两棵树的结构与内容差异**，通常用于虚拟 DOM 优化或数据同步。其实现需解决两个关键问题：  
1. **节点比对**：判断节点是否相同（通常依赖唯一 key 或值）；  
2. **差异定位**：识别增删改移操作。  

**基础实现（递归比对）**  

```javascript  
function diffTrees(oldNode, newNode) {  
  const changes = [];  

  // 节点删除  
  if (!newNode && oldNode) {  
    changes.push({ type: 'REMOVE', node: oldNode });  
    return changes;  
  }  

  // 节点新增  
  if (!oldNode && newNode) {  
    changes.push({ type: 'ADD', node: newNode });  
    return changes;  
  }  

  // 节点值更新  
  if (oldNode.val !== newNode.val) {  
    changes.push({ type: 'UPDATE', oldNode, newNode });  
  }  

  // 递归比对子树  
  const leftDiff = diffTrees(oldNode?.left, newNode?.left);  
  const rightDiff = diffTrees(oldNode?.right, newNode?.right);  

  return [...changes, ...leftDiff, ...rightDiff];  
}  
```

**优化策略**  

1. **Key 标识**：  
   - 为节点添加唯一标识（如 `key`），避免仅依赖位置比对，支持跨层级移动检测。  

2. **哈希映射**：  
   - 预处理新树生成 `key-to-node` 哈希表，快速定位旧节点在新树中的位置。  

3. **动态规划（LCS）**：  
   - 通过最长公共子序列算法（如 Myers 算法）最小化操作步骤，减少节点移动成本。  

**优化示例（哈希映射加速查找）**：  
```javascript  
function optimizedDiff(oldRoot, newRoot) {  
  const oldMap = new Map();  
  traverse(oldRoot, node => oldMap.set(node.key, node));  
  return diffHelper(oldRoot, newRoot, oldMap);  
}  

function diffHelper(oldNode, newNode, oldMap) {  
  const changes = [];  
  if (!oldNode && newNode) {  
    changes.push({ type: 'ADD', node: newNode });  
  } else if (oldNode && !newNode) {  
    changes.push({ type: 'REMOVE', node: oldNode });  
  } else if (oldNode.key !== newNode.key) {  
    // Key 不同视为替换  
    changes.push({ type: 'REPLACE', oldNode, newNode });  
  } else {  
    if (oldNode.val !== newNode.val) {  
      changes.push({ type: 'UPDATE', oldNode, newNode });  
    }  
    // 递归处理子节点  
    const oldLeft = oldNode.left, newLeft = newNode.left;  
    const oldRight = oldNode.right, newRight = newNode.right;  
    const leftMatch = oldLeft?.key === newLeft?.key ? newLeft : oldMap.get(newLeft?.key);  
    const rightMatch = oldRight?.key === newRight?.key ? newRight : oldMap.get(newRight?.key);  
    changes.push(...diffHelper(oldLeft, leftMatch, oldMap));  
    changes.push(...diffHelper(oldRight, rightMatch, oldMap));  
  }  
  return changes;  
}  
```

**前端应用场景**  

1. **虚拟 DOM 更新**：  
   - React Reconciler 通过 Diff 算法比对 Fiber 树，生成 DOM 操作指令；  
   - Vue 3 的 Block Tree 优化静态节点比对。  

2. **数据同步**：  
   - 配置系统对比新旧 JSON 树生成增量更新；  
   - 协同编辑中合并多人操作（如 OT 算法）。  

3. **可视化工具**：  
   - 流程图版本差异对比；  
   - 低代码平台组件树状态回滚。  

**性能瓶颈与突破**  

| 问题                  | 解决方案                                                     |
| --------------------- | ------------------------------------------------------------ |
| **全量递归性能差**    | 按层级分片 Diff（如 React 的时间切片）                       |
| **跨层级移动难检测**  | 基于 Key 的哈希映射 + 双向编辑图（如 Google Diff-Match-Patch） |
| **多次 DOM 操作卡顿** | 批处理更新（如 React 的 commit 阶段合并操作）                |

**总结**  

二叉树 Diff 的核心是 **平衡准确性与性能**：  
- **简单场景**：递归比对即可满足需求；  
- **复杂场景**：需引入 Key 映射、哈希预计算或动态规划优化。  
在前端框架中，Diff 算法直接影响渲染性能，需结合业务场景选择策略（如牺牲少量准确性换取更高帧率）。

## 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

---

## K个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

---

```javascript
function reverseKGroup(head, k) {
  if(head === null||k===1) return head
  let a,b
  a = b = head
  for (let i = 0; i < k; i++) {
    if(b === null) return head
    b = b.next
  }
  let newHead = reverse(a,b)
  a.next = reverseKGroup(b,k)
  function reverse(a,b){
    let pre = null
    let cur = a
    while(cur!==b){
      let next = cur.next
      cur.next = pre
      pre = cur
      cur = next
    }
    return pre
  }
  return newHead
}
```



## 删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)

```
输入：head = [1,1,2]
输出：[1,2]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)

```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

---

## 搜索二维矩阵

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

---



## 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

---


```javascript
function isRingLinkList(head) {
  let fast = head
  let slow = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}
```

## 斐波那契数列

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

---


```javascript
//普通递归
function fib(num) {
  if (num < 2) {
    return num;
  }

  return fib(num - 1) + fib(num - 2);
}
//尾递归

function fib2(n,a = 0,b = 1) {
    if(n === 0) return a;
    if(n === 1 ) return b;
    return fib2(n - 1, b,a+ b)
}
//动态规划

function fib3(n) {
    if( n === 0 || n === 1) return n
    let a = 0,b = 1;
    let temp = 0;
    for(let i = 2; i <= n; i++) {
        temp = a + b;
        a = b;
        b = temp
    }
    return temp;
}

```



## 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

[LCR 127. 跳跃训练](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

---



```javascript
function jumpFloor(number)
{
    if(number === 1){
        return 1
    }
    if(number === 2){
        return 2
    }
    if(number > 2){
        return jumpFloor(number-1)+jumpFloor(number-2)
    }
}
```

## 电话号码组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

---



```javascript
function letterCombinations(digits) {
  if (!digits) return [];

  const phoneMap = {
    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
  };

  const result = [];

  function backtrack(combination, nextDigits) {
    if (nextDigits.length === 0) {
      result.push(combination);
    } else {
      const digit = nextDigits[0];
      const letters = phoneMap[digit];
      for (let i = 0; i < letters.length; i++) {
        backtrack(combination + letters[i], nextDigits.slice(1));
      }
    }
  }

  backtrack('', digits);
  return result;
}
```

## 全排列

给定一个不含重复数字的整数数组 `nums` ，返回其 **所有可能的全排列** 。可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

[46. 全排列](https://leetcode.cn/problems/permutations/)

---



## 字符串所有排列组合

[面试题 08.07. 无重复字符串的排列组合](https://leetcode.cn/problems/permutation-i-lcci/)

[面试题 08.08. 有重复字符串的排列组合](https://leetcode.cn/problems/permutation-ii-lcci/)

---


```javascript
function getPermutation(str) {
  const res = []
  const dfs = (path) => {
    if (path.length === str.length) {
      res.push(path)
      return
    }
    for (let i = 0; i < str.length; i++) {
      if (path.includes(str[i])) continue
      dfs(path + str[i])
    }
  }
  dfs('')
  return res
}
```

## 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb
```

[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

---

```javascript
function longestPalindrome(s) {
  if (s.length === 1) return s;
  let maxRes = 0, maxStr = '';
  for (let i = 0; i < s.length; i++) {
    let str1 = palindrome(s, i, i);
    if (str1.length > maxRes) {
      maxStr = str1;
      maxRes = str1.length;
    }
  }
  function palindrome(s, l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      l--;
      r++;
    }
    return s.slice(l + 1, r);
  }
  return maxStr;
}
```

## 验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。 

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**示例 2：**

```
输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。
```

**示例 3：**

```
输入：s = " "
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。
由于空字符串正着反着读都一样，所以是回文串。
```

[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

---


## 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

**输入：**s = "()"

**输出：**true

**示例 2：**

**输入：**s = "()[]{}"

**输出：**true

**示例 3：**

**输入：**s = "(]"

**输出：**false

**示例 4：**

**输入：**s = "([])"

**输出：**true

[有效的括号](https://leetcode.cn/problems/valid-parentheses/)

---

```java
function isValidBrackets(str) {
  const map = new Map([['(', ')'], ['[', ']'], ['{', '}'],])
  const stack = []

  for (let i = 0; i < str.length; i++) {
    if (map.has(str[i])) {
      stack.push(str[i])
    } else if (map.get(stack[stack.length - 1]) === str[i]) {
      stack.pop()
    } else {
      return false
    }
  }
  return stack.length === 0
}
```

## 最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

---

```javascript
function LIS(nums) {
  if(nums.length === 0) return []
  const results = [[nums[0]]];
  for (let i = 0; i < nums.length; i++) {
    const current = nums[i];
    _update(current)
  }

  function _update(n) {
    for (let i = results.length - 1; i >= 0; i--) {
      const line = results[i];
      const tail = line[line.length - 1];

      if (tail < n) {
        results[i + 1] = [...line, n];
        break
      }else if (n < tail && i === 0) {
        results[0] = [n]
      }
    }
  }
  return results[results.length - 1]
}
```

## 滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

---

- 双端队列

```javascript
function maxSlidingWindow(nums, k) {
  let window = [...nums.slice(0,k)]
  let res = []
  for (let i = k; i < nums.length; i++) {
    res.push(Math.max(...window))
    window.shift()
    window.push(nums[i])
  }
  return res
}
```

- 单调队列

```javascript
var maxSlidingWindow2 = function (nums, k) {
  // 边界条件
  if (k > nums.length || k <= 0) return []
  let deque = [], res = []
  for (let i = 0; i < nums.length; i++) {
    // 如果nums[i]比栈尾的数大，则弹出
    while (deque.length && deque[deque.length - 1] < nums[i]) {
      deque.pop()
    }
    // nums[i]入栈
    deque.push(nums[i])
    // 删除离开窗口的元素
    if (deque[0] === nums[i - k]) deque.shift()
    // 推入最大值
    if (i >= k - 1) res.push(deque[0])
  }
  return res
};
```

## 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

---

```javascript
function towSum(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j]
      }
    }
  }
}
function towSum2(nums, target) {
    const map = new Map();
    for(let i = 0, len = nums.length; i < len; i++){
        if(map.get(nums[i]) !== undefined){
            return [map.get(nums[i]), i];
        } else {
            map.set(target - nums[i], i);
        }
    }
    return [];
};

```

## 三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

[15. 三数之和](https://leetcode.cn/problems/3sum/)

---

```javascript
function findThree(arr, target) {
  // 先将数组从小到大排序
  arr.sort((a, b) => a - b)
  let result = [];
  for (let i = 0; i < arr.length - 2; i++) {
    // 跳过重复的arr[i]值, 比如[2, 1, 1],跳过第二个1
    if (i && arr[i] === arr[i - 1]) continue;
    let left = i + 1;
    let right = arr.length - 1;

    // 双端指针left、right
    while (left < right) {
      let sum = arr[i] + arr[left] + arr[right];
      if (sum > target) {
        right--;
      } else if (sum < target) {
        left++;
      } else {
        // 先取arr[left]，然后left++, 两步合成一步；arr[right--]同样的逻辑
        result.push([arr[i], arr[left++], arr[right--]]);
        while (arr[left] === arr[left - 1]) {
          // 跳过重复的arr[left]值,
          left++;
        }
        while (arr[right] === arr[right + 1]) {
          // 跳过重复的arr[right]值
          right--;
        }
      }
    }
  }
  return result;
}

```



## 买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

---

```javascript
function bestTimeBuyStock(prices) {
  let minPrice = Infinity
  let maxProfit = 0
  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < minPrice) {
      minPrice = prices[i]
    } else if (prices[i] - minPrice > maxProfit) {
      maxProfit = prices[i] - minPrice
    }
  }
  return maxProfit
}
```

其他版本买股票问题：[买卖股票的最佳时机](https://zhuanlan.zhihu.com/p/136811810)

## 计算多个数组的交集

给你一个二维整数数组 `nums` ，其中 `nums[i]` 是由 **不同** 正整数组成的一个非空数组，按 **升序排列** 返回一个数组，数组中的每个元素在 `nums` **所有数组** 中都出现过。

**示例 1：**

```
输入：nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
输出：[3,4]
解释：
nums[0] = [3,1,2,4,5]，nums[1] = [1,2,3,4]，nums[2] = [3,4,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。
```

**示例 2：**

```
输入：nums = [[1,2,3],[4,5,6]]
输出：[]
解释：
不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。
```

[2248. 多个数组求交集](https://leetcode.cn/problems/intersection-of-multiple-arrays/)

---

```javascript
const getIntersection = (...arrs) => {
  return arrs.reduce((pre, cur) => {
    return cur.filter(item => pre.includes(item));
  })
}
```



## 背包问题

给定容量为 `C` 的背包和 `N` 个物品，每个物品有重量 `w[i]` 和价值 `v[i]`，每个物品只能选或不选。目标是总重量不超容量的前提下，最大化总价值。

[LintCode 链接](https://www.lintcode.com/problem/125/description)

[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

---


**01背包问题解析**  

**问题描述**：给定容量为 `C` 的背包和 `N` 个物品，每个物品有重量 `w[i]` 和价值 `v[i]`，每个物品只能选或不选。目标是总重量不超容量的前提下，最大化总价值。

**动态规划解法（最优解）**  

**核心思想**：通过状态转移记录子问题最优解，逐步递推全局最优。  **实现步骤**  

1. **状态定义**  
   - `dp[i][j]`：前 `i` 个物品在容量 `j` 下的最大价值。  
   - **空间优化**：使用一维数组 `dp[j]`，逆序遍历容量避免覆盖。  

2. **状态转移方程**  
   ```  
   dp[j] = max(dp[j], dp[j - w[i]] + v[i])  （需 j >= w[i]）  
   ```

3. **代码实现**  
```javascript  
function knapsack01(C, weights, values) {  
  const dp = new Array(C + 1).fill(0);  
  for (let i = 0; i < weights.length; i++) {  
    for (let j = C; j >= weights[i]; j--) {  
      dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);  
    }  
  }  
  return dp[C];  
}  

// 示例  
const C = 4;  
const weights = [1, 3, 4];  
const values = [15, 20, 30];  
console.log(knapsack01(C, weights, values)); // 35（选物品0和2，重量1+4=5超出？需修正示例）
```
*注：示例中实际应为容量4，选物品3（重量3，价值20）和物品0（重量1，总价值35）？需要核对数据。*  

**特点**：  
- **时间复杂度**：`O(N*C)`，适合中等规模数据；  
- **空间复杂度**：`O(C)`，通过逆序压缩空间；  
- **保证全局最优**，但无法处理极大容量（如 `C > 1e5`）。  

**贪心算法（近似解，不保证最优）**  

**核心思想**：每一步选择当前最优策略（如价值密度最高），但无法保证全局最优。  **实现步骤**  

1. **排序物品**：按价值密度（`价值/重量`）降序排列；  
2. **贪心选择**：依次尝试装入当前最优物品，直到容量不足。  

**代码实现**：  
```javascript  
function greedyKnapsack(C, weights, values) {  
  const items = weights.map((w, i) => ({ w, v: values[i], ratio: values[i]/w }));  
  items.sort((a, b) => b.ratio - a.ratio);  

  let totalValue = 0, remaining = C;  
  for (const item of items) {  
    if (item.w <= remaining) {  
      totalValue += item.v;  
      remaining -= item.w;  
    }  
    if (remaining === 0) break;  
  }  
  return totalValue;  
}  

// 示例  
console.log(greedyKnapsack(4, [1,3,4], [15,20,30])); // 45（选物品0和2，总重量5？需修正示例）  
```
*注：示例数据需调整，例如 `C=5`，选物品0（重量1，价值15）和物品2（重量4，价值30），总价值45。*  

**局限性**：  
- **反例**：  
  - 容量为3，物品1（重量2，价值3）、物品2（重量3，价值4）。  
  - 贪心按密度选物品1（密度1.5），总价值3；实际最优解选物品2，价值4。  
- **适用场景**：仅当物品按价值密度排序且组合无冲突时可能最优（极少情况）。  

**对比与选型**  

| 特性           | 动态规划                 | 贪心算法                     |
| -------------- | ------------------------ | ---------------------------- |
| **解的质量**   | 全局最优                 | 局部最优，可能远离全局最优   |
| **时间复杂度** | O(N*C)                   | O(N log N)（排序主导）       |
| **适用场景**   | 精确解，中等数据规模     | 快速近似解，极大规模容量     |
| **前端应用**   | 资源分配优化（精确需求） | 实时计算的近似策略（如游戏） |

**总结**  

- **动态规划**是01背包问题的标准解法，保证最优但受容量限制；  
- **贪心算法**仅适用于分数背包问题（物品可分割），在01背包中无法保证最优，但可作为大规模数据的近似方案；  
- 实际开发中需根据场景权衡：若要求精确解且数据规模可控，用动态规划；若接受近似解且追求高效，可尝试贪心或其他启发式算法。

## N皇后问题

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

[51. N 皇后](https://leetcode.cn/problems/n-queens/)

---

**解法核心：回溯算法**  

**步骤拆解**：  

1. **逐行放置**：每行仅放一个皇后，递归处理下一行。  
2. **冲突检测**：检查当前列、主对角线（行-列）、副对角线（行+列）是否已被占用。  
3. **剪枝优化**：通过集合记录已占用的列和对角线，避免全量遍历检查。  

**JavaScript代码实现**  

```javascript  
function solveNQueens(n) {  
  const result = [];  
  // 初始化列、主对角线、副对角线占用集合  
  const cols = new Set();  
  const diag1 = new Set();  // 主对角线：row - col  
  const diag2 = new Set();  // 副对角线：row + col  

  // 回溯函数  
  const backtrack = (row, path) => {  
    if (row === n) {  
      // 生成棋盘格式（如 [".Q..","...Q"]）  
      const board = path.map(col => '.'.repeat(col) + 'Q' + '.'.repeat(n - col - 1));  
      result.push(board);  
      return;  
    }  
    for (let col = 0; col < n; col++) {  
      const d1 = row - col;  
      const d2 = row + col;  
      // 冲突检测  
      if (cols.has(col) || diag1.has(d1) || diag2.has(d2)) continue;  
      // 选择当前列  
      cols.add(col);  
      diag1.add(d1);  
      diag2.add(d2);  
      path.push(col);  
      // 递归下一行  
      backtrack(row + 1, path);  
      // 撤销选择  
      path.pop();  
      cols.delete(col);  
      diag1.delete(d1);  
      diag2.delete(d2);  
    }  
  };  

  backtrack(0, []);  
  return result;  
}  

// 示例：n=4 → 输出2种解法  
console.log(solveNQueens(4));  
```

**关键优化点**  

1. **冲突检测**：  
   - 列冲突 → `cols` 集合；  
   - 主对角线 → `row - col` 的差值唯一；  
   - 副对角线 → `row + col` 的和唯一。  
2. **时间复杂度**：最坏情况 `O(N!)`，但剪枝大幅减少实际计算量。  
3. **空间复杂度**：`O(N)`（递归栈深度 + 集合存储）。  

**前端应用场景**  

1. **可视化工具**：  
   - 棋盘交互式演示（如拖拽皇后动态校验合法性）；  
   - 算法教学动画生成（回溯过程可视化）。  
2. **游戏开发**：  
   - 解谜类游戏关卡设计（自动生成N皇后布局）；  
   - 棋类AI冲突检测逻辑。  
3. **性能测试**：  
   - 递归与剪枝策略的浏览器执行效率对比。  

**变种问题**  

1. **统计解法数量**：无需记录路径，仅计数。  
2. **随机合法解**：在回溯过程中随机选择有效列，快速找到一个解。  
3. **超大N优化**：位运算压缩状态（如用二进制表示列和对角线占用）。  

**注意事项**  

- **数据不可变性**：递归时传递深拷贝或回溯时及时撤销状态；  
- **N较大时的性能**：浏览器中N>15可能导致栈溢出或超时，需分帧计算或Web Worker处理；  
- **输出格式适配**：按题目要求返回数组格式（如LeetCode标准）。  

N皇后问题是回溯算法的经典案例，理解其冲突检测与状态管理机制对解决其他组合问题（如数独、排列组合）具有重要参考价值。

## 找出数组中第K大的数

给你一个字符串数组 `nums` 和一个整数 `k` 。`nums` 中的每个字符串都表示一个不含前导零的整数。

返回 `nums` 中表示第 `k` 大整数的字符串。

**注意：**重复的数字在统计时会视为不同元素考虑。例如，如果 `nums` 是 `["1","2","2"]`，那么 `"2"` 是最大的整数，`"2"` 是第二大的整数，`"1"` 是第三大的整数。

 

**示例 1：**

```
输入：nums = ["3","6","7","10"], k = 4
输出："3"
解释：
nums 中的数字按非递减顺序排列为 ["3","6","7","10"]
其中第 4 大整数是 "3"
```

**示例 2：**

```
输入：nums = ["2","21","12","1"], k = 3
输出："2"
解释：
nums 中的数字按非递减顺序排列为 ["1","2","12","21"]
其中第 3 大整数是 "2"
```

**示例 3：**

```
输入：nums = ["0","0"], k = 2
输出："0"
解释：
nums 中的数字按非递减顺序排列为 ["0","0"]
其中第 2 大整数是 "0"
```

[1985. 找出数组中的第 K 大整数](https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/)

---

## 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长连续子字符串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

[LCR 016. 无重复字符的最长子串](https://leetcode.cn/problems/wtcaE1/)

---

## 寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)





## 洗牌算法

洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，即为乱序算法。

---

## 图的最小生成树


**最小生成树（Minimum Spanting Tree, MST）的核心概念**  

最小生成树是 **连通加权无向图中权值和最小的生成树**，需满足：  
1. 包含所有顶点；  
2. 无环且边数 = 顶点数 - 1；  
3. 总权重最小。  

**算法实现（JavaScript）**  

1. **Prim算法（贪心思想，适合稠密图）**  

**步骤**：  
1. 从任一顶点开始，初始化最小堆（按边权排序）；  
2. 每次取堆顶最小边，将新顶点加入生成树，并更新相邻边入堆；  
3. 重复直到所有顶点连通。  

**代码示例**：  
```javascript  
function primMST(graph) {  
  const n = graph.length;  
  const visited = new Array(n).fill(false);  
  const minHeap = new PriorityQueue((a, b) => a.weight - b.weight);  
  const result = [];  

  // 从顶点0开始  
  visited[0] = true;  
  graph[0].forEach((weight, neighbor) => {  
    if (weight > 0) minHeap.push({ from: 0, to: neighbor, weight });  
  });  

  while (result.length < n - 1) {  
    const { from, to, weight } = minHeap.pop();  
    if (visited[to]) continue;  

    result.push({ from, to, weight });  
    visited[to] = true;  

    graph[to].forEach((nextWeight, nextNeighbor) => {  
      if (nextWeight > 0 && !visited[nextNeighbor]) {  
        minHeap.push({ from: to, to: nextNeighbor, weight: nextWeight });  
      }  
    });  
  }  
  return result;  
}  
```

2. **Kruskal算法（并查集，适合稀疏图）**  

**步骤**：  

1. 将所有边按权重升序排序；  
2. 按序选择边，若两端点不在同一集合（不形成环），则合并集合；  
3. 重复直到选够n-1条边。  

**代码示例**：  

```javascript  
class UnionFind {  
  constructor(size) {  
    this.parent = Array.from({ length: size }, (_, i) => i);  
  }  
  find(x) {  
    if (this.parent[x] !== x) {  
      this.parent[x] = this.find(this.parent[x]);  
    }  
    return this.parent[x];  
  }  
  union(x, y) {  
    const rootX = this.find(x);  
    const rootY = this.find(y);  
    if (rootX !== rootY) this.parent[rootY] = rootX;  
  }  
}  

function kruskalMST(edges, n) {  
  edges.sort((a, b) => a.weight - b.weight);  
  const uf = new UnionFind(n);  
  const result = [];  

  for (const edge of edges) {  
    const { from, to, weight } = edge;  
    if (uf.find(from) !== uf.find(to)) {  
      result.push(edge);  
      uf.union(from, to);  
      if (result.length === n - 1) break;  
    }  
  }  
  return result;  
}  
```

**前端应用场景**  

1. **网络拓扑优化**：  
   - 可视化工具中计算服务器节点间的最优布线方案；  
   - 低代码平台组件依赖的最小连接路径生成。  
2. **游戏开发**：  
   - 地图生成（如村庄间道路的最低成本规划）；  
   - 资源运输路径的动态计算（避免绕路）。  
3. **数据分析**：  
   - 用户关系图谱中的关键连接挖掘；  
   - 前端监控系统依赖项的最小覆盖分析。  

**对比与选型**  

| 特性           | Prim算法                 | Kruskal算法            |
| -------------- | ------------------------ | ---------------------- |
| **时间复杂度** | O(E + V log V)（二叉堆） | O(E log E)（排序主导） |
| **适用图类型** | 稠密图（邻接矩阵）       | 稀疏图（边列表）       |
| **空间复杂度** | O(V + E)                 | O(E)                   |
| **实现复杂度** | 需优先队列支持           | 需并查集结构           |

**注意事项**  

1. **边权重处理**：需保证权重为非负数（负权需特殊处理）；  
2. **图的连通性**：非连通图无法生成完整MST；  
3. **性能优化**：  
   - 大规模数据下，Kruskal算法可用路径压缩优化并查集；  
   - Prim算法使用斐波那契堆可优化至O(E + V log V)。  

**总结**  

最小生成树是图论中的经典问题，在前端涉及复杂网络可视化或路径优化时具有实际价值。根据数据特点选择算法：  
- **密集连接** → Prim算法；  
- **分散连接** → Kruskal算法。  
实际开发中可结合框架能力（如Web Worker）处理大规模计算，避免阻塞主线程。

## 数据流中的中位数

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

**示例 1：**

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

[295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

---

## 字符串相加

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。

**示例 1：**

```
输入：num1 = "11", num2 = "123"
输出："134"
```

**示例 2：**

```
输入：num1 = "456", num2 = "77"
输出："533"
```

**示例 3：**

```
输入：num1 = "0", num2 = "0"
输出："0"
```

[415. 字符串相加](https://leetcode.cn/problems/add-strings/)

---

## 合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

 [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

---



## 编辑距离

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

[72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

---

## 路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

[路径总和](https://leetcode.cn/problems/path-sum/)

---

## 只出现一次的数字

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1 ：**

**输入：**nums = [2,2,1]

**输出：**1

**示例 2 ：**

**输入：**nums = [4,1,2,1,2]

**输出：**4

**示例 3 ：**

**输入：**nums = [1]

**输出：**1

[只出现一次的数字](https://leetcode.cn/problems/single-number/)

---

## 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

[二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

---



## x 的平方根 

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

[x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

---



