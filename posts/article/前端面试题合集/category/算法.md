---
category: 算法
order: 19
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 算法

## 说说你对算法的理解，应用场景？

我对算法的理解是**用高效、明确的步骤解决特定问题**。在前端开发中，算法常用于以下场景：

1. **性能优化**：如虚拟滚动通过计算可视区域动态渲染，减少DOM操作；
2. **数据处理**：如复杂表单联动时，用拓扑排序解决依赖关系校验；
3. **交互逻辑**：如拖拽排序结合稳定排序算法，保证用户体验一致性；
4. **框架底层**：如虚拟DOM Diff策略减少渲染开销。
   我习惯在需求中识别算法切入点，例如曾用LRU缓存策略优化H5页面资源加载速度，并持续通过LeetCode保持逻辑敏感度。

## 说说你对数据结构的理解？有哪些？区别？

**数据结构是数据组织和操作的逻辑模型**，核心在于**平衡存储效率与操作性能**。常见类型及区别：  

1. **线性结构**  
   - **数组**：连续内存，通过索引快速访问，但插入/删除成本高（需移动元素）；  
   - **链表**：节点离散存储，通过指针连接，增删高效但查询需遍历；  
   - **栈（LIFO）**：函数调用栈、撤销操作；  
   - **队列（FIFO）**：异步任务队列、浏览器事件循环。  

2. **非线性结构**  
   - **树**：层级关系，如DOM树、组件树，B+树用于数据库索引；  
   - **图**：多对多关联，如社交网络关系、依赖分析（Webpack模块图）；  
   - **哈希表**：键值映射（JS的`Map`），通过哈希函数快速存取，冲突用拉链法/开放寻址解决。  

**前端典型场景**：  
- 虚拟DOM用树结构比对差异；  
- 路由历史管理用栈结构；  
- 防抖/节流任务调度用队列；  
- LocalStorage缓存淘汰策略（如LRU）依赖哈希表+双向链表。

## 什么是时间复杂度，空间复杂度？

**时间复杂度**衡量算法执行时间随数据规模增长的趋势，**空间复杂度**衡量算法内存消耗的增速，二者都用大O表示法描述。

**前端典型场景**：

- **时间复杂度**：
  - 遍历数组操作 → O(n)
  - 双重循环比对节点 → O(n²)（需警惕性能瓶颈）
  - 虚拟DOM Diff优化 → 通过Key策略降为O(n)
- **空间复杂度**：
  - 递归调用层级 → O(n)（可能栈溢出）
  - 深拷贝对象 → O(n)（内存翻倍需谨慎）
  - 状态管理库内存占用 → 关注数据缓存策略

理解复杂度能帮助在编码时权衡性能，例如用哈希表（O(1)查询）替代数组遍历（O(n)）来优化高频操作。

## 什么是链表？如何实现一个简单的单链表？

**链表**是由节点组成的线性数据结构，每个节点包含**数据域**和**指针域**（指向下个节点），内存非连续存储。与数组相比，链表插入/删除高效（O(1)~O(n)），但随机访问低效（O(n)）。

**JavaScript实现单链表**：

```javascript
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
  }

  // 尾部添加节点
  append(value) {
    const newNode = new Node(value);
    if (!this.head) {
      this.head = newNode;
      return;
    }
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = newNode;
  }

  // 删除匹配的第一个节点
  delete(value) {
    if (!this.head) return;
    if (this.head.value === value) {
      this.head = this.head.next;
      return;
    }
    let current = this.head;
    while (current.next) {
      if (current.next.value === value) {
        current.next = current.next.next;
        return;
      }
      current = current.next;
    }
  }
}

// 示例
const list = new LinkedList();
list.append(1);
list.append(2);
list.delete(1); // 删除头节点
```

**关键点**：

1. **插入**：遍历到尾节点修改指针（O(n)）；
2. **删除**：需定位前驱节点（如删除头节点特殊处理）；
3. **应用场景**：React Fiber架构中任务调度队列、浏览器历史记录管理等。

## 说说你对树的理解？应用场景？

**树是层级化的非线性数据结构**，核心特征是节点间存在父子关系且无循环。前端典型场景：

1. **DOM树**：浏览器解析HTML生成的节点树，前端框架（如React/Vue）通过虚拟DOM Diff算法比对树结构差异，高效更新视图。
2. **组件树**：React Fiber架构将组件关系抽象为树，实现任务优先级调度和异步渲染。
3. **路由配置**：嵌套路由用树形结构管理（如Vue Router的children），动态生成导航菜单。
4. **数据结构优化**：
   - 二叉搜索树：快速查找（时间复杂度O(logn)）
   - Trie树：自动补全/关键词过滤（前缀匹配）
   - 决策树：可视化配置工具的条件分支逻辑

**实现示例（二叉树遍历）**：

```javascript
class TreeNode {  
  constructor(value) {  
    this.value = value;  
    this.left = null;  
    this.right = null;  
  }  
}  

// 前序遍历（根-左-右）  
function preorder(root) {  
  if (!root) return [];  
  return [root.value, ...preorder(root.left), ...preorder(root.right)];  
}  

// 应用场景：克隆组件树结构  
const cloneTree = (node) => {  
  if (!node) return null;  
  const newNode = new TreeNode(node.value);  
  newNode.left = cloneTree(node.left);  
  newNode.right = cloneTree(node.right);  
  return newNode;  
};  
```

树的优势在于**天然映射层级关系**，适合处理嵌套数据和递归逻辑，但需警惕深层次遍历的性能问题（如栈溢出）。

## 说说你对堆，栈，队列的理解？应用场景？

**堆、栈、队列是三种基础数据结构**，核心区别在于**操作规则与使用场景**：  

**1. 栈（Stack）**  

- **特性**：后进先出（LIFO），仅允许在栈顶操作（push/pop）。  
- **前端应用**：  
  - **函数调用栈**：执行上下文压栈/弹栈（递归调用时的堆栈溢出问题）；  
  - **撤销操作**：编辑器或表单的Undo/Redo（如用两个栈实现历史记录）；  
  - **路由管理**：浏览器History API的`pushState`和`popState`；  
  - **算法场景**：括号匹配、DFS非递归实现。  

**代码示例**：  
```javascript  
// 用数组模拟栈实现撤销功能  
class UndoStack {  
  constructor() {  
    this.stack = [];  
    this.index = -1;  
  }  
  push(action) {  
    this.stack[++this.index] = action;  
    this.stack.length = this.index + 1; // 截断后续记录  
  }  
  undo() {  
    if (this.index < 0) return null;  
    return this.stack[this.index--];  
  }  
  redo() {  
    if (this.index >= this.stack.length - 1) return null;  
    return this.stack[++this.index];  
  }  
}  
```

**2. 队列（Queue）**  

- **特性**：先进先出（FIFO），队尾入队（enqueue）、队头出队（dequeue）。  
- **前端应用**：  
  - **事件循环**：宏任务队列（如setTimeout）、微任务队列（Promise）；  
  - **异步请求控制**：并发请求队列（如限制同时最多5个请求）；  
  - **动画调度**：保证动画执行顺序（如GSAP的TweenMax队列）；  
  - **算法场景**：BFS层级遍历、缓存淘汰策略（如最近最少使用队列）。  

**代码示例**：  
```javascript  
// 请求并发控制队列  
class RequestQueue {  
  constructor(concurrency) {  
    this.queue = [];  
    this.concurrency = concurrency;  
    this.running = 0;  
  }  
  add(requestFn) {  
    return new Promise((resolve, reject) => {  
      this.queue.push({ requestFn, resolve, reject });  
      this.next();  
    });  
  }  
  next() {  
    while (this.running < this.concurrency && this.queue.length) {  
      const { requestFn, resolve, reject } = this.queue.shift();  
      this.running++;  
      requestFn().then(resolve).catch(reject).finally(() => {  
        this.running--;  
        this.next();  
      });  
    }  
  }  
}  
```

**3. 堆（Heap）**  

- **特性**：完全二叉树结构，根节点为极值（最大堆/最小堆）。  
- **前端应用**：  
  - **优先级队列**：React Scheduler中的任务调度（高优先级任务优先执行）；  
  - **Top K问题**：日志系统中统计高频报错类型；  
  - **性能监控**：统计页面加载时间的P90/P99分位值（无需全排序）；  
  - **算法场景**：堆排序、合并K个有序链表。  

**逻辑示例（React Scheduler中的堆应用）**：  
```javascript  
// 简化版最小堆实现任务优先级调度  
class MinHeap {  
  constructor() {  
    this.heap = [];  
  }  
  push(task) {  
    this.heap.push(task);  
    this.bubbleUp(this.heap.length - 1);  
  }  
  pop() {  
    const min = this.heap[0];  
    const end = this.heap.pop();  
    if (this.heap.length > 0) {  
      this.heap[0] = end;  
      this.sinkDown(0);  
    }  
    return min;  
  }  
  // 上浮与下沉操作（具体实现略）  
}  

// 任务调度器使用堆管理任务  
const scheduler = new MinHeap();  
scheduler.push({ priority: 1, task: renderComponentA });  
scheduler.push({ priority: 0, task: urgentUpdateB }); // 更高优先级  
const nextTask = scheduler.pop(); // 优先执行priority 0的任务  
```

**总结**  

- **栈**：LIFO，适合对称性操作（如函数调用）；  
- **队列**：FIFO，保证顺序公平性（如异步任务）；  
- **堆**：动态极值获取，优化高频查询场景（如优先级调度）。

## 什么是图？

**图（Graph）** 是由 **节点（顶点）** 和 **边** 组成的非线性数据结构，用于描述多对多关系。其核心特点是能表达复杂关联性，主要分两类：  
- **有向图**：边有方向（如A→B），如任务依赖关系、微博关注网络；  
- **无向图**：边无方向（如A-B），如社交好友关系、地铁线路图。  

**前端典型应用场景**  

1. **依赖分析**  
   - Webpack 模块依赖图：解析文件间的`import/require`关系，构建有向图进行打包顺序优化；  
   - 循环依赖检测：通过遍历图判断是否存在环（如使用DFS+路径记录）。  

2. **可视化工具**  
   - 低代码平台的节点连线（如流程图设计器）；  
   - 组织架构图、知识图谱渲染。  

3. **状态管理**  
   - 复杂表单的字段关联关系（如某个选项触发多个字段显隐）；  
   - 前端路由权限的节点访问控制（如角色与页面的关联图）。  

**代码示例（邻接表实现图）**  

```javascript  
class Graph {  
  constructor() {  
    this.nodes = new Map(); // 节点表：key为节点ID，value为相邻节点集合  
  }  

  // 添加节点  
  addNode(node) {  
    if (!this.nodes.has(node)) {  
      this.nodes.set(node, new Set());  
    }  
  }  

  // 添加有向边（A→B）  
  addDirectedEdge(from, to) {  
    if (this.nodes.has(from) && this.nodes.has(to)) {  
      this.nodes.get(from).add(to);  
    }  
  }  

  // 检测循环依赖（DFS）  
  hasCycle() {  
    const visited = new Map();  
    const recursionStack = new Map();  

    const dfs = (node) => {  
      if (recursionStack.get(node)) return true;  
      if (visited.get(node)) return false;  

      visited.set(node, true);  
      recursionStack.set(node, true);  

      const neighbors = this.nodes.get(node);  
      for (const neighbor of neighbors) {  
        if (dfs(neighbor)) return true;  
      }  

      recursionStack.set(node, false);  
      return false;  
    };  

    for (const [node] of this.nodes) {  
      if (dfs(node)) return true;  
    }  
    return false;  
  }  
}  

// 示例：检测模块依赖是否有环  
const graph = new Graph();  
graph.addNode('A');  
graph.addNode('B');  
graph.addNode('C');  
graph.addDirectedEdge('A', 'B');  
graph.addDirectedEdge('B', 'C');  
graph.addDirectedEdge('C', 'A'); // 形成A→B→C→A的环  
console.log(graph.hasCycle()); // true  
```

**图的算法与前端结合**  

- **最短路径**：可视化地图路径规划（如Dijkstra算法）；  
- **拓扑排序**：构建任务执行顺序（如Vite的插件执行顺序）；  
- **连通性检测**：判断组件树的子模块是否可独立卸载。  

图的优势在于 **灵活表达复杂关系**，但需注意大规模数据下的性能问题（如遍历优化、内存占用）。

## 什么是哈希表？如何使用对象实现一个简单的哈希表？

**哈希表（Hash Table）** 是通过哈希函数将键映射到存储位置的数据结构，实现高效查找（理想时间复杂度O(1)）。核心是解决**哈希冲突**，常见方法有链地址法和开放寻址法。  

**JavaScript实现简单哈希表（链地址法）**  

```javascript  
class HashTable {  
  constructor(size = 32) {  
    this.buckets = new Array(size).fill(null).map(() => []); // 每个桶用数组存键值对  
    this.size = size;  
  }  

  // 哈希函数（简单示例：ASCII码累加取模）  
  _hash(key) {  
    let hash = 0;  
    const strKey = String(key);  
    for (let i = 0; i < strKey.length; i++) {  
      hash += strKey.charCodeAt(i);  
    }  
    return hash % this.size;  
  }  

  // 插入/更新键值对  
  set(key, value) {  
    const index = this._hash(key);  
    const bucket = this.buckets[index];  
    const existing = bucket.find((pair) => pair[0] === key);  
    if (existing) {  
      existing[1] = value; // 更新已有键  
    } else {  
      bucket.push([key, value]); // 新增键值对  
    }  
  }  

  // 获取值  
  get(key) {  
    const index = this._hash(key);  
    const bucket = this.buckets[index];  
    const pair = bucket.find((pair) => pair[0] === key);  
    return pair ? pair[1] : undefined;  
  }  

  // 删除键  
  delete(key) {  
    const index = this._hash(key);  
    const bucket = this.buckets[index];  
    const pairIndex = bucket.findIndex((pair) => pair[0] === key);  
    if (pairIndex >= 0) {  
      bucket.splice(pairIndex, 1);  
      return true;  
    }  
    return false;  
  }  
}  

// 使用示例  
const table = new HashTable();  
table.set('name', 'Alice');  
table.set('age', 30);  
console.log(table.get('name')); // Alice  
table.delete('age');  
console.log(table.get('age')); // undefined  
```

**关键点解析**  

1. **哈希函数设计**：  
   - 目标：均匀分布键以减少冲突；  
   - 示例中用ASCII码累加取模，实际生产环境需更复杂算法（如djb2）。  

2. **冲突处理**：  
   - **链地址法**：同一索引的键值对存入数组/链表，查找时遍历；  
   - **开放寻址法**：冲突时探测下一个空位（如线性探测）。  

3. **前端应用场景**：  
   - 快速缓存数据（如React Fiber节点的缓存查询）；  
   - 路由参数解析（键值对存储）；  
   - 状态管理库（如Redux中的快速状态索引）。  

4. **性能优化**：  
   - **动态扩容**：当负载因子（元素数/桶数）超过阈值时，倍增桶数并重新哈希；  
   - **哈希函数优化**：减少碰撞概率（如使用质数模数）。  

**哈希表与JavaScript对象的差异**  

- **键类型**：对象仅支持字符串/Symbol键，哈希表可支持任意类型（需序列化处理）；  
- **顺序性**：ES6后对象保留插入顺序，哈希表通常无序；  
- **冲突处理**：对象内部使用更复杂的优化策略（如V8引擎的隐藏类）。  

通过手动实现哈希表，能更深入理解数据结构原理及其在前端性能优化中的潜在价值。

## 如何实现深度优先搜索（DFS）和广度优先搜索（BFS）？


**深度优先搜索（DFS）**  

**核心思想**：尽可能深地遍历分支，直到末端再回溯。  

**实现方式**：  
1. **递归法**（隐式调用栈）：  
```javascript  
function dfs(node) {  
  if (!node) return;  
  console.log(node.value); // 处理当前节点  
  node.children.forEach(child => dfs(child));  
}  
```
2. **迭代法**（显式使用栈）：  
```javascript  
function dfs(root) {  
  const stack = [root];  
  while (stack.length) {  
    const node = stack.pop();  
    console.log(node.value);  
    // 子节点逆序入栈以保证顺序正确（如左→右）  
    node.children.slice().reverse().forEach(child => stack.push(child));  
  }  
}  
```
**应用场景**：  
- DOM树遍历（如查找嵌套组件）；  
- 路径探索（如迷宫问题）；  
- 依赖解析（Webpack模块循环检测）。  

**广度优先搜索（BFS）**  

**核心思想**：逐层遍历，先处理离根节点最近的节点。  

**实现方式**（使用队列）：  
```javascript  
function bfs(root) {  
  const queue = [root];  
  while (queue.length) {  
    const node = queue.shift(); // 改用索引（如指针）优化性能  
    console.log(node.value);  
    node.children.forEach(child => queue.push(child));  
  }  
}  
```
**优化队列**（避免`shift`低效）：  
```javascript  
function bfsOptimized(root) {  
  const queue = [root];  
  let index = 0; // 手动维护指针  
  while (index < queue.length) {  
    const node = queue[index++];  
    console.log(node.value);  
    node.children.forEach(child => queue.push(child));  
  }  
}  
```
**应用场景**：  
- 最短路径问题（如社交网络好友层级）；  
- 按层级渲染组件（如树形表格）；  
- 任务调度（如异步请求并发控制）。  

**关键对比**  

| 特性             | DFS                | BFS                 |
| ---------------- | ------------------ | ------------------- |
| **数据结构**     | 栈（LIFO）         | 队列（FIFO）        |
| **空间复杂度**   | O(h)（h为树高度）  | O(w)（w为最大宽度） |
| **适用场景**     | 深层遍历、路径探索 | 层级遍历、最短路径  |
| **前端典型应用** | 递归组件渲染       | 路由权限层级校验    |

**图的遍历注意事项**  

若处理图结构（含循环引用），需记录已访问节点：  
```javascript  
// DFS（图）  
function dfsGraph(node, visited = new Set()) {  
  if (visited.has(node)) return;  
  visited.add(node);  
  console.log(node.value);  
  node.neighbors.forEach(neighbor => dfsGraph(neighbor, visited));  
}  

// BFS（图）  
function bfsGraph(startNode) {  
  const queue = [startNode];  
  const visited = new Set([startNode]);  
  while (queue.length) {  
    const node = queue.shift();  
    console.log(node.value);  
    node.neighbors.forEach(neighbor => {  
      if (!visited.has(neighbor)) {  
        visited.add(neighbor);  
        queue.push(neighbor);  
      }  
    });  
  }  
}  
```

**总结**  

- **DFS** 通过栈实现深度探索，适合解决“是否存在路径”问题；  
- **BFS** 通过队列实现层级扩展，适合解决“最短路径”问题；  
- 根据业务场景选择算法，例如前端组件树遍历多用DFS，权限校验层级多用BFS。

## 说说你对二分查找的理解？应用场景？


**二分查找理解**  

二分查找是**针对有序数据的高效搜索算法**，核心通过 **“折半淘汰”** 缩小范围，时间复杂度 **O(logn)**。关键点：  
1. **前提条件**：数据必须有序（或可间接排序）；  
2. **核心操作**：取中间值比较，动态调整左右边界；  
3. **终止条件**：左边界超过右边界。  

**前端应用场景**  

1. **性能优化**  
   - 日志时间戳快速定位（如监控系统按时间排序的日志）；  
   - 长列表渲染时计算可视区域起始索引（虚拟列表优化）。  

2. **功能实现**  
   - 自动补全建议词匹配（有序词库中查找前缀）；  
   - 版本号比较（如语义化版本数组中找到最近的兼容版本）。  

3. **框架底层**  
   - React Scheduler 中任务优先级排序；  
   - Babel 插件按条件范围匹配 AST 节点。  

**代码实现（JavaScript）**  

```javascript  
function binarySearch(sortedArray, target) {  
  let left = 0;  
  let right = sortedArray.length - 1;  

  while (left <= right) {  
    const mid = Math.floor((left + right) / 2);  
    const midVal = sortedArray[mid];  

    if (midVal === target) {  
      return mid; // 找到目标  
    } else if (midVal < target) {  
      left = mid + 1; // 淘汰左半区  
    } else {  
      right = mid - 1; // 淘汰右半区  
    }  
  }  
  return -1; // 未找到  
}  

// 示例  
const arr = [1, 3, 5, 7, 9];  
console.log(binarySearch(arr, 5)); // 2  
```

**边界与变种问题**  

1. **重复元素**：  
   - 查找第一个/最后一个匹配项（如LeetCode 34题）；  
2. **非显式有序**：  
   - 旋转排序数组查找（如LeetCode 33题）；  
3. **抽象场景**：  
   - 数值范围二分（如求平方根）。  

**注意事项**  

- **数值溢出**：`mid = left + (right - left) >> 1` 替代 `(left+right)/2`；  
- **浮点处理**：精度控制（如保留小数位）；  
- **业务结合**：数据是否频繁变动（决定是否维护排序成本）。  

二分查找的价值在于 **用有序性换时间效率**，适合前端大数据量下的性能敏感场景。

## 说说你对动态规划的理解？应用场景？

**动态规划（DP）** 是通过 **拆解子问题+复用中间解** 解决复杂问题的策略，核心是 **状态转移方程** 和 **最优子结构**。  

**前端应用场景**  

1. **性能优化**  
   - 虚拟DOM Diff中最小化操作（如最长公共子序列算法优化移动逻辑）；  
   - 资源预加载策略（按依赖关系动态规划加载顺序）。  

2. **交互逻辑**  
   - 富文本差异比对（如协同编辑的OT算法中状态合并）；  
   - 动画路径规划（贝塞尔曲线关键帧的最优插值计算）。  

3. **数据处理**  
   - 文本相似度计算（如Levenshtein最短编辑距离）；  
   - 动态表单校验（多步骤校验结果复用）。  

**代码示例（最短编辑距离）**  

```javascript  
function minEditDistance(strA, strB) {  
  const [m, n] = [strA.length, strB.length];  
  const dp = Array(m+1).fill().map(() => Array(n+1).fill(0));  

  // 初始化边界条件  
  for (let i = 0; i <= m; i++) dp[i][0] = i;  
  for (let j = 0; j <= n; j++) dp[0][j] = j;  

  for (let i = 1; i <= m; i++) {  
    for (let j = 1; j <= n; j++) {  
      if (strA[i-1] === strB[j-1]) {  
        dp[i][j] = dp[i-1][j-1]; // 字符相同无需操作  
      } else {  
        dp[i][j] = Math.min(  
          dp[i-1][j] + 1,   // 删除  
          dp[i][j-1] + 1,   // 插入  
          dp[i-1][j-1] + 1  // 替换  
        );  
      }  
    }  
  }  
  return dp[m][n];  
}  

console.log(minEditDistance("kitten", "sitting")); // 3  
```

**关键点**  

- **状态定义**：明确`dp[i][j]`含义（如`i/j`表示子串长度）；  
- **转移方程**：根据业务逻辑推导递推关系；  
- **空间优化**：滚动数组压缩（如二维DP转一维）。  

动态规划的价值在于 **用空间换时间的高效复杂决策**，适合前端高复杂度且可拆解的交互场景。

## 说说你对贪心算法，回溯算法的理解？应用场景？


**贪心算法**  

**理解**：每一步选择当前最优解，期望得到全局最优。**特点**是高效但不保证全局最优，需验证贪心策略是否成立。  

**前端应用场景**：  
1. **资源分配**  
   - 按需加载优先级（如首屏关键资源优先加载）；  
   - 图片懒加载顺序（按视口距离动态计算加载顺序）。  
2. **调度优化**  
   - React Scheduler 中高优先级任务插队（如用户交互优先于渲染）；  
   - 请求并发控制（优先处理耗时短的任务）。  
3. **近似解场景**  
   - 离线缓存策略（如Service Worker按访问频率缓存资源）。  

**代码示例（找零问题-贪心）**：  
```javascript  
function greedyCoinChange(coins, amount) {  
  coins.sort((a, b) => b - a); // 降序排序  
  let count = 0;  
  for (const coin of coins) {  
    while (amount >= coin) {  
      amount -= coin;  
      count++;  
    }  
  }  
  return amount === 0 ? count : -1; // 仅适用特定币种（如人民币）  
}  
console.log(greedyCoinChange([1, 5, 10], 28)); // 10+10+5+1+1+1 → 6枚  
```

**回溯算法**  

**理解**：通过试错遍历所有可能解，走不通时回退（剪枝）。**特点**是暴力穷举，时间复杂度高但能找所有解。  

**前端应用场景**：  
1. **组合问题**  
   - 动态表单多条件联动校验（如某选项触发后续字段显隐组合校验）；  
   - 权限路由树生成（遍历角色权限组合生成可用路由）。  
2. **路径探索**  
   - 低代码平台节点连线合法性校验（如禁止循环依赖）；  
   - 游戏类页面解谜逻辑（如迷宫路径回溯渲染）。  
3. **决策场景**  
   - 可视化配置工具的条件分支生成（如嵌套`if-else`规则树）。  

**代码示例（全排列-回溯）**：  
```javascript  
function permute(nums) {  
  const res = [];  
  const backtrack = (path, used) => {  
    if (path.length === nums.length) {  
      res.push([...path]);  
      return;  
    }  
    for (let i = 0; i < nums.length; i++) {  
      if (used[i]) continue;  
      used[i] = true;  
      path.push(nums[i]);  
      backtrack(path, used);  
      path.pop();  
      used[i] = false;  
    }  
  };  
  backtrack([], []);  
  return res;  
}  
console.log(permute([1, 2, 3])); // [[1,2,3],[1,3,2],...]  
```

**对比与选型**  

| 特性             | 贪心算法               | 回溯算法               |
| ---------------- | ---------------------- | ---------------------- |
| **时间复杂度**   | 通常较低（O(n)~O(n²)） | 较高（O(n!)或指数级）  |
| **解的质量**     | 局部最优，未必全局最优 | 精确解（全解或最优解） |
| **适用场景**     | 高效近似解             | 小规模精确解           |
| **前端典型应用** | 性能优化调度           | 配置类工具逻辑         |

**注意事项**  

- **贪心算法**需验证策略正确性（如找零问题中币种是否满足贪心条件）；  
- **回溯算法**必须剪枝（如路径记录`used`数组避免重复计算），否则易性能爆炸。  

两者在前端中虽不常用，但在解决特定复杂交互逻辑时能提供清晰的算法模型。

## 冒泡排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/冒泡排序.webp)

```javascript
function bubbleSort(arr){
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if(arr[j]>arr[j+1]){
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return arr
}
```

## 选择排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/选择排序.webp)

```javascript
function selectSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[min]) {
        min = j
      }
    }
    [arr[i], arr[min]] = [arr[min], arr[i]]
  }
}
```

## 插入排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/插入排序.webp)

```javascript
function insertSort(arr) {
  // 从第 2 个元素开始遍历序列
  for (let i = 1; i < arr.length; i++) {
    let j = i;
    //记录要插入的目标元素
    let target = arr[j];
    //从 target 所在位置向前遍历，直至找到一个比目标元素小的元素，目标元素插入到该元素之后的位置
    while (j > 0 && arr[j - 1] > target) {
      //移动前一个元素的位置，将其向后移动一个位置
      arr[j] = arr[j - 1];
      j--;
    }
    arr[j] = target;
  }
  return arr;
}
```

## 快速排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/快速排序.webp)

```javascript
function quickSort(arr) {
  if(arr.length <= 1) return arr
  let pivot = arr[0]
  let left = []
  let right = []
  for (let i = 1; i < arr.length; i++) {
    if(arr[i] < pivot) {
      left.push(arr[i])
    }else {
      right.push(arr[i])
    }
  }
  return [...quickSort(left), pivot, ...quickSort(right)]
}
```



```javascript
function quickSort(array, start, end) {
  if (start >= end) {
    return;
  }
  let pivot = array[start];
  let left = start + 1;
  let right = end;
  while (left < right) {
    while (left < right && array[left] <= pivot) {
      left++;
    }
    while (left < right && array[right] >= pivot) {
      right--;
    }
    if (left < right) {
      let temp = array[left];
      array[left] = array[right];
      array[right] = temp;
    }
  }
  array[start] = array[right];
  array[right] = pivot;
  quickSort(array, start, right - 1);
  quickSort(array, right + 1, end);
  return array
}
```



## 归并排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/归并排序.webp)

```javascript
function MergeSort(array) {
  let len = array.length;

  // 当每个子序列中仅有1个元素时返回
  if (len <= 1) {
    return array;
  }
  // 将给定的列表分为两半
  let num = Math.floor(len / 2);
  let left = MergeSort(array.slice(0, num));
  let right = MergeSort(array.slice(num, array.length));
  return merge(left, right);

  function merge(left, right) {
    let [l, r] = [0, 0];
    let result = [];
    // 从 left 和 right 区域中各个取出第一个元素，比较它们的大小
    while (l < left.length && r < right.length) {
      // 将较小的元素添加到result中，然后从较小元素所在的区域内取出下一个元素，继续进行比较；
      if (left[l] < right[r]) {
        result.push(left[l]);
        l++;
      } else {
        result.push(right[r]);
        r++;
      }
    }
    // 如果 left 或者 right 有一方为空，则直接将另一方的所有元素依次添加到result中
    result = result.concat(left.slice(l, left.length));
    result = result.concat(right.slice(r, right.length));
    return result;
  }
}
```




## 反转链表

```javascript
function reverseLinkList(head) {
  let pre = null
  let cur = head
  while (cur) {
    let next = cur.next
    cur.next = pre
    pre = cur
    cur = next
  }
}

```

## K个一组翻转链表

```javascript
function reverseKGroup(head, k) {
  if(head === null||k===1) return head
  let a,b
  a = b = head
  for (let i = 0; i < k; i++) {
    if(b === null) return head
    b = b.next
  }
  let newHead = reverse(a,b)
  a.next = reverseKGroup(b,k)
  function reverse(a,b){
    let pre = null
    let cur = a
    while(cur!==b){
      let next = cur.next
      cur.next = pre
      pre = cur
      cur = next
    }
    return pre
  }
  return newHead
}
```



## 判断链表是否有环

```javascript
function isRingLinkList(head) {
  let fast = head
  let slow = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}
```

## 二叉树的遍历  


**二叉树遍历的核心类型**  

1. **前序遍历（根→左→右）**  
2. **中序遍历（左→根→右）**  
3. **后序遍历（左→右→根）**  
4. **层次遍历（BFS逐层访问）**  

**代码实现（JavaScript）**  

1. 前序遍历  

**递归实现**：  
```javascript  
function preorder(root) {  
  if (!root) return [];  
  return [root.val, ...preorder(root.left), ...preorder(root.right)];  
}  
```
**迭代实现（栈模拟递归）**：  

```javascript  
function preorderIterative(root) {  
  const stack = [root], res = [];  
  while (stack.length) {  
    const node = stack.pop();  
    if (!node) continue;  
    res.push(node.val);  
    stack.push(node.right); // 右先入栈，保证左先出栈  
    stack.push(node.left);  
  }  
  return res;  
}  
```

2. 中序遍历  

**递归实现**：  
```javascript  
function inorder(root) {  
  if (!root) return [];  
  return [...inorder(root.left), root.val, ...inorder(root.right)];  
}  
```
**迭代实现**：  
```javascript  
function inorderIterative(root) {  
  const stack = [], res = [];  
  let curr = root;  
  while (curr || stack.length) {  
    while (curr) {  
      stack.push(curr);  
      curr = curr.left; // 左子树全部入栈  
    }  
    curr = stack.pop();  
    res.push(curr.val);  
    curr = curr.right; // 转向右子树  
  }  
  return res;  
}  
```

3. 后序遍历  

**递归实现**：  
```javascript  
function postorder(root) {  
  if (!root) return [];  
  return [...postorder(root.left), ...postorder(root.right), root.val];  
}  
```
**迭代实现（逆序技巧）**：  
```javascript  
function postorderIterative(root) {  
  const stack = [root], res = [];  
  while (stack.length) {  
    const node = stack.pop();  
    if (!node) continue;  
    res.push(node.val);  
    stack.push(node.left); // 调整入栈顺序，结果逆序即为后序  
    stack.push(node.right);  
  }  
  return res.reverse();  
}  
```

4. 层次遍历（BFS队列实现）  

```javascript  
function levelOrder(root) {  
  const queue = [root], res = [];  
  while (queue.length) {  
    const levelSize = queue.length, level = [];  
    for (let i = 0; i < levelSize; i++) {  
      const node = queue.shift();  
      if (!node) continue;  
      level.push(node.val);  
      queue.push(node.left);  
      queue.push(node.right);  
    }  
    if (level.length) res.push(level);  
  }  
  return res;  
}  
```

**前端应用场景**  

1. **DOM树操作**  
   - **前序**：克隆DOM树结构（先复制当前节点再处理子节点）  
   - **后序**：批量移除子节点（先清空子节点再删除父节点）  

2. **组件树处理**  
   - **中序**：表单联动校验（如左侧树控件选中后更新中间表单）  
   - **层次遍历**：按优先级渲染组件（如弹窗层级管理）  

3. **状态管理**  
   - **后序**：Redux中间件执行顺序（先子中间件后父级）  
   - **前序**：依赖注入（先父组件提供数据再子组件消费）  

4. **性能优化**  
   - **中序**：AST语法树分析（Babel插件转换代码）  
   - **层次遍历**：虚拟列表可视区域计算（分块渲染）  

**注意事项**  

1. **递归风险**：深层次树可能导致栈溢出，建议用迭代法处理大数据量；  
2. **遍历顺序**：前/中/后序本质是 **处理当前节点的时机不同**；  
3. **框架应用**：React Fiber架构的遍历策略结合了DFS和优先级调度。  

遍历方法的选择需结合业务目标，例如需要 **快速定位叶子节点** 时优先考虑后序，**按层级渲染** 则必须用BFS。

## 二叉树搜索


**二叉搜索树（BST）核心特性**  

1. **有序性**：左子树节点值 < 根节点值 < 右子树节点值；  
2. **高效性**：查找/插入/删除平均时间复杂度 **O(logn)**（树平衡时）；  
3. **中序遍历**：可直接输出有序数据序列。  

**基本操作实现（JavaScript）**  

1. 查找  

```javascript  
function searchBST(root, target) {  
  if (!root) return null;  
  if (root.val === target) return root;  
  return target < root.val  
    ? searchBST(root.left, target)  
    : searchBST(root.right, target);  
}  
```

2. 插入  

```javascript  
function insertBST(root, val) {  
  if (!root) return new TreeNode(val);  
  if (val < root.val) {  
    root.left = insertBST(root.left, val);  
  } else if (val > root.val) {  
    root.right = insertBST(root.right, val);  
  }  
  return root; // 忽略重复值  
}  
```

3. 删除（最复杂）  

```javascript  
function deleteBST(root, key) {  
  if (!root) return null;  
  if (key < root.val) {  
    root.left = deleteBST(root.left, key);  
  } else if (key > root.val) {  
    root.right = deleteBST(root.right, key);  
  } else {  
    // 找到目标节点  
    if (!root.left) return root.right; // 无左子树  
    if (!root.right) return root.left;  // 无右子树  
    // 找右子树最小节点替代  
    let minNode = root.right;  
    while (minNode.left) minNode = minNode.left;  
    root.val = minNode.val;  
    root.right = deleteBST(root.right, minNode.val); // 删除替代节点  
  }  
  return root;  
}  
```

**前端应用场景**  

1. **数据快速检索**  
   - 大型表单中按用户ID快速查询（替代数组遍历的O(n)）；  
   - 前端缓存有序数据（如商品价格区间筛选）。  

2. **框架底层优化**  
   - React Fiber任务优先级调度（按过期时间组织任务树）；  
   - 富文本编辑器光标位置管理（按文本偏移量组织节点）。  

3. **可视化工具**  
   - 组织架构图按层级排序渲染；  
   - 时间轴工具按时间戳排序事件节点。  

**BST的局限性及解决方案**  

| 问题               | 后果               | 解决方案                   |
| ------------------ | ------------------ | -------------------------- |
| **不平衡树**       | 退化为链表（O(n)） | 自平衡树（AVL/红黑树）     |
| **内存开销**       | 节点存储指针       | 数组模拟树结构（堆式存储） |
| **范围查询效率低** | 需多次遍历         | 跳表或B+树                 |

**验证BST合法性（高频面试题）**  

```javascript  
function isValidBST(root, min = -Infinity, max = Infinity) {  
  if (!root) return true;  
  if (root.val <= min || root.val >= max) return false;  
  return isValidBST(root.left, min, root.val) &&  
         isValidBST(root.right, root.val, max);  
}  
// 示例：通过中序遍历验证是否严格递增  
function isValidBSTInOrder(root) {  
  let prev = -Infinity;  
  const inorder = (node) => {  
    if (!node) return true;  
    if (!inorder(node.left)) return false;  
    if (node.val <= prev) return false;  
    prev = node.val;  
    return inorder(node.right);  
  };  
  return inorder(root);  
}  
```

**总结**  

BST在前端中虽不常用，但在处理 **有序数据高频检索** 时能显著优化性能。实际开发中需注意：  
1. 优先使用语言内置结构（如`Map`/`Set`）；  
2. 数据量较大时考虑平衡树变种或跳表；  
3. 结合业务场景选择数据结构，避免过度设计。



## 二叉树diff算法


**二叉树 Diff 算法核心思路**  

二叉树 Diff 的目标是 **高效识别两棵树的结构与内容差异**，通常用于虚拟 DOM 优化或数据同步。其实现需解决两个关键问题：  
1. **节点比对**：判断节点是否相同（通常依赖唯一 key 或值）；  
2. **差异定位**：识别增删改移操作。  

**基础实现（递归比对）**  

```javascript  
function diffTrees(oldNode, newNode) {  
  const changes = [];  

  // 节点删除  
  if (!newNode && oldNode) {  
    changes.push({ type: 'REMOVE', node: oldNode });  
    return changes;  
  }  

  // 节点新增  
  if (!oldNode && newNode) {  
    changes.push({ type: 'ADD', node: newNode });  
    return changes;  
  }  

  // 节点值更新  
  if (oldNode.val !== newNode.val) {  
    changes.push({ type: 'UPDATE', oldNode, newNode });  
  }  

  // 递归比对子树  
  const leftDiff = diffTrees(oldNode?.left, newNode?.left);  
  const rightDiff = diffTrees(oldNode?.right, newNode?.right);  

  return [...changes, ...leftDiff, ...rightDiff];  
}  
```

**优化策略**  

1. **Key 标识**：  
   - 为节点添加唯一标识（如 `key`），避免仅依赖位置比对，支持跨层级移动检测。  

2. **哈希映射**：  
   - 预处理新树生成 `key-to-node` 哈希表，快速定位旧节点在新树中的位置。  

3. **动态规划（LCS）**：  
   - 通过最长公共子序列算法（如 Myers 算法）最小化操作步骤，减少节点移动成本。  

**优化示例（哈希映射加速查找）**：  
```javascript  
function optimizedDiff(oldRoot, newRoot) {  
  const oldMap = new Map();  
  traverse(oldRoot, node => oldMap.set(node.key, node));  
  return diffHelper(oldRoot, newRoot, oldMap);  
}  

function diffHelper(oldNode, newNode, oldMap) {  
  const changes = [];  
  if (!oldNode && newNode) {  
    changes.push({ type: 'ADD', node: newNode });  
  } else if (oldNode && !newNode) {  
    changes.push({ type: 'REMOVE', node: oldNode });  
  } else if (oldNode.key !== newNode.key) {  
    // Key 不同视为替换  
    changes.push({ type: 'REPLACE', oldNode, newNode });  
  } else {  
    if (oldNode.val !== newNode.val) {  
      changes.push({ type: 'UPDATE', oldNode, newNode });  
    }  
    // 递归处理子节点  
    const oldLeft = oldNode.left, newLeft = newNode.left;  
    const oldRight = oldNode.right, newRight = newNode.right;  
    const leftMatch = oldLeft?.key === newLeft?.key ? newLeft : oldMap.get(newLeft?.key);  
    const rightMatch = oldRight?.key === newRight?.key ? newRight : oldMap.get(newRight?.key);  
    changes.push(...diffHelper(oldLeft, leftMatch, oldMap));  
    changes.push(...diffHelper(oldRight, rightMatch, oldMap));  
  }  
  return changes;  
}  
```

**前端应用场景**  

1. **虚拟 DOM 更新**：  
   - React Reconciler 通过 Diff 算法比对 Fiber 树，生成 DOM 操作指令；  
   - Vue 3 的 Block Tree 优化静态节点比对。  

2. **数据同步**：  
   - 配置系统对比新旧 JSON 树生成增量更新；  
   - 协同编辑中合并多人操作（如 OT 算法）。  

3. **可视化工具**：  
   - 流程图版本差异对比；  
   - 低代码平台组件树状态回滚。  

**性能瓶颈与突破**  

| 问题                  | 解决方案                                                     |
| --------------------- | ------------------------------------------------------------ |
| **全量递归性能差**    | 按层级分片 Diff（如 React 的时间切片）                       |
| **跨层级移动难检测**  | 基于 Key 的哈希映射 + 双向编辑图（如 Google Diff-Match-Patch） |
| **多次 DOM 操作卡顿** | 批处理更新（如 React 的 commit 阶段合并操作）                |

**总结**  

二叉树 Diff 的核心是 **平衡准确性与性能**：  
- **简单场景**：递归比对即可满足需求；  
- **复杂场景**：需引入 Key 映射、哈希预计算或动态规划优化。  
在前端框架中，Diff 算法直接影响渲染性能，需结合业务场景选择策略（如牺牲少量准确性换取更高帧率）。



## 图的最小生成树


**最小生成树（Minimum Spanting Tree, MST）的核心概念**  

最小生成树是 **连通加权无向图中权值和最小的生成树**，需满足：  
1. 包含所有顶点；  
2. 无环且边数 = 顶点数 - 1；  
3. 总权重最小。  

**算法实现（JavaScript）**  

1. **Prim算法（贪心思想，适合稠密图）**  

**步骤**：  
1. 从任一顶点开始，初始化最小堆（按边权排序）；  
2. 每次取堆顶最小边，将新顶点加入生成树，并更新相邻边入堆；  
3. 重复直到所有顶点连通。  

**代码示例**：  
```javascript  
function primMST(graph) {  
  const n = graph.length;  
  const visited = new Array(n).fill(false);  
  const minHeap = new PriorityQueue((a, b) => a.weight - b.weight);  
  const result = [];  

  // 从顶点0开始  
  visited[0] = true;  
  graph[0].forEach((weight, neighbor) => {  
    if (weight > 0) minHeap.push({ from: 0, to: neighbor, weight });  
  });  

  while (result.length < n - 1) {  
    const { from, to, weight } = minHeap.pop();  
    if (visited[to]) continue;  

    result.push({ from, to, weight });  
    visited[to] = true;  

    graph[to].forEach((nextWeight, nextNeighbor) => {  
      if (nextWeight > 0 && !visited[nextNeighbor]) {  
        minHeap.push({ from: to, to: nextNeighbor, weight: nextWeight });  
      }  
    });  
  }  
  return result;  
}  
```

2. **Kruskal算法（并查集，适合稀疏图）**  

**步骤**：  

1. 将所有边按权重升序排序；  
2. 按序选择边，若两端点不在同一集合（不形成环），则合并集合；  
3. 重复直到选够n-1条边。  

**代码示例**：  
```javascript  
class UnionFind {  
  constructor(size) {  
    this.parent = Array.from({ length: size }, (_, i) => i);  
  }  
  find(x) {  
    if (this.parent[x] !== x) {  
      this.parent[x] = this.find(this.parent[x]);  
    }  
    return this.parent[x];  
  }  
  union(x, y) {  
    const rootX = this.find(x);  
    const rootY = this.find(y);  
    if (rootX !== rootY) this.parent[rootY] = rootX;  
  }  
}  

function kruskalMST(edges, n) {  
  edges.sort((a, b) => a.weight - b.weight);  
  const uf = new UnionFind(n);  
  const result = [];  

  for (const edge of edges) {  
    const { from, to, weight } = edge;  
    if (uf.find(from) !== uf.find(to)) {  
      result.push(edge);  
      uf.union(from, to);  
      if (result.length === n - 1) break;  
    }  
  }  
  return result;  
}  
```

**前端应用场景**  

1. **网络拓扑优化**：  
   - 可视化工具中计算服务器节点间的最优布线方案；  
   - 低代码平台组件依赖的最小连接路径生成。  
2. **游戏开发**：  
   - 地图生成（如村庄间道路的最低成本规划）；  
   - 资源运输路径的动态计算（避免绕路）。  
3. **数据分析**：  
   - 用户关系图谱中的关键连接挖掘；  
   - 前端监控系统依赖项的最小覆盖分析。  

**对比与选型**  

| 特性           | Prim算法                 | Kruskal算法            |
| -------------- | ------------------------ | ---------------------- |
| **时间复杂度** | O(E + V log V)（二叉堆） | O(E log E)（排序主导） |
| **适用图类型** | 稠密图（邻接矩阵）       | 稀疏图（边列表）       |
| **空间复杂度** | O(V + E)                 | O(E)                   |
| **实现复杂度** | 需优先队列支持           | 需并查集结构           |

**注意事项**  

1. **边权重处理**：需保证权重为非负数（负权需特殊处理）；  
2. **图的连通性**：非连通图无法生成完整MST；  
3. **性能优化**：  
   - 大规模数据下，Kruskal算法可用路径压缩优化并查集；  
   - Prim算法使用斐波那契堆可优化至O(E + V log V)。  

**总结**  

最小生成树是图论中的经典问题，在前端涉及复杂网络可视化或路径优化时具有实际价值。根据数据特点选择算法：  
- **密集连接** → Prim算法；  
- **分散连接** → Kruskal算法。  
实际开发中可结合框架能力（如Web Worker）处理大规模计算，避免阻塞主线程。

## 斐波那契数列





```javascript
//普通递归
function fib(num) {
  if (num < 2) {
    return num;
  }

  return fib(num - 1) + fib(num - 2);
}
//尾递归

function fib2(n,a = 0,b = 1) {
    if(n === 0) return a;
    if(n === 1 ) return b;
    return fib2(n - 1, b,a+ b)
}
//动态规划

function fib3(n) {
    if( n === 0 || n === 1) return n
    let a = 0,b = 1;
    let temp = 0;
    for(let i = 2; i <= n; i++) {
        temp = a + b;
        a = b;
        b = temp
    }
    return temp;
}

```

## 青蛙跳台阶问题



```javascript
function jumpFloor(number)
{
    if(number === 1){
        return 1
    }
    if(number === 2){
        return 2
    }
    if(number > 2){
        return jumpFloor(number-1)+jumpFloor(number-2)
    }
}
```


## 电话号码组合

```javascript
function letterCombinations(digits) {
  if (!digits) return [];

  const phoneMap = {
    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
  };

  const result = [];

  function backtrack(combination, nextDigits) {
    if (nextDigits.length === 0) {
      result.push(combination);
    } else {
      const digit = nextDigits[0];
      const letters = phoneMap[digit];
      for (let i = 0; i < letters.length; i++) {
        backtrack(combination + letters[i], nextDigits.slice(1));
      }
    }
  }

  backtrack('', digits);
  return result;
}
```

## 字符串所有排列组合

```javascript
function getPermutation(str) {
  const res = []
  const dfs = (path) => {
    if (path.length === str.length) {
      res.push(path)
      return
    }
    for (let i = 0; i < str.length; i++) {
      if (path.includes(str[i])) continue
      dfs(path + str[i])
    }
  }
  dfs('')
  return res
}
```

## 最长回文子串

```javascript
function longestPalindrome(s) {
  if (s.length === 1) return s;
  let maxRes = 0, maxStr = '';
  for (let i = 0; i < s.length; i++) {
    let str1 = palindrome(s, i, i);
    if (str1.length > maxRes) {
      maxStr = str1;
      maxRes = str1.length;
    }
  }
  function palindrome(s, l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      l--;
      r++;
    }
    return s.slice(l + 1, r);
  }
  return maxStr;
}
```

## 版本号排序

```javascript
function versionSort(arr) {
  return arr.sort((a,b)=>{
    const arr1 = a.split('.')
    const arr2 = b.split('.')
    while(arr1.length || arr2.length){
      const a1 = arr1.shift()
      const b1 = arr2.shift()
      if(!a1)return -1
      if(!b1)return 1
      if(a1!==b1){
        return a1 - b1
      }
    }
  })
}
```



## <span id="flat">数组拍平</span>

- Array.prototype.flat(depth)

```javascript
  let newArray = arr.flat(Infinity)
```

- 迭代

```javascript
function flatten(array) {
  const result = [];
  const stack = [array];
  while (stack.length > 0) {
    const item = stack.pop();
    if (Array.isArray(item)) {
      for (let i = item.length - 1; i >= 0; i--) {
        stack.push(item[i]);
      }
    } else {
      result.push(item);
    }
  }
  return result.reverse();
}
```

- 递归

```javascript
function arrayFlat(arr) {
  let result = []
  arr.forEach(item => {
    if (item instanceof Array) {
      result = result.concat(arrayFlat(item))
    } else {
      result.push(item)
    }
  })
  return result
}

function arrayFlat2(arr) {
  return arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? arrayFlat2(cur) : cur), [])
}
```

- 简单情况toString

```javascript
function arrayFlat(arr) {
  return arr.toString().split(',').map(item=>parseInt(item))
}
```

## 有效的括号

给定一个只包括'('，')'，'{'，'}'，'['，']'的字符串s，判断字符串是否有效。

```java
function isValidBrackets(str) {
  const map = new Map([['(', ')'], ['[', ']'], ['{', '}'],])
  const stack = []

  for (let i = 0; i < str.length; i++) {
    if (map.has(str[i])) {
      stack.push(str[i])
    } else if (map.get(stack[stack.length - 1]) === str[i]) {
      stack.pop()
    } else {
      return false
    }
  }
  return stack.length === 0
}
```

## 最长递增子序列

在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。

[最长递增子序列](https://www.bilibili.com/video/BV19M4m1X7Do/?spm_id_from=333.337.search-card.all.click&vd_source=a4e90c849b91dfcaf761cb42efd7e48c)

```javascript
function LIS(nums) {
  if(nums.length === 0) return []
  const results = [[nums[0]]];
  for (let i = 0; i < nums.length; i++) {
    const current = nums[i];
    _update(current)
  }

  function _update(n) {
    for (let i = results.length - 1; i >= 0; i--) {
      const line = results[i];
      const tail = line[line.length - 1];

      if (tail < n) {
        results[i + 1] = [...line, n];
        break
      }else if (n < tail && i === 0) {
        results[0] = [n]
      }
    }
  }
  return results[results.length - 1]
}
```

## 滑动窗口最大值

给定一个长度为n的数组和一个大小为m的滑动窗口(0<m<=n)请找出所有滑动窗口里的最大值。

- 双端队列

```javascript
function maxSlidingWindow(nums, k) {
  let window = [...nums.slice(0,k)]
  let res = []
  for (let i = k; i < nums.length; i++) {
    res.push(Math.max(...window))
    window.shift()
    window.push(nums[i])
  }
  return res
}
```

- 单调队列

```javascript
var maxSlidingWindow2 = function (nums, k) {
  // 边界条件
  if (k > nums.length || k <= 0) return []
  let deque = [], res = []
  for (let i = 0; i < nums.length; i++) {
    // 如果nums[i]比栈尾的数大，则弹出
    while (deque.length && deque[deque.length - 1] < nums[i]) {
      deque.pop()
    }
    // nums[i]入栈
    deque.push(nums[i])
    // 删除离开窗口的元素
    if (deque[0] === nums[i - k]) deque.shift()
    // 推入最大值
    if (i >= k - 1) res.push(deque[0])
  }
  return res
};
```

## 两数之和

给定一个数组 nums 和一个目标值 target，在该数组中找出和为目标值的两个数。

```javascript
function towSum(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j]
      }
    }
  }
}
function towSum2(nums, target) {
    const map = new Map();
    for(let i = 0, len = nums.length; i < len; i++){
        if(map.get(nums[i]) !== undefined){
            return [map.get(nums[i]), i];
        } else {
            map.set(target - nums[i], i);
        }
    }
    return [];
};

```

## 三数之和

给定一个数组nums，判断 nums 中是否存在三个元素`a，b，c`，使得 `a + b + c = target`，找出所有满足条件且不重复的三元组合。

```javascript
function findThree(arr, target) {
  // 先将数组从小到大排序
  arr.sort((a, b) => a - b)
  let result = [];
  for (let i = 0; i < arr.length - 2; i++) {
    // 跳过重复的arr[i]值, 比如[2, 1, 1],跳过第二个1
    if (i && arr[i] === arr[i - 1]) continue;
    let left = i + 1;
    let right = arr.length - 1;

    // 双端指针left、right
    while (left < right) {
      let sum = arr[i] + arr[left] + arr[right];
      if (sum > target) {
        right--;
      } else if (sum < target) {
        left++;
      } else {
        // 先取arr[left]，然后left++, 两步合成一步；arr[right--]同样的逻辑
        result.push([arr[i], arr[left++], arr[right--]]);
        while (arr[left] === arr[left - 1]) {
          // 跳过重复的arr[left]值,
          left++;
        }
        while (arr[right] === arr[right + 1]) {
          // 跳过重复的arr[right]值
          right--;
        }
      }
    }
  }
  return result;
}

```



## 判断输入是不是回文字符串

```javascript
function isPlalindrome(input) {
  if (typeof input !== 'string') return false;
  return input.split('').reverse().join('') === input;
}

function isPlalindrome2(input) {
  if (typeof input !== 'string') return false;
  let i = 0, j = input.length - 1
  while(i < j) {
      if(input.charAt(i) !== input.charAt(j)) return false
      i ++
      j --
  }
  return true
}
```

## 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

```javascript
function bestTimeBuyStock(prices) {
  let minPrice = Infinity
  let maxProfit = 0
  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < minPrice) {
      minPrice = prices[i]
    } else if (prices[i] - minPrice > maxProfit) {
      maxProfit = prices[i] - minPrice
    }
  }
  return maxProfit
}
```

其他版本买股票问题：[买卖股票的最佳时机](https://zhuanlan.zhihu.com/p/136811810)

## 计算多个数组的交集

```javascript
const getIntersection = (...arrs) => {
  return arrs.reduce((pre, cur) => {
    return cur.filter(item => pre.includes(item));
  })
}
```



## 背包问题


**01背包问题解析**  

**问题描述**：给定容量为 `C` 的背包和 `N` 个物品，每个物品有重量 `w[i]` 和价值 `v[i]`，每个物品只能选或不选。目标是总重量不超容量的前提下，最大化总价值。

**动态规划解法（最优解）**  

**核心思想**：通过状态转移记录子问题最优解，逐步递推全局最优。  **实现步骤**  

1. **状态定义**  
   - `dp[i][j]`：前 `i` 个物品在容量 `j` 下的最大价值。  
   - **空间优化**：使用一维数组 `dp[j]`，逆序遍历容量避免覆盖。  

2. **状态转移方程**  
   ```  
   dp[j] = max(dp[j], dp[j - w[i]] + v[i])  （需 j >= w[i]）  
   ```

3. **代码实现**  
```javascript  
function knapsack01(C, weights, values) {  
  const dp = new Array(C + 1).fill(0);  
  for (let i = 0; i < weights.length; i++) {  
    for (let j = C; j >= weights[i]; j--) {  
      dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);  
    }  
  }  
  return dp[C];  
}  

// 示例  
const C = 4;  
const weights = [1, 3, 4];  
const values = [15, 20, 30];  
console.log(knapsack01(C, weights, values)); // 35（选物品0和2，重量1+4=5超出？需修正示例）
```
*注：示例中实际应为容量4，选物品3（重量3，价值20）和物品0（重量1，总价值35）？需要核对数据。*  

**特点**：  
- **时间复杂度**：`O(N*C)`，适合中等规模数据；  
- **空间复杂度**：`O(C)`，通过逆序压缩空间；  
- **保证全局最优**，但无法处理极大容量（如 `C > 1e5`）。  

**贪心算法（近似解，不保证最优）**  

**核心思想**：每一步选择当前最优策略（如价值密度最高），但无法保证全局最优。  **实现步骤**  

1. **排序物品**：按价值密度（`价值/重量`）降序排列；  
2. **贪心选择**：依次尝试装入当前最优物品，直到容量不足。  

**代码实现**：  
```javascript  
function greedyKnapsack(C, weights, values) {  
  const items = weights.map((w, i) => ({ w, v: values[i], ratio: values[i]/w }));  
  items.sort((a, b) => b.ratio - a.ratio);  

  let totalValue = 0, remaining = C;  
  for (const item of items) {  
    if (item.w <= remaining) {  
      totalValue += item.v;  
      remaining -= item.w;  
    }  
    if (remaining === 0) break;  
  }  
  return totalValue;  
}  

// 示例  
console.log(greedyKnapsack(4, [1,3,4], [15,20,30])); // 45（选物品0和2，总重量5？需修正示例）  
```
*注：示例数据需调整，例如 `C=5`，选物品0（重量1，价值15）和物品2（重量4，价值30），总价值45。*  

**局限性**：  
- **反例**：  
  - 容量为3，物品1（重量2，价值3）、物品2（重量3，价值4）。  
  - 贪心按密度选物品1（密度1.5），总价值3；实际最优解选物品2，价值4。  
- **适用场景**：仅当物品按价值密度排序且组合无冲突时可能最优（极少情况）。  

**对比与选型**  

| 特性           | 动态规划                 | 贪心算法                     |
| -------------- | ------------------------ | ---------------------------- |
| **解的质量**   | 全局最优                 | 局部最优，可能远离全局最优   |
| **时间复杂度** | O(N*C)                   | O(N log N)（排序主导）       |
| **适用场景**   | 精确解，中等数据规模     | 快速近似解，极大规模容量     |
| **前端应用**   | 资源分配优化（精确需求） | 实时计算的近似策略（如游戏） |

**总结**  

- **动态规划**是01背包问题的标准解法，保证最优但受容量限制；  
- **贪心算法**仅适用于分数背包问题（物品可分割），在01背包中无法保证最优，但可作为大规模数据的近似方案；  
- 实际开发中需根据场景权衡：若要求精确解且数据规模可控，用动态规划；若接受近似解且追求高效，可尝试贪心或其他启发式算法。

## N皇后问题


**N皇后问题解析**  

**问题描述**：在 `N×N` 的棋盘上放置 `N` 个皇后，使其彼此无法攻击（即任意两个皇后不在同一行、列或对角线）。目标是找到所有合法的放置方案。

**解法核心：回溯算法**  

**步骤拆解**：  

1. **逐行放置**：每行仅放一个皇后，递归处理下一行。  
2. **冲突检测**：检查当前列、主对角线（行-列）、副对角线（行+列）是否已被占用。  
3. **剪枝优化**：通过集合记录已占用的列和对角线，避免全量遍历检查。  

**JavaScript代码实现**  

```javascript  
function solveNQueens(n) {  
  const result = [];  
  // 初始化列、主对角线、副对角线占用集合  
  const cols = new Set();  
  const diag1 = new Set();  // 主对角线：row - col  
  const diag2 = new Set();  // 副对角线：row + col  

  // 回溯函数  
  const backtrack = (row, path) => {  
    if (row === n) {  
      // 生成棋盘格式（如 [".Q..","...Q"]）  
      const board = path.map(col => '.'.repeat(col) + 'Q' + '.'.repeat(n - col - 1));  
      result.push(board);  
      return;  
    }  
    for (let col = 0; col < n; col++) {  
      const d1 = row - col;  
      const d2 = row + col;  
      // 冲突检测  
      if (cols.has(col) || diag1.has(d1) || diag2.has(d2)) continue;  
      // 选择当前列  
      cols.add(col);  
      diag1.add(d1);  
      diag2.add(d2);  
      path.push(col);  
      // 递归下一行  
      backtrack(row + 1, path);  
      // 撤销选择  
      path.pop();  
      cols.delete(col);  
      diag1.delete(d1);  
      diag2.delete(d2);  
    }  
  };  

  backtrack(0, []);  
  return result;  
}  

// 示例：n=4 → 输出2种解法  
console.log(solveNQueens(4));  
```

**关键优化点**  

1. **冲突检测**：  
   - 列冲突 → `cols` 集合；  
   - 主对角线 → `row - col` 的差值唯一；  
   - 副对角线 → `row + col` 的和唯一。  
2. **时间复杂度**：最坏情况 `O(N!)`，但剪枝大幅减少实际计算量。  
3. **空间复杂度**：`O(N)`（递归栈深度 + 集合存储）。  

**前端应用场景**  

1. **可视化工具**：  
   - 棋盘交互式演示（如拖拽皇后动态校验合法性）；  
   - 算法教学动画生成（回溯过程可视化）。  
2. **游戏开发**：  
   - 解谜类游戏关卡设计（自动生成N皇后布局）；  
   - 棋类AI冲突检测逻辑。  
3. **性能测试**：  
   - 递归与剪枝策略的浏览器执行效率对比。  

**变种问题**  

1. **统计解法数量**：无需记录路径，仅计数。  
2. **随机合法解**：在回溯过程中随机选择有效列，快速找到一个解。  
3. **超大N优化**：位运算压缩状态（如用二进制表示列和对角线占用）。  

**注意事项**  

- **数据不可变性**：递归时传递深拷贝或回溯时及时撤销状态；  
- **N较大时的性能**：浏览器中N>15可能导致栈溢出或超时，需分帧计算或Web Worker处理；  
- **输出格式适配**：按题目要求返回数组格式（如LeetCode标准）。  

N皇后问题是回溯算法的经典案例，理解其冲突检测与状态管理机制对解决其他组合问题（如数独、排列组合）具有重要参考价值。

## 数组去重


```javascript
function arrayDeduplication(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) { 
        arr.splice(j, 1)
        j--
      }
    }
  }
  return arr
}
```

## 列表转树

```javascript
function listToTree(list) {
  list.forEach(item=>{
    item.children = []
    list.forEach(item2=>{
      if(item2.parentId === item.id){
        item.children.push(item2)
      }
    })
  })
  list = list.filter(item=>item.parentId === 0)
}
```



