---
category: 算法
order: 19
---
<script setup>
import NavHead from "../components/NavHead.vue";
</script>
<nav-head link="/posts/article/前端面试题合集/read.html">
</nav-head>


# 算法


## 说说你对算法的理解，应用场景？

## 说说你对数据结构的理解？有哪些？区别？

## 什么是时间复杂度，空间复杂度？

## 什么是链表？如何实现一个简单的单链表？

## 说说你对树的理解？应用场景？

## 说说你对堆，栈，队列的理解？应用场景？

## 什么是图？

## 什么是哈希表？如何使用对象实现一个简单的哈希表？

## 如何实现深度优先搜索（DFS）和广度优先搜索（BFS）？

## 说说你对二分查找的理解？应用场景？

## 说说你对动态规划的理解？应用场景？

## 说说你对贪心算法，回溯算法的理解？应用场景？



## 冒泡排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/冒泡排序.webp)

```javascript
function bubbleSort(arr){
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if(arr[j]>arr[j+1]){
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return arr
}
```

## 选择排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/选择排序.webp)

```javascript
function selectSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[min]) {
        min = j
      }
    }
    [arr[i], arr[min]] = [arr[min], arr[i]]
  }
}
```

## 插入排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/插入排序.webp)

```javascript
function insertSort(arr) {
  // 从第 2 个元素开始遍历序列
  for (let i = 1; i < arr.length; i++) {
    let j = i;
    //记录要插入的目标元素
    let target = arr[j];
    //从 target 所在位置向前遍历，直至找到一个比目标元素小的元素，目标元素插入到该元素之后的位置
    while (j > 0 && arr[j - 1] > target) {
      //移动前一个元素的位置，将其向后移动一个位置
      arr[j] = arr[j - 1];
      j--;
    }
    arr[j] = target;
  }
  return arr;
}
```

## 快速排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/快速排序.webp)

```javascript
function quickSort(arr) {
  if(arr.length <= 1) return arr
  let pivot = arr[0]
  let left = []
  let right = []
  for (let i = 1; i < arr.length; i++) {
    if(arr[i] < pivot) {
      left.push(arr[i])
    }else {
      right.push(arr[i])
    }
  }
  return [...quickSort(left), pivot, ...quickSort(right)]
}
```



```javascript
function quickSort(array, start, end) {
  if (start >= end) {
    return;
  }
  let pivot = array[start];
  let left = start + 1;
  let right = end;
  while (left < right) {
    while (left < right && array[left] <= pivot) {
      left++;
    }
    while (left < right && array[right] >= pivot) {
      right--;
    }
    if (left < right) {
      let temp = array[left];
      array[left] = array[right];
      array[right] = temp;
    }
  }
  array[start] = array[right];
  array[right] = pivot;
  quickSort(array, start, right - 1);
  quickSort(array, right + 1, end);
  return array
}
```



## 归并排序

![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/归并排序.webp)

```javascript
function MergeSort(array) {
  let len = array.length;

  // 当每个子序列中仅有1个元素时返回
  if (len <= 1) {
    return array;
  }
  // 将给定的列表分为两半
  let num = Math.floor(len / 2);
  let left = MergeSort(array.slice(0, num));
  let right = MergeSort(array.slice(num, array.length));
  return merge(left, right);

  function merge(left, right) {
    let [l, r] = [0, 0];
    let result = [];
    // 从 left 和 right 区域中各个取出第一个元素，比较它们的大小
    while (l < left.length && r < right.length) {
      // 将较小的元素添加到result中，然后从较小元素所在的区域内取出下一个元素，继续进行比较；
      if (left[l] < right[r]) {
        result.push(left[l]);
        l++;
      } else {
        result.push(right[r]);
        r++;
      }
    }
    // 如果 left 或者 right 有一方为空，则直接将另一方的所有元素依次添加到result中
    result = result.concat(left.slice(l, left.length));
    result = result.concat(right.slice(r, right.length));
    return result;
  }
}
```




## 反转链表

```javascript
function reverseLinkList(head) {
  let pre = null
  let cur = head
  while (cur) {
    let next = cur.next
    cur.next = pre
    pre = cur
    cur = next
  }
}

```

## K个一组翻转链表

```javascript
function reverseKGroup(head, k) {
  if(head === null||k===1) return head
  let a,b
  a = b = head
  for (let i = 0; i < k; i++) {
    if(b === null) return head
    b = b.next
  }
  let newHead = reverse(a,b)
  a.next = reverseKGroup(b,k)
  function reverse(a,b){
    let pre = null
    let cur = a
    while(cur!==b){
      let next = cur.next
      cur.next = pre
      pre = cur
      cur = next
    }
    return pre
  }
  return newHead
}
```



## 判断链表是否有环

```javascript
function isRingLinkList(head) {
  let fast = head
  let slow = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}
```

## 二叉树的遍历  

[二叉树的遍历](https://segmentfault.com/a/1190000016226334)

## 二叉树搜索

[二叉树的搜索](http://blog.csdn.net/ZHANGYANG_1109/article/details/123686185)



## 二叉树diff算法



[二叉树diff算法](https://blog.csdn.net/qq_34388186/article/details/145052647)



## 图的最小生成树



[图的最小生成树](https://www.yisu.com/jc/169229.html)

## 斐波那契数列





```javascript
//普通递归
function fib(num) {
  if (num < 2) {
    return num;
  }

  return fib(num - 1) + fib(num - 2);
}
//尾递归

function fib2(n,a = 0,b = 1) {
    if(n === 0) return a;
    if(n === 1 ) return b;
    return fib2(n - 1, b,a+ b)
}
//动态规划

function fib3(n) {
    if( n === 0 || n === 1) return n
    let a = 0,b = 1;
    let temp = 0;
    for(let i = 2; i <= n; i++) {
        temp = a + b;
        a = b;
        b = temp
    }
    return temp;
}

```

## 青蛙跳台阶问题



```javascript
function jumpFloor(number)
{
    if(number === 1){
        return 1
    }
    if(number === 2){
        return 2
    }
    if(number > 2){
        return jumpFloor(number-1)+jumpFloor(number-2)
    }
}
```


## 电话号码组合

```javascript
function letterCombinations(digits) {
  if (!digits) return [];

  const phoneMap = {
    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
  };

  const result = [];

  function backtrack(combination, nextDigits) {
    if (nextDigits.length === 0) {
      result.push(combination);
    } else {
      const digit = nextDigits[0];
      const letters = phoneMap[digit];
      for (let i = 0; i < letters.length; i++) {
        backtrack(combination + letters[i], nextDigits.slice(1));
      }
    }
  }

  backtrack('', digits);
  return result;
}
```

## 字符串所有排列组合

```javascript
function getPermutation(str) {
  const res = []
  const dfs = (path) => {
    if (path.length === str.length) {
      res.push(path)
      return
    }
    for (let i = 0; i < str.length; i++) {
      if (path.includes(str[i])) continue
      dfs(path + str[i])
    }
  }
  dfs('')
  return res
}
```

## 最长回文子串

```javascript
function longestPalindrome(s) {
  if (s.length === 1) return s;
  let maxRes = 0, maxStr = '';
  for (let i = 0; i < s.length; i++) {
    let str1 = palindrome(s, i, i);
    if (str1.length > maxRes) {
      maxStr = str1;
      maxRes = str1.length;
    }
  }
  function palindrome(s, l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      l--;
      r++;
    }
    return s.slice(l + 1, r);
  }
  return maxStr;
}
```

## 版本号排序

```javascript
function versionSort(arr) {
  return arr.sort((a,b)=>{
    const arr1 = a.split('.')
    const arr2 = b.split('.')
    while(arr1.length || arr2.length){
      const a1 = arr1.shift()
      const b1 = arr2.shift()
      if(!a1)return -1
      if(!b1)return 1
      if(a1!==b1){
        return a1 - b1
      }
    }
  })
}
```



## <span id="flat">数组拍平</span>

- Array.prototype.flat(depth)

```javascript
  let newArray = arr.flat(Infinity)
```

- 迭代

```javascript
function flatten(array) {
  const result = [];
  const stack = [array];
  while (stack.length > 0) {
    const item = stack.pop();
    if (Array.isArray(item)) {
      for (let i = item.length - 1; i >= 0; i--) {
        stack.push(item[i]);
      }
    } else {
      result.push(item);
    }
  }
  return result.reverse();
}
```

- 递归

```javascript
function arrayFlat(arr) {
  let result = []
  arr.forEach(item => {
    if (item instanceof Array) {
      result = result.concat(arrayFlat(item))
    } else {
      result.push(item)
    }
  })
  return result
}

function arrayFlat2(arr) {
  return arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? arrayFlat2(cur) : cur), [])
}
```

- 简单情况toString

```javascript
function arrayFlat(arr) {
  return arr.toString().split(',').map(item=>parseInt(item))
}
```

## 有效的括号

给定一个只包括'('，')'，'{'，'}'，'['，']'的字符串s，判断字符串是否有效。

```java
function isValidBrackets(str) {
  const map = new Map([['(', ')'], ['[', ']'], ['{', '}'],])
  const stack = []

  for (let i = 0; i < str.length; i++) {
    if (map.has(str[i])) {
      stack.push(str[i])
    } else if (map.get(stack[stack.length - 1]) === str[i]) {
      stack.pop()
    } else {
      return false
    }
  }
  return stack.length === 0
}
```

## 最长递增子序列

在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。

[最长递增子序列](https://www.bilibili.com/video/BV19M4m1X7Do/?spm_id_from=333.337.search-card.all.click&vd_source=a4e90c849b91dfcaf761cb42efd7e48c)

```javascript
function LIS(nums) {
  if(nums.length === 0) return []
  const results = [[nums[0]]];
  for (let i = 0; i < nums.length; i++) {
    const current = nums[i];
    _update(current)
  }

  function _update(n) {
    for (let i = results.length - 1; i >= 0; i--) {
      const line = results[i];
      const tail = line[line.length - 1];

      if (tail < n) {
        results[i + 1] = [...line, n];
        break
      }else if (n < tail && i === 0) {
        results[0] = [n]
      }
    }
  }
  return results[results.length - 1]
}
```

## 滑动窗口最大值

给定一个长度为n的数组和一个大小为m的滑动窗口(0<m<=n)请找出所有滑动窗口里的最大值。

- 双端队列

```javascript
function maxSlidingWindow(nums, k) {
  let window = [...nums.slice(0,k)]
  let res = []
  for (let i = k; i < nums.length; i++) {
    res.push(Math.max(...window))
    window.shift()
    window.push(nums[i])
  }
  return res
}
```

- 单调队列

```javascript
var maxSlidingWindow2 = function (nums, k) {
  // 边界条件
  if (k > nums.length || k <= 0) return []
  let deque = [], res = []
  for (let i = 0; i < nums.length; i++) {
    // 如果nums[i]比栈尾的数大，则弹出
    while (deque.length && deque[deque.length - 1] < nums[i]) {
      deque.pop()
    }
    // nums[i]入栈
    deque.push(nums[i])
    // 删除离开窗口的元素
    if (deque[0] === nums[i - k]) deque.shift()
    // 推入最大值
    if (i >= k - 1) res.push(deque[0])
  }
  return res
};
```

## 两数之和

给定一个数组 nums 和一个目标值 target，在该数组中找出和为目标值的两个数。

```javascript
function towSum(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j]
      }
    }
  }
}
function towSum2(nums, target) {
    const map = new Map();
    for(let i = 0, len = nums.length; i < len; i++){
        if(map.get(nums[i]) !== undefined){
            return [map.get(nums[i]), i];
        } else {
            map.set(target - nums[i], i);
        }
    }
    return [];
};

```

## 三数之和

给定一个数组nums，判断 nums 中是否存在三个元素`a，b，c`，使得 `a + b + c = target`，找出所有满足条件且不重复的三元组合。

```javascript
function findThree(arr, target) {
  // 先将数组从小到大排序
  arr.sort((a, b) => a - b)
  let result = [];
  for (let i = 0; i < arr.length - 2; i++) {
    // 跳过重复的arr[i]值, 比如[2, 1, 1],跳过第二个1
    if (i && arr[i] === arr[i - 1]) continue;
    let left = i + 1;
    let right = arr.length - 1;

    // 双端指针left、right
    while (left < right) {
      let sum = arr[i] + arr[left] + arr[right];
      if (sum > target) {
        right--;
      } else if (sum < target) {
        left++;
      } else {
        // 先取arr[left]，然后left++, 两步合成一步；arr[right--]同样的逻辑
        result.push([arr[i], arr[left++], arr[right--]]);
        while (arr[left] === arr[left - 1]) {
          // 跳过重复的arr[left]值,
          left++;
        }
        while (arr[right] === arr[right + 1]) {
          // 跳过重复的arr[right]值
          right--;
        }
      }
    }
  }
  return result;
}

```



## 判断输入是不是回文字符串

```javascript
function isPlalindrome(input) {
  if (typeof input !== 'string') return false;
  return input.split('').reverse().join('') === input;
}

function isPlalindrome2(input) {
  if (typeof input !== 'string') return false;
  let i = 0, j = input.length - 1
  while(i < j) {
      if(input.charAt(i) !== input.charAt(j)) return false
      i ++
      j --
  }
  return true
}
```

## 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

```javascript
function bestTimeBuyStock(prices) {
  let minPrice = Infinity
  let maxProfit = 0
  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < minPrice) {
      minPrice = prices[i]
    } else if (prices[i] - minPrice > maxProfit) {
      maxProfit = prices[i] - minPrice
    }
  }
  return maxProfit
}
```

其他版本买股票问题：[买卖股票的最佳时机](https://zhuanlan.zhihu.com/p/136811810)

## 计算多个数组的交集

```javascript
const getIntersection = (...arrs) => {
  return arrs.reduce((pre, cur) => {
    return cur.filter(item => pre.includes(item));
  })
}
```



## 背包问题

- 贪心算法（物品可分割）

假设一个背包可以装 100 kg 物品，我们有如下 5 种豆子，每种豆子的总量和总价值各不相同，为了让背包中所装的物品总价值最大，我们如何选择在背包中装哪些豆子，每种豆子该装多少？

| 物品 | 总量（kg） | 总价值（元） |
| ---- | ---------- | ------------ |
| 黄豆 | 100        | 100          |
| 绿豆 | 30         | 90           |
| 红豆 | 60         | 120          |
| 黑豆 | 20         | 80           |
| 青豆 | 50         | 75           |

先对物品进行价值排序，先装价值高的，装到不能装为止。

```javascript
function knapsack(max, goods) {
  const arr = goods.map(item => {
    item.value = item.price / item.weight
    return item
  })
  let total = 0
  let rest = max
  for (let i = 0; i < arr.length; i++) {
    if (rest >= arr[i].weight) {
      total += arr[i].price
      rest -= arr[i].weight
    }else {
      total += arr[i].value * rest
      break
    }
  }
  return total
}
```

- 动态规划

  [实现动态规划01背包问题](https://blog.csdn.net/qq_38951259/article/details/129386435)

  [01背包问题算法动画讲解](https://www.bilibili.com/video/BV1pY4y1J7na/?spm_id_from=333.337.search-card.all.click&vd_source=a4e90c849b91dfcaf761cb42efd7e48c)

## N皇后问题

[N 皇后经典算法解析](https://juejin.cn/post/6967155502820098085)

## 数组去重


```javascript
function arrayDeduplication(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) { 
        arr.splice(j, 1)
        j--
      }
    }
  }
  return arr
}
```

## 列表转树

```javascript
function listToTree(list) {
  list.forEach(item=>{
    item.children = []
    list.forEach(item2=>{
      if(item2.parentId === item.id){
        item.children.push(item2)
      }
    })
  })
  list = list.filter(item=>item.parentId === 0)
}
```



