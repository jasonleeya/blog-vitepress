[{"title":"\\<!DOCTYPE html> 标签有什么用？","answer":"<p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。</p>\n"},{"title":"HTML5有哪些新特性？","answer":"<ol>\n<li><strong>语义化标签</strong>：\n<ul>\n<li><code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code> 等，替代无意义的 <code>&lt;div&gt;</code>，提升代码可读性和 SEO。</li>\n</ul>\n</li>\n<li><strong>多媒体支持</strong>：\n<ul>\n<li>原生嵌入音视频：<code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 标签，告别 Flash。</li>\n</ul>\n</li>\n<li><strong>表单增强</strong>：\n<ul>\n<li>新输入类型：<code>email</code>、<code>date</code>、<code>number</code>、<code>range</code> 等；</li>\n<li>属性：<code>placeholder</code>（占位符）、<code>required</code>（必填）、<code>autofocus</code>（自动聚焦）。</li>\n</ul>\n</li>\n<li><strong>本地存储</strong>：\n<ul>\n<li><code>localStorage</code> 和 <code>sessionStorage</code>，存储容量更大（约5MB），无需依赖 Cookie。</li>\n</ul>\n</li>\n<li><strong>图形与动画</strong>：\n<ul>\n<li><code>&lt;canvas&gt;</code> 标签：配合 JavaScript 绘制 2D/3D 图形（如图表、游戏）。</li>\n</ul>\n</li>\n<li><strong>通信与性能</strong>：\n<ul>\n<li><strong>WebSocket</strong>：实现客户端与服务器实时双向通信（如聊天室）；</li>\n<li><strong>Web Workers</strong>：后台运行脚本，避免主线程卡顿。</li>\n</ul>\n</li>\n<li><strong>设备交互</strong>：\n<ul>\n<li><strong>Geolocation API</strong>：获取用户地理位置；</li>\n<li><strong>拖放 API</strong>：支持元素拖拽操作（如上传文件）。</li>\n</ul>\n</li>\n<li><strong>离线应用</strong>：\n<ul>\n<li>通过 <code>manifest</code> 文件缓存资源，支持离线访问网页。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"HTML语义化的理解","answer":"<p>HTML语义化是指使用恰当的标签来准确描述内容的结构和含义，而不仅仅依赖div和span。比如用<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code>等标签，能让代码更易读，提升SEO效果，同时增强无障碍访问性，让屏幕阅读器等辅助技术更好地解析页面内容。语义化标签也让代码维护更高效，团队协作更顺畅。</p>\n"},{"title":"块元素和行内元素有什么区别？","answer":"<p>块元素（如<code>div</code>、<code>p</code>）独占一行，默认宽度撑满父容器，可设宽高和边距；</p>\n<p>行内元素（如<code>span</code>、<code>a</code>）不换行，宽度由内容撑开，设置宽高无效，边距仅水平生效。行内块（如<code>img</code>、<code>button</code>）则兼具特性，可设宽高且同行排列。</p>\n"},{"title":"meta viewport 是做什么用的，怎么写？","answer":"<p><code>meta viewport</code> 用于控制移动端视口的尺寸和缩放行为，确保页面适配不同设备。常用写法：</p>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">meta</span><span style=\"color:#B07D48\"> name</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">viewport</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> content</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p>通过 <code>width=device-width</code> 让页面宽度等于设备宽度，<code>user-scalable=no,</code>不允许用户进行缩放<code>initial-scale=1.0</code> 设置初始缩放比例为1，防止自动缩放，<code> maximum-scale=1.0, minimum-scale=1.0&quot;</code>允许用户的最大/小缩放值</p>\n"},{"title":"src和href的区别是什么？","answer":"<p><code>src</code>（源）用于<strong>嵌入资源</strong>到当前文档（如<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>），加载时会阻塞页面解析；<code>href</code>（超链接）用于<strong>关联资源</strong>（如<code>&lt;a&gt;</code>、<code>&lt;link&gt;</code>），建立文档与资源的引用关系，通常异步加载，不影响页面渲染流程。例如：<code>&lt;img src=&quot;image.jpg&quot;&gt;</code>直接嵌入图片，而<code>&lt;a href=&quot;page.html&quot;&gt;</code>仅指向目标链接。</p>\n"},{"title":"HTML中 data- 属性是做什么的？ ","answer":"<p><code>data-</code> 属性用于在 HTML 元素中存储自定义数据，供 JavaScript 或 CSS 访问。例如 <code>data-id=&quot;123&quot;</code>，可通过 <code>element.dataset.id</code> 读取，实现数据与结构的解耦，增强可维护性，同时避免滥用非标准属性。</p>\n"},{"title":"HTML5的离线存储怎么使用，工作原理能不能解释一下？","answer":"<p>HTML5 离线存储通过 <strong><code>manifest</code> 文件</strong>（已废弃）或 <strong>Service Worker</strong> 实现资源缓存，使页面离线可用。</p>\n<ol>\n<li>\n<p><strong>传统方式（Application Cache）</strong>：</p>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">html</span><span style=\"color:#B07D48\"> manifest</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">app.manifest</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><code>app.manifest</code> 列出需缓存的资源，浏览器下载后离线加载。</p>\n</li>\n<li>\n<p><strong>现代方案（Service Worker）</strong>：\n通过 JavaScript 注册 Service Worker，拦截请求并缓存资源到 <code>Cache API</code>，实现精细控制。</p>\n</li>\n</ol>\n<p><strong>原理</strong>：首次访问缓存资源，后续优先从本地加载，同时检测更新。Service Worker 支持动态缓存和离线请求处理，更灵活可靠。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Offline_Service_workers\">通过 Service workers 让 PWA 离线工作</a></p>\n"},{"title":" iframe有那些优缺点","answer":"<p><strong>优点</strong>：</p>\n<ul>\n<li>隔离性：内容/样式/脚本独立（如嵌入第三方页面、微前端）。</li>\n<li>异步加载：提升页面性能（延迟加载非关键内容）。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>SEO差</strong>：内容不易被搜索引擎抓取；</li>\n<li><strong>性能开销</strong>：每个 iframe 是独立文档，增加内存消耗；</li>\n<li><strong>跨域限制</strong>：父子页面通信需 <code>postMessage</code>，操作受限；</li>\n<li><strong>适配问题</strong>：移动端滚动/布局易出 Bug（如高度自适应）。</li>\n</ul>\n"},{"title":"FOUC（无样式内容闪烁）？你如何来避免 FOUC？","answer":"<p>FOUC 是页面加载时短暂出现无样式内容的现象，因 CSS 延迟加载导致。<strong>避免方法</strong>：</p>\n<ol>\n<li>将 CSS 通过 <code>&lt;link&gt;</code> 放在 <code>&lt;head&gt;</code> 中优先加载；</li>\n<li>内联关键 CSS（如首屏样式）；</li>\n<li>避免使用 <code>@import</code> 引入 CSS；</li>\n<li>非关键 CSS 异步加载（如 <code>media=&quot;print&quot;</code> 或 <code>preload</code> 预加载）。</li>\n</ol>\n"},{"title":"img的srcset属性的作⽤","answer":"<p><code>srcset</code> 用于根据设备像素比或视口宽度提供不同分辨率的图片，让浏览器自动选择最合适的加载。例如：</p>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">img</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">default.jpg</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">     srcset</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">small.jpg 320w, medium.jpg 640w, large.jpg 1024w</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">     sizes</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">(max-width: 600px) 100vw, 50vw</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p>通过 <code>w</code>（宽度描述符）和 <code>x</code>（像素密度描述符），结合 <code>sizes</code> 定义的布局尺寸，优化加载性能与显示效果。</p>\n"},{"title":"HTML Web Components是什么？它们包括哪些技术？","answer":"<p>Web Components 是一组 Web 平台 API，允许开发者创建封装性强、可重用的组件，这些组件可以在任何 Web 应用程序中使用。Web Components 主要包括以下四个核心技术：</p>\n<p><strong>1. 自定义元素（Custom Elements）</strong></p>\n<p>允许开发者定义新的 HTML 元素及其行为。这些自定义元素可以像内置元素一样被使用，并且支持生命周期回调函数。</p>\n<p><strong>2. 模板（Templates）</strong></p>\n<p><code>&lt;template&gt;</code> 元素用于定义可以重复使用的 HTML 结构。模板中的内容在被使用时才会被实例化和插入到 DOM 中，从而提高性能和重用性。</p>\n<p><strong>3. Shadow DOM</strong></p>\n<p>允许将组件的内部结构和样式封装在一个独立的 DOM 子树中，这样可以避免样式和脚本的冲突。Shadow DOM 使组件可以有自己的封闭样式和结构。</p>\n<p><strong>4. HTML Imports（已废弃）</strong></p>\n<p>HTML Imports 曾用于引入和使用 HTML 文档的片段，但该技术已被废弃，现代 Web 组件技术通常通过模块化 JavaScript 或 ES6 模块来替代。</p>\n<p><strong>Web Components 的优势</strong></p>\n<ul>\n<li><strong>封装性</strong>：通过 Shadow DOM 隔离组件的样式和结构，避免全局样式和脚本的干扰。</li>\n<li><strong>重用性</strong>：自定义元素可以被多次重用，促进代码的模块化和组织。</li>\n<li><strong>标准化</strong>：作为 Web 标准的一部分，Web Components 与各种 JavaScript 框架和库兼容，能够在不同的环境中使用。</li>\n</ul>\n<p><strong>使用示例</strong></p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#AB5959\">!</span><span style=\"color:#B07D48\">DOCTYPE</span><span style=\"color:#B07D48\"> html</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">html</span><span style=\"color:#B07D48\"> lang</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">en</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">head</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#1E754F\">meta</span><span style=\"color:#B07D48\"> charset</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">UTF-8</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#1E754F\">title</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">Web Components Example</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">title</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#393A34\">        class MyElement extends HTMLElement </span><span style=\"color:#999999\">{</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">            constructor</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">                super</span><span style=\"color:#999999\">()</span><span style=\"color:#393A34\">;</span></span>\n<span class=\"line\"><span style=\"color:#393A34\">                const </span><span style=\"color:#B07D48\">shadow</span><span style=\"color:#999999\"> =</span><span style=\"color:#A65E2B\"> this</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">attachShadow</span><span style=\"color:#999999\">({</span><span style=\"color:#998418\"> mode</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">open</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\"> })</span><span style=\"color:#393A34\">;</span></span>\n<span class=\"line\"><span style=\"color:#393A34\">                shadow.</span><span style=\"color:#B07D48\">innerHTML</span><span style=\"color:#999999\"> =</span><span style=\"color:#B5695977\"> `</span><span style=\"color:#B56959\">&#x3C;style>p { color: red; }&#x3C;/style>&#x3C;p>Hello, Web Components!&#x3C;/p></span><span style=\"color:#B5695977\">`</span><span style=\"color:#393A34\">;</span></span>\n<span class=\"line\"><span style=\"color:#999999\">            }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">        }</span></span>\n<span class=\"line\"><span style=\"color:#393A34\">        customElements.define('my-element', MyElement);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">head</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">body</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#998418\">my-element</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#998418\">my-element</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">body</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">html</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p>在上面的示例中，我们定义了一个自定义元素 <code>&lt;my-element&gt;</code>，它具有一个 Shadow DOM 和一些样式。这个元素可以被插入到任何 HTML 文档中，并且它的样式和结构是封闭的，不会受到外部样式的影响。</p>\n<p><a href=\"https://www.ruanyifeng.com/blog/2019/08/web_components.html\">Web Components 入门实例教程</a></p>\n"},{"title":"如何解决浏览器乱码问题？","answer":"<ul>\n<li>统一编码声明（HTML、服务器、文件存储均用UTF-8）；</li>\n<li>检查HTTP头 <code>Content-Type: text/html; charset=utf-8</code>；</li>\n<li>使用编码转换工具修正文件格式。</li>\n</ul>\n"},{"title":"如何通过 HTML 优化页面加载速度？","answer":"<ol>\n<li><strong>资源懒加载</strong>：图片/iframe 添加 <code>loading=&quot;lazy&quot;</code>，延迟非关键内容加载；</li>\n<li><strong>异步脚本</strong>：使用 <code>async/defer</code> 避免阻塞 DOM 解析；</li>\n<li><strong>预加载关键资源</strong>：<code>&lt;link rel=&quot;preload&quot;&gt;</code> 提前加载字体、CSS 等；</li>\n<li><strong>精简 HTML</strong>：减少 DOM 层级，压缩代码（移除空格/注释）；</li>\n<li><strong>响应式图片</strong>：<code>srcset</code> + <code>sizes</code> 按需适配分辨率，降低资源体积。</li>\n</ol>\n"},{"title":"浏览器是怎么解析 HTML 文档的？","answer":""},{"title":"使用input标签上传图片时，怎样触发默认拍照功能？","answer":""},{"title":"如何禁止input展示输入的历史记录？","answer":""},{"title":"canvas在标签上设置宽高，与在style中设置宽高有什么区别？","answer":"<p>canvas标签的width和height是画布实际宽度和高度，绘制的图形都是在这个上面。</p>\n<p>而style的width和height是canvas在浏览器中被渲染的高度和宽度。</p>\n<p>如果canvas的width和height没指定或值不正确，就被设置成默认值。</p>\n"},{"title":"浏览器是怎么解析 HTML 文档的？","answer":"<p>浏览器解析 HTML 文档的过程是一个复杂的过程，涉及多个阶段，主要分为以下几个步骤：</p>\n<ol>\n<li>\n<p><strong>接收 HTML 文件</strong></p>\n<ul>\n<li>浏览器通过发送 HTTP 请求获取服务器返回的 HTML 文件。该文件可能会包含外部资源（如 CSS、JavaScript、图片等），浏览器会逐步处理这些内容。</li>\n</ul>\n</li>\n<li>\n<p><strong>构建 DOM 树</strong></p>\n<ul>\n<li><strong>词法分析（Tokenization）</strong>：浏览器开始解析 HTML 文档时，将 HTML 源代码拆分为一系列的“标记”或“词法单元”（tokens）。这些标记对应 HTML 标签、属性和文本。</li>\n<li><strong>构建 DOM 树（Document Object Model）</strong>：浏览器根据这些标记构建一个 DOM 树。DOM 树的每个节点代表 HTML 文档的一个元素（如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>）或文本内容，形成一个层次结构。</li>\n<li><strong>节点顺序</strong>：解析 HTML 文档时，浏览器会根据标签的嵌套关系将它们组织成树状结构。例如，<code>&lt;html&gt;</code> 元素是根节点，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 是其子节点，等等。</li>\n</ul>\n</li>\n<li>\n<p><strong>解析 CSS（样式处理）</strong></p>\n<ul>\n<li>在构建 DOM 树的同时，浏览器会遇到 <code>&lt;style&gt;</code> 标签或者外部 CSS 文件的链接（如 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>），浏览器会下载并解析这些 CSS 规则。</li>\n<li>浏览器将 CSS 规则应用到相应的 DOM 节点，生成 <strong>CSSOM 树</strong>（CSS Object Model），它表示页面上所有样式的结构。</li>\n<li>通过将 DOM 树和 CSSOM 树结合，生成 <strong>渲染树</strong>（Render Tree），它包含了页面中所有可见元素的样式信息。</li>\n</ul>\n</li>\n<li>\n<p><strong>生成渲染树</strong></p>\n<ul>\n<li>渲染树由 DOM 树和 CSSOM 树组合而成，包含了页面中所有需要呈现的元素以及它们的样式信息。</li>\n<li>渲染树不包括像 <code>&lt;head&gt;</code> 标签或隐藏元素（例如 <code>display: none</code> 的元素），只有可见的元素和它们的样式才会被包含在内。</li>\n<li>例如，一个 <code>&lt;div&gt;</code> 元素的渲染树节点会包含该 <code>div</code> 的位置、大小、颜色等样式信息。</li>\n</ul>\n</li>\n<li>\n<p><strong>布局（Layout / Reflow）</strong></p>\n<ul>\n<li><strong>布局阶段</strong>：浏览器通过渲染树来确定每个元素的准确位置和大小。浏览器计算每个元素的几何位置，得到每个元素在页面上的精确位置。</li>\n<li>如果布局发生了改变（例如窗口尺寸变化，或者某个元素的尺寸改变），浏览器需要重新计算布局，这个过程叫做 <strong>重排（Reflow）</strong>。</li>\n</ul>\n</li>\n<li>\n<p><strong>绘制（Paint）</strong></p>\n<ul>\n<li><strong>绘制阶段</strong>：浏览器会将布局好的元素按照样式规则渲染到屏幕上，绘制每个元素的颜色、边框、阴影等外观。这个过程称为 <strong>绘制（Paint）</strong>。</li>\n<li>例如，浏览器会绘制元素的背景色、文本、边框等，生成最终的页面显示内容。</li>\n</ul>\n</li>\n<li>\n<p><strong>合成层（Composite）</strong></p>\n<ul>\n<li>在绘制完成后，浏览器可能会将渲染的内容分为多个层。某些元素（如动画、滚动条、固定定位的元素等）可能需要单独的图层。</li>\n<li><strong>合成阶段</strong>：浏览器将这些层合成，最终生成显示在屏幕上的完整页面。</li>\n</ul>\n</li>\n<li>\n<p><strong>执行 JavaScript</strong></p>\n<ul>\n<li>如果页面中有 JavaScript 代码，浏览器会在文档解析过程中执行它。JavaScript 代码通常会在 HTML 中的 <code>&lt;script&gt;</code> 标签内被嵌入或通过外部文件引入。</li>\n<li><strong>影响</strong>：JavaScript 可能会修改 DOM 或 CSSOM，导致重新计算布局（Reflow）或重新绘制（Repaint）。因此，JavaScript 执行的时机和顺序可能会影响页面的渲染性能。</li>\n</ul>\n</li>\n<li>\n<p><strong>事件监听与交互</strong></p>\n<ul>\n<li>一旦页面的初始渲染完成，用户可以与页面进行交互。浏览器会监听用户的输入、鼠标点击、键盘事件等，并相应地触发 JavaScript 代码进行处理。</li>\n</ul>\n</li>\n</ol>\n"}]