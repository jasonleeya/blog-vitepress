[{"title":"谈一谈你对前端框架的理解?","answer":"前端框架（如Vue/React）是**高效构建用户界面**的工具，核心价值在于：\r\n\r\n1. **组件化开发**：\r\n   - 将UI拆分为独立、可复用的组件，提升代码复用性与可维护性。\r\n2. **数据驱动视图**：\r\n   - 通过响应式或虚拟DOM机制，数据变化自动更新视图，减少手动DOM操作。\r\n3. **生态整合**：\r\n   - 提供路由（Vue Router/React Router）、状态管理（Pinia/Redux）、构建工具（Vite/Webpack）等完整开发链路支持。\r\n4. **性能优化**：\r\n   - 虚拟DOM Diff算法、SSR服务端渲染、代码分割等优化手段，提升应用性能。\r\n\r\n**解决的问题**：\r\n\r\n- 传统开发中手动操作DOM的低效与复杂度；\r\n- 大规模应用下代码组织混乱、维护困难；\r\n- 跨团队协作规范不统一。"},{"title":"谈谈对 MVC、MVP、MVVM 模式的理解？","answer":"**1. MVC（Model-View-Controller）**\r\n\r\n- **组成**：\r\n  - **Model**：管理数据和业务逻辑。\r\n  - **View**：负责 UI 展示。\r\n  - **Controller**：接收用户输入，更新 Model，并通知 View 更新。\r\n- **交互**：\r\n  - 用户操作 → **Controller** → 更新 Model → **View** 监听 Model 变化并渲染。\r\n- **特点**：\r\n  - View 可直接访问 Model，导致**双向依赖**（如观察者模式），耦合度较高。\r\n  - 典型应用：传统后端框架（如 Spring MVC）、早期前端框架。\r\n- **问题**：View 和 Model 的强耦合可能导致代码维护困难。\r\n\r\n**2. MVP（Model-View-Presenter）**\r\n\r\n- **组成**：\r\n  - **Model**：同 MVC，管理数据。\r\n  - **View**：被动 UI，仅定义界面结构和触发事件。\r\n  - **Presenter**：中介者，处理业务逻辑，更新 Model 并控制 View。\r\n- **交互**：\r\n  - 用户操作 → **View** → 通知 Presenter → 更新 Model → Presenter 更新 View。\r\n- **特点**：\r\n  - **View 与 Model 完全解耦**，所有逻辑集中在 Presenter。\r\n  - 更易测试（Mock View 即可测试 Presenter）。\r\n  - 典型应用：桌面应用（如 Android 早期开发）。\r\n- **问题**：Presenter 可能变得臃肿，需手动同步 View 和 Model。\r\n\r\n**3. MVVM（Model-View-ViewModel）**\r\n\r\n- **组成**：\r\n  - **Model**：数据层。\r\n  - **View**：UI 展示。\r\n  - **ViewModel**：通过数据绑定（Data Binding）连接 View 和 Model，暴露命令和状态。\r\n- **交互**：\r\n  - **双向绑定**：View 的输入自动更新 ViewModel，ViewModel 变化自动同步到 View。\r\n  - **数据驱动**：Model 变化 → ViewModel 更新 → View 自动渲染（如 Vue/React）。\r\n- **特点**：\r\n  - **低耦合**：View 不直接操作 Model，通过 ViewModel 代理。\r\n  - **高效开发**：减少手动 DOM 操作（如 Vue 的 `v-model`）。\r\n  - 典型应用：现代前端框架（Vue.js、React + MobX）。\r\n- **问题**：过度依赖数据绑定可能导致调试困难或性能问题（如大型列表渲染）。\r\n\r\n**对比总结**\r\n\r\n| 模式     | 核心思想                             | 通信方式                             | 适用场景                        |\r\n| :------- | :----------------------------------- | :----------------------------------- | :------------------------------ |\r\n| **MVC**  | 分层解耦，View 直接依赖 Model        | 多向通信（可能循环依赖）             | 传统后端、简单前端应用          |\r\n| **MVP**  | Presenter 解耦 View 和 Model         | 单向通信（View ↔ Presenter ↔ Model） | 桌面应用、需要高测试性的场景    |\r\n| **MVVM** | 数据绑定自动同步，ViewModel 代理逻辑 | 双向绑定（View ↔ ViewModel ↔ Model） | 现代前端框架（如 Vue、Angular） |"},{"title":"说说你对SPA（单页应用）的理解?","answer":"SPA（单页应用）是指**通过前端路由动态渲染内容**的 Web 应用，其核心特点是：\r\n\r\n1. **单次加载**：首次访问加载完整 HTML、CSS 和 JS，后续页面切换通过 AJAX/API 获取数据，客户端动态更新 DOM，无需整页刷新。\r\n2. **前端路由**：利用 `history API` 或 `hash` 实现 URL 变化与视图匹配，保持用户体验流畅性（如 Vue Router、React Router）。\r\n3. **优点**：\r\n   - 交互流畅，接近原生应用体验；\r\n   - 减轻服务器压力，前后端分离开发；\r\n   - 支持复杂状态管理（如 Redux、Pinia）。\r\n4. **挑战**：\r\n   - **SEO 不友好**：传统爬虫难以抓取动态内容（可通过 SSR/SSG 优化）；\r\n   - **首屏性能**：资源加载较慢（需代码分割、懒加载优化）；\r\n   - **内存管理**：长期运行需警惕内存泄漏。"},{"title":"SPA（单页应用）首屏加载速度慢怎么解决？","answer":"1. **代码分割 + 懒加载**：\r\n   - 用`import()`动态导入路由组件（Vue Router的`component: () => import('...')`），按需加载。\r\n   - 使用Webpack的`SplitChunksPlugin`拆分公共代码和第三方库（如Vue、Vuex）。\r\n2. **资源优化**：\r\n   - 压缩JS/CSS（Terser、CSSNano）、图片转WebP/AVIF格式或用懒加载。\r\n   - 开启Gzip/Brotli压缩（服务器配置）。\r\n3. **预渲染（Prerender）或SSR**：\r\n   - 对静态页面用`prerender-spa-plugin`预生成HTML，直接返回给用户。\r\n   - 复杂场景用服务端渲染（如Nuxt.js），首屏直出HTML。\r\n4. **CDN加速静态资源**：\r\n   - 将第三方库（如Vue、lodash）通过CDN引入，减少打包体积。\r\n5. **优化首屏关键资源**：\r\n   - 内联关键CSS，异步加载非必要JS（如`async`/`defer`）。\r\n   - 使用骨架屏（Skeleton）过渡，提升用户体验。\r\n6. **缓存策略**：\r\n   - 强缓存（Cache-Control）、协商缓存（ETag）减少重复请求。\r\n   - Service Worker做离线缓存（PWA）。\r\n\r\n**工具辅助**：用Lighthouse分析性能瓶颈，针对性优化。"},{"title":"常⻅兼容性问题","answer":"[前端开发中常见的浏览器兼容性问题及解决方案大汇总](https://juejin.cn/post/7067808335034220574)"},{"title":"HTML中的attribute属性和JavaScript中的property属性的详解以及区别","answer":"**attribute**：是HTML标签上的某个属性，如id、class、value等以及自定义属性，它的值只能是字符串，关于这个属性一共有三个相关的方法，setAttribute、getAttribute、removeAttribute；\r\n**property**：是js获取的DOM对象上的属性值，比如a，你可以将它看作为一个基本的js对象。这个节点包括很多property，比如value，className以及一些方法onclik等方法。\r\n\r\n**注意**：在使用setAttribute的时候，该函数一定接收两个参数，setAttribute（attributeName,value）,无论value的值是什么类型都会编译为字符串类型。在html标签中添加属性，本质上是跟在标签里面写属性时一样的，所以属性值最终都会编译为字符串类型。"},{"title":"HTML中的attribute属性和JavaScript中的property属性区别","answer":"- **Attribute**：\r\n  - **HTML 标签上的属性**，定义在 HTML 中（如 `<input id=\"name\" value=\"初始值\">`）。\r\n  - 通过 `setAttribute()`/`getAttribute()` 操作，**始终返回字符串**。\r\n- **Property**：\r\n  - **DOM 对象（如元素节点）的属性**，是 JavaScript 内存中的值。\r\n  - 通过 `element.propertyName` 直接访问（如 `input.value`），**类型多样**（布尔、数字、对象等）。"},{"title":"常见的 web 前端网络攻击有哪些？","answer":"**1. XSS（跨站脚本攻击）**\r\n\r\n- **原理**：攻击者注入恶意脚本到页面中，窃取用户数据（如 Cookie）。\r\n- **类型**：存储型、反射型、DOM 型。\r\n- **防御**：\r\n  - 输入内容转义（如 `&` → `&`）。\r\n  - 使用 CSP（内容安全策略）限制脚本来源。\r\n  - 避免 `innerHTML`，优先用 `textContent`。\r\n\r\n**2. CSRF（跨站请求伪造）**\r\n\r\n- **原理**：诱导用户发起非预期的请求（如修改密码）。\r\n- **防御**：\r\n  - 关键操作校验 `Referer` 或 `Origin` 头。\r\n  - 请求添加 CSRF Token（服务端生成并验证）。\r\n  - Cookie 设置 `SameSite=Strict/Lax`。\r\n\r\n**3. 点击劫持（Clickjacking）**\r\n\r\n- **原理**：通过透明 iframe 覆盖诱骗用户点击隐藏按钮。\r\n- **防御**：\r\n  - HTTP 头设置 `X-Frame-Options: DENY/SAMEORIGIN`。\r\n  - 前端 JS 判断 `self === top` 防止嵌套。\r\n\r\n**4. 中间人攻击（MITM）**\r\n\r\n- **原理**：劫持通信链路窃取或篡改数据。\r\n- **防御**：\r\n  - 全站启用 HTTPS（HTTP/2 + HSTS 强制跳转）。\r\n  - 避免混合内容（HTTP 与 HTTPS 混用）。\r\n\r\n**5. CORS 配置错误**\r\n\r\n- **原理**：不当的跨域策略导致敏感数据泄露。\r\n- **防御**：\r\n  - 服务端严格设置 `Access-Control-Allow-Origin`（避免 `*`）。\r\n  - 限制预检请求（`OPTIONS`）的响应头范围。\r\n\r\n**6. DDoS（CC 攻击）**\r\n\r\n- **原理**：高频请求耗尽服务器资源。\r\n- **防御**：\r\n  - 前端添加验证码或行为验证（如滑动拼图）。\r\n  - 服务端限流（IP 频率限制）。\r\n\r\n7. 恶意文件上传**\r\n\r\n- **原理**：上传可执行文件（如 `.php`）到服务器。\r\n- **防御**：\r\n  - 前端限制文件类型（白名单校验）。\r\n  - 服务端重命名文件并扫描内容。\r\n\r\n**8. DNS 劫持**\r\n\r\n- **原理**：篡改 DNS 解析结果导向恶意站点。\r\n- **防御**：\r\n  - 使用 HTTPS 加密通信。\r\n  - 启用 DNS over HTTPS（DoH）。"},{"title":"什么是虚拟DOM?其优点有哪些？","answer":"虚拟 DOM（Virtual DOM）是一种**用 JavaScript 对象模拟真实 DOM 结构的中间层**，常见于 React、Vue 等框架，其核心原理与优点如下：\r\n\r\n**一、虚拟 DOM 的核心原理**\r\n\r\n1. **结构映射**：将真实 DOM 抽象为轻量的 JS 对象（如 `{ type: 'div', props: { className: 'box' }, children: [...] }`）。\r\n2. **差异比对（Diff）**：状态变化时生成新虚拟 DOM，与旧版本对比，找出最小变更（差异）。\r\n3. **批量更新**：将差异一次性应用到真实 DOM，减少直接操作次数。\r\n\r\n**二、虚拟 DOM 的核心优点**\r\n\r\n1. **性能优化**\r\n   - **减少直接 DOM 操作**：真实 DOM 操作（如修改 `innerHTML`）会触发重排/重绘，成本高昂。\r\n   - **批量更新与合并**：通过差异比对避免频繁的 DOM 修改，降低渲染开销。\r\n2. **跨平台能力**\r\n   - **抽象渲染逻辑**：虚拟 DOM 可对接不同平台（浏览器 DOM、移动端原生组件、Canvas 等），如 React Native。\r\n3. **开发体验提升**\r\n   - **声明式编程**：开发者关注数据与 UI 的关系，而非手动操作 DOM（如 `document.getElementById`）。\r\n   - **自动优化**：框架处理底层 DOM 更新，简化复杂 UI 的维护。\r\n4. **高效的 Diff 算法**\r\n   - **同级对比**：React 等框架采用分层对比策略，时间复杂度从 O(n³) 优化至 O(n)。\r\n   - **Key 值优化**：通过 `key` 标识元素，减少不必要的节点销毁与重建。\r\n\r\n**三、虚拟 DOM 的适用场景**\r\n\r\n- **动态复杂 UI**：频繁交互的页面（如数据看板、编辑器）。\r\n- **跨平台应用**：一套代码适配多端渲染。\r\n- **框架级优化**：与状态管理、组件化结合，构建高效应用。\r\n\r\n**四、与传统直接操作 DOM 的对比**\r\n\r\n| **场景**     | **直接操作 DOM**   | **虚拟 DOM**                 |\r\n| :----------- | :----------------- | :--------------------------- |\r\n| **简单更新** | 更快（无中间层）   | 略慢（需生成和对比虚拟 DOM） |\r\n| **复杂更新** | 性能差（频繁重排） | 性能优（批量更新）           |\r\n| **开发效率** | 低（手动更新）     | 高（声明式编程）             |\r\n\r\n**总结**\r\n\r\n虚拟 DOM 通过 **JS 对象抽象** 和 **差异比对机制**，在复杂场景下显著提升性能与开发效率，是现代前端框架的核心设计之一。其价值并非绝对性能最优，而是在开发体验与渲染效率之间找到最佳平衡。"},{"title":"DOM树和渲染树有什么区别？","answer":"DOM 树和渲染树（Render Tree）的核心区别在于**作用范围和节点过滤**：\r\n\r\n1. **节点范围**：\r\n   - **DOM 树**：包含 HTML 文档所有节点（包括隐藏元素如 `display: none` 或 `<script>`）。\r\n   - **渲染树**：仅包含**可见节点**（如 `display: none` 的元素会被排除）。\r\n2. **构建依据**：\r\n   - DOM 树由 HTML 解析直接生成，反映文档结构。\r\n   - 渲染树由 DOM 树 + CSSOM（CSS 样式规则）组合生成，决定实际渲染内容。\r\n3. **节点对应关系**：\r\n   - DOM 节点与渲染树节点不一定一一对应（如 `visibility: hidden` 的元素仍占用渲染树空间）。\r\n4. **核心作用**：\r\n   - DOM 树提供文档结构操作能力（如 JS 增删节点）。\r\n   - 渲染树驱动浏览器布局（Layout）和绘制（Paint），直接影响页面渲染性能。\r\n\r\n**示例**：\r\n\r\n- `<div style=\"display: none\">` 会出现在 DOM 树中，但不会进入渲染树。\r\n- `<span>Hello</span>` 在渲染树中可能被合并到父级文本块中。"},{"title":"Vue与React的区别，分别在哪些场景下使用更合适？","answer":"一、核心区别\r\n\r\n1. **数据绑定与响应式机制**\r\n\r\n- **Vue**：采用**双向数据绑定**（如`v-model`），通过`getter/setter`劫持数据变化，自动追踪依赖并更新视图，简化了表单交互开发137。\r\n- **React**：坚持**单向数据流**，需通过`setState`显式更新状态，依赖虚拟DOM的`diff`算法优化渲染性能，强调数据的不可变性169。\r\n\r\n2. **模板与语法**\r\n\r\n- **Vue**：使用基于HTML的模板语法（如`v-if`、`v-for`），逻辑与视图分离更直观，适合偏好声明式开发的团队268。\r\n- **React**：完全依赖**JSX**（JavaScript XML），将HTML与JavaScript混合编写，提供更高的灵活性，适合函数式编程爱好者6910。\r\n\r\n3. **组件通信与复用**\r\n\r\n- **Vue**：通过`props`传递数据、`$emit`触发事件，支持`provide/inject`跨层级通信；逻辑复用多依赖`mixins`或`Composition API`17。\r\n- **React**：父组件通过`props`传递回调函数，跨层级通信使用`Context API`；逻辑复用通过**HOC（高阶组件）**或**Hooks**实现159。\r\n\r\n4. **状态管理**\r\n\r\n- **Vue**：内置**Vuex/Pinia**，支持直接修改状态，深度集成响应式系统，开发体验更简洁179。\r\n- **React**：依赖第三方库如**Redux/MobX**，强调不可变数据与纯函数，需通过`dispatch`触发状态变更，适合复杂状态流156。\r\n\r\n5. **生态系统与工具链**\r\n\r\n- **Vue**：官方提供全家桶（Vue Router、Vuex、Vite），适合快速搭建轻量级应用；中文文档友好，学习曲线平缓3610。\r\n- **React**：社区生态庞大（如Next.js、React Native），工具链灵活但需自行选型；适合企业级应用与跨平台开发5610。\r\n\r\n二、适用场景\r\n\r\n1. **选择Vue的场景**\r\n\r\n- **中小型项目**：快速原型开发、表单密集型应用（如后台管理系统），Vue的响应式系统能显著减少手动编码量368。\r\n- **团队新手较多**：模板语法直观，文档详尽，适合传统Web开发者快速上手610。\r\n- **渐进式集成**：需逐步替换旧项目（如jQuery），通过CDN引入局部功能升级510。\r\n\r\n2. **选择React的场景**\r\n\r\n- **大型复杂应用**：如社交平台、实时协作工具，React的单向数据流与虚拟DOM优化更易维护高性能动态界面569。\r\n- **跨平台开发**：借助**React Native**实现iOS/Android代码复用，适用于需原生性能的移动端项目510。\r\n- **强类型与测试需求**：结合TypeScript，提升代码健壮性；生命周期管理严格，适合微前端架构569。\r\n\r\n3. **其他考量因素**\r\n\r\n- **团队经验**：熟悉函数式编程选React，偏好HTML模板选Vue610。\r\n- **长期维护性**：React的不可变数据与TypeScript支持降低重构风险；Vue的渐进式升级路径更明确（如Vue2→3平滑迁移）59。"},{"title":"<span id=\"browser\">从浏览器输入url后都经历了什么</span>","answer":"- 通过DNS解析获得网址的对应IP地址 \r\n\r\n- 浏览器与远程web服务器 通过TCP三次握手协商来建立一个 TCP/IP 连接 \r\n\r\n- 浏览器 通过TCP/IP连接 向web服务器 发送一个 HTTP 请求 \r\n\r\n- 服务器的永久重定向响应 \r\n\r\n- 浏览器跟踪重定向地址 \r\n\r\n- 服务器处理请求 \r\n\r\n- 服务器返回一个 HTTP 响应 \r\n\r\n- 浏览器渲染:解析HTML、解析CSS、解析JS、Render树"},{"title":"<span id=\"reflow-and-repaint\">回流和重绘有什么区别？</span>","answer":"**1. 触发原因**\r\n\r\n- **回流（Reflow）**：当元素的**几何属性或布局发生变化**（如宽高、位置、字体大小、窗口缩放等），浏览器需重新计算元素的几何信息并更新布局树。\r\n- **重绘（Repaint）**：当元素的**样式变化但不影响布局**（如颜色、背景、透明度等），浏览器只需重新绘制受影响区域。\r\n\r\n**2. 性能影响**\r\n\r\n- **回流比重绘代价更高**：回流会导致子元素及后续元素的连锁重新计算（“布局抖动”），而重绘仅涉及像素更新。\r\n- **回流必定触发重绘**：布局变化后必然需要重新绘制，但重绘不一定触发回流。\r\n\r\n**3. 常见触发场景**\r\n\r\n- **回流**：\r\n  - 修改元素的尺寸、位置、边距（如 `width`、`margin`、`position`）。\r\n  - 增删可见 DOM 元素。\r\n  - 读取某些属性（如 `offsetTop`、`scrollHeight`）会强制同步回流。\r\n- **重绘**：\r\n  - 修改颜色（`color`）、背景（`background`）、阴影（`box-shadow`）。\r\n  - 隐藏元素但保留布局（如 `visibility: hidden`）。\r\n\r\n**优化策略**\r\n\r\n1. **减少回流次数**：\r\n   - 使用 `transform` 或 `opacity` 代替直接修改 `top/left`（触发 GPU 加速，跳过回流）。\r\n   - 避免逐行修改样式，通过 `class` 或 `cssText` 批量更新。\r\n   - 使用 `DocumentFragment` 批量操作 DOM。\r\n2. **避免强制同步布局**：\r\n   - 避免在循环中频繁读取布局属性（如 `offsetWidth`），会强制浏览器立即回流。"},{"title":"你知道哪些性能优化手段？","answer":"**一、网络请求优化**\r\n\r\n1. **减少请求次数**\r\n   - 合并资源（CSS/JS 文件、雪碧图）。\r\n   - 使用 HTTP/2 多路复用降低队头阻塞。\r\n2. **资源压缩与缓存**\r\n   - 开启 Gzip/Brotli 压缩。\r\n   - 强缓存（`Cache-Control`）与协商缓存（`ETag`）合理配置。\r\n3. **CDN 加速**：静态资源分发至边缘节点，减少传输延迟。\r\n\r\n**二、资源加载优化**\r\n\r\n1. **按需加载**\r\n   - 路由懒加载（React.lazy + Suspense）。\r\n   - 图片懒加载（`loading=\"lazy\"` 或 IntersectionObserver）。\r\n2. **预加载关键资源**\r\n   - `<link rel=\"preload\">` 提前加载字体、核心 JS/CSS。\r\n   - 异步脚本（`async/defer`）避免阻塞渲染。\r\n3. **资源体积优化**\r\n   - 代码分包（Webpack SplitChunks）。\r\n   - 图片格式优化（WebP/AVIF）、响应式图片（`srcset`）。\r\n\r\n**三、渲染性能优化**\r\n\r\n1. **减少重排与重绘**\r\n   - 避免频繁操作样式，使用 `transform/opacity` 触发 GPU 加速。\r\n   - 批量 DOM 更新（DocumentFragment）。\r\n2. **优化长列表**\r\n   - 虚拟滚动（React Virtualized、Vue Virtual Scroller）。\r\n3. **避免强制同步布局**\r\n   - 分离读写操作（如先读取布局属性，再统一修改）。\r\n\r\n**四、代码执行优化**\r\n\r\n1. **减少主线程阻塞**\r\n   - 长任务拆分（Web Workers）。\r\n   - 防抖/节流（resize、scroll 事件）。\r\n2. **内存管理**\r\n   - 及时解绑事件监听、清除定时器。\r\n   - 避免内存泄漏（闭包、全局变量滥用）。\r\n3. **Tree Shaking**：删除未使用代码（ES Module 静态分析）。\r\n\r\n**五、其他关键优化**\r\n\r\n1. **SSR/SSG**：服务端渲染（如 Next.js）提升首屏速度。\r\n2. **Web Vitals 指标优化**\r\n   - LCP：优先加载关键资源，优化图片/字体。\r\n   - FID：减少主线程长任务，延迟非关键 JS。\r\n   - CLS：预留图片/广告位尺寸，避免布局偏移。\r\n3. **性能监控**\r\n   - Lighthouse 评分分析。\r\n   - 埋点上报（FP/FCP/LCP 等关键指标）。\r\n\r\n**总结**\r\n\r\n性能优化需结合具体场景，核心思路是 **减少负载、加速渲染、避免阻塞**。通过工具分析瓶颈（如 Chrome DevTools Performance 面板），渐进式优化并持续监控。"},{"title":"前端动画有哪些实现方式？","answer":"1. **CSS动画**：使用 `transition` 和 `@keyframes` 实现简单动画，性能优化好，适合交互动效（如悬停、加载）。\r\n2. **JavaScript动画库**：如 **GSAP**、Anime.js，适合复杂动画（时间轴、路径动画），控制精细。\r\n3. **SVG动画**：通过 `<animate>` 标签或操作DOM属性，适合矢量图形动画（如图标变形）。\r\n4. **Canvas/WebGL**：用 **Canvas API** 或 **Three.js** 实现高性能动画（游戏、数据可视化）。\r\n5. **框架内置动画**：如 Vue 的 `<Transition>` 组件、React 的 **React Spring**，与框架深度集成。\r\n6. **Web Animations API**：原生JS API，融合CSS和JS动画能力，可控性强。"},{"title":"Canvas 和 SVG 的区别","answer":"Canvas 是**位图**，通过 JavaScript 动态绘制，适合高频渲染（如动画、游戏），但元素不可单独操作；\r\n\r\nSVG 是**矢量图**，基于 XML 描述图形，支持缩放无损、DOM 事件绑定，适合静态或交互复杂图形（如图标、图表）。Canvas 性能更高，SVG 更易维护和交互。"},{"title":"如何判断用户设备？","answer":"1. 使用 navigator.userAgent（用户代理字符串）\r\n2. 使用 CSS 媒体查询\r\n3. js判断视口宽度\r\n4. 第三方库（mobile-detect.js等）"},{"title":"你知道哪些自适应的方案？","answer":"1. **媒体查询（Media Queries）**\r\n   通过CSS `@media` 根据屏幕尺寸适配不同样式，如断点布局（Bootstrap栅格系统）。\r\n2. **弹性布局（Flexbox/Grid）**\r\n   使用 `Flexbox` 或 `CSS Grid` 实现弹性容器，自动适应不同屏幕尺寸。\r\n3. **百分比/视口单位（vw/vh）**\r\n   用 `%`、`vw`（视口宽度单位）或 `vh`（视口高度单位）动态调整元素尺寸。\r\n4. **Rem适配方案**\r\n   结合 `rem`（根元素字体大小）和 `JavaScript` 动态计算根字体（如根据屏幕宽度设置 `1rem = 屏幕宽度的1/10`）。\r\n5. **响应式图片**\r\n   使用 `<picture>` 标签或 `srcset` 属性适配不同分辨率，结合 `max-width: 100%` 防止图片溢出。"},{"title":" 前端需要注意哪些SEO","answer":"1. **语义化 HTML**\r\n   合理使用 `<h1>`~`<h6>`、`<header>`、`<nav>`、`<article>` 等标签，增强内容可读性。\r\n2. **标题与 Meta 标签**\r\n   确保每个页面有唯一的 `<title>` 和 `meta description`，准确描述页面内容。\r\n3. **图片优化**\r\n   添加 `alt` 属性，压缩图片体积（WebP格式），使用 `srcset` 适配不同分辨率。\r\n4. **友好的 URL 结构**\r\n   采用静态路径（如 `/blog/seo-tips`），避免 `#` 路由或动态参数混乱。\r\n5. **移动端适配**\r\n   响应式设计 + `viewport` 配置，确保移动端体验良好（影响 Google 排名）。\r\n6. **性能优化**\r\n   压缩资源、减少渲染阻塞（如懒加载）、提升加载速度（Lighthouse 评分）。\r\n7. **避免纯 SPA 问题**\r\n   单页应用（如 React/Vue）需结合 SSR（服务端渲染）或预渲染，保证爬虫抓取内容。\r\n8. **结构化数据（Schema）**\r\n   使用 JSON-LD 标记关键信息（如产品价格、评分），提升搜索富片段展示。\r\n9. **外链与内链优化**\r\n   合理设置 `<a>` 标签的 `href`，避免死链，利用 `rel=\"nofollow\"` 控制权重。\r\n10. **Sitemap 与 robots.txt**\r\n    提交 XML 站点地图，配置爬虫抓取规则。"},{"title":"cookie 和 session有什么区别","answer":"1. **存储位置**\r\n   - Cookie：数据存储在**客户端**（浏览器），通过请求头自动传递。\r\n   - Session：数据存储在**服务端**，客户端仅保存 Session ID（通常通过 Cookie 存储）。\r\n2. **安全性**\r\n   - Cookie：易被篡改或窃取（需配合 `HttpOnly`、`Secure` 等属性提升安全性）。\r\n   - Session：敏感数据存于服务端，仅暴露 ID，安全性更高。\r\n3. **存储大小限制**\r\n   - Cookie：单域名下通常限制为 **4KB** 左右。\r\n   - Session：服务端存储，理论无严格大小限制。\r\n4. **生命周期**\r\n   - Cookie：可设置过期时间（如 `Expires` 或 `Max-Age`），支持长期保存。\r\n   - Session：依赖服务端配置，通常浏览器关闭即失效（或服务端主动清理）。"},{"title":"懒加载和预加载有什么区别？","answer":"1. **加载时机**\r\n   - **懒加载**：延迟加载非关键资源（如图片、组件），当用户即将需要时（如滚动到视口）触发。\r\n   - **预加载**：提前加载后续可能需要的资源（如下一页内容），在空闲时间或用户操作前完成。\r\n2. **核心目的**\r\n   - **懒加载**：优化首屏加载速度，减少初始请求压力。\r\n   - **预加载**：提升后续操作的流畅性，减少用户等待时间。\r\n3. **典型场景**\r\n   - **懒加载**：长列表、图库、非首屏内容。\r\n   - **预加载**：幻灯片切换、关键功能模块、预测用户下一步行为。\r\n4. **实现方式**\r\n   - **懒加载**：通过 `Intersection Observer` 监听元素可见性，或动态 `import()` 异步加载组件。\r\n   - **预加载**：使用 `<link rel=\"preload\">` 或 `fetch()` 提前请求资源。"},{"title":"为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？","answer":"**使用 1x1 像素透明 GIF 图片发送埋点请求的核心原因**：\r\n\r\n1. **无跨域限制**：\r\n   `<img>` 标签天然支持跨域请求，无需 CORS 配置，避免浏览器拦截。\r\n2. **性能损耗低**：\r\n   1x1 透明 GIF 体积极小（约 43B），传输快且不占用额外资源，对页面性能影响最小。\r\n3. **兼容性强**：\r\n   所有浏览器均支持 GIF 格式，且图片加载无阻塞问题（相比脚本或 AJAX）。\r\n4. **无副作用**：\r\n   透明图片不会干扰页面展示，无需处理内容返回（服务器只需响应 204/200 状态码）。\r\n5. **数据传参灵活**：\r\n   通过 URL 的 query 参数携带埋点数据（如 `?event=click&user=123`），服务端解析日志即可。"},{"title":"简述一下 PWA","answer":"**PWA（渐进式网络应用）的核心要点**：\r\n\r\n1. **核心能力**：\r\n   - **离线可用**：通过 `Service Worker` 缓存资源，实现弱网或无网访问。\r\n   - **类原生体验**：支持添加到主屏幕、全屏模式、推送通知（Push API）。\r\n2. **关键技术**：\r\n   - **Service Worker**：后台脚本管理缓存与网络代理。\r\n   - **Web App Manifest**：定义应用图标、启动页等元数据（`manifest.json`）。\r\n   - **HTTPS 强制**：确保通信安全。\r\n3. **核心优势**：\r\n   - **响应式设计**：适配多端（PC/移动）。\r\n   - **低流量消耗**：优先加载缓存资源。\r\n   - **无安装依赖**：通过浏览器访问，支持渐进增强（逐步支持高级功能）。"},{"title":"前端埋点有哪些方案？","answer":"1. **代码埋点（手动埋点）**\r\n   在代码中插入上报逻辑（如点击/曝光事件），灵活但维护成本高。\r\n2. **可视化埋点**\r\n   通过工具（如GrowingIO）配置事件，无代码侵入，适合非技术人员操作。\r\n3. **无埋点（全埋点）**\r\n   自动采集全量用户行为（如点击、页面停留），通过后端过滤分析，数据全但处理复杂。\r\n4. **服务端埋点**\r\n   由后端记录日志（如API请求），避免客户端数据丢失，但无法捕获前端交互细节。\r\n5. **基于Image/Beacon的请求**\r\n   使用 `new Image().src` 或 `navigator.sendBeacon()` 发送数据，避免阻塞页面。"},{"title":"简述一下 WebAssembly","answer":"1. **定位**：\r\n   - 一种**二进制指令格式**，能在浏览器中高性能执行（接近原生速度），与JS互补，非替代。\r\n2. **核心能力**：\r\n   - **高性能计算**：适用于图形渲染、游戏、加密等CPU密集型任务。\r\n   - **跨语言支持**：C/C++/Rust等语言可编译成Wasm，复用现有生态。\r\n   - **沙箱安全**：运行在隔离内存环境中，避免恶意代码攻击。\r\n3. **应用场景**：\r\n   - 浏览器内高性能应用（如FFmpeg视频解码）。\r\n   - 跨平台应用（结合Web/桌面/移动端）。\r\n   - 模块化加速（如JS性能瓶颈的数学计算）。"},{"title":"如何给自己团队的大型前端项目设计单元测试？","answer":"1. **选型与分层**\r\n   - **框架**：选主流工具（如Jest+Vue Test Utils/React Testing Library），确保生态支持。\r\n   - **分层策略**：按模块拆分（Utils → Components → Hooks → API层），优先覆盖核心逻辑与公共模块。\r\n2. **覆盖率与规范**\r\n   - **阈值设定**：核心代码覆盖率不低于80%（如业务Utils），UI组件可放宽。\r\n   - **Mock策略**：用`jest.mock`隔离API、第三方库，避免真实网络请求。\r\n3. **组件测试重点**\r\n   - **渲染校验**：验证Props传递与条件渲染（如`toBeInTheDocument`）。\r\n   - **交互测试**：模拟用户操作（点击/输入），断言状态或事件触发正确性。\r\n4. **工程化集成**\r\n   - **Husky + Lint**：提交代码前自动跑测试，拦截失败用例。\r\n   - **CI流水线**：集成到Jenkins/GitHub Actions，生成可视化报告（如Jest HTML Reporter）。\r\n5. **维护与优化**\r\n   - **快照测试**：监控UI意外变更（慎用，避免频繁失效）。\r\n   - **测试可读性**：用例命名清晰（`describe`场景，`it`预期结果），定期Review冗余用例。"},{"title":"ECharts是什么？能够用来做什么？","answer":"`ECharts`（百度开源的**可视化图表库**）是一个基于`JavaScript`的开源可视化图表库，可以用来创建丰富、交互式的数据可视化图表。\r\n\r\n`ECharts`能够用来展示各种类型的图表，包括**折线图、柱状图、条形图、散点图、饼图、雷达图、地图**等。它支持动态更新数据，通过交互操作，可以实现数据的**筛选、排序、缩放**等功能。\r\n\r\n`ECharts`提供了丰富的配置项和API，使开发者可以根据自己的需求灵活定制图表的样式和行为，同时还支持多种数据格式的导入和导出。它适用于各类**数据分析、数据可视化、大屏展示**等场景，可以帮助用户更直观地理解和分析数据，从而做出更好的决策。"},{"title":"如何提高前端代码的可维护性和可拓展性？","answer":"1. **模块化与组件化**\r\n   - 按功能拆分独立模块/组件，遵循**单一职责原则**（如UI与逻辑分离），降低耦合度。\r\n2. **统一代码规范**\r\n   - 使用ESLint+Prettier强制代码风格，制定命名规则（如`动词+名词`函数名），增强可读性。\r\n3. **类型系统**\r\n   - 引入TypeScript，明确接口类型与数据结构，减少隐式错误，提升重构信心。\r\n4. **设计模式应用**\r\n   - 常用模式：工厂模式（创建对象）、策略模式（算法替换）、观察者模式（事件通信），提升扩展性。\r\n5. **文档与注释**\r\n   - 关键逻辑添加注释，维护组件API文档（如Storybook），降低新人上手成本。\r\n6. **自动化测试**\r\n   - 核心逻辑覆盖单元测试（Jest），复杂交互补充E2E测试（Cypress），保障迭代安全。\r\n7. **状态管理规范**\r\n   - 使用Redux/Pinia集中管理全局状态，避免Props多层透传，逻辑更易追踪。\r\n8. **工程化工具链**\r\n   - 配置Alias简化导入路径，利用Webpack/Vite实现按需加载，优化构建流程。"},{"title":"列举一些常见的content-type","answer":"1. **`application/json`**：JSON 数据交互，如 REST API 请求/响应。\r\n2. **`multipart/form-data`**：表单文件上传（支持二进制数据）。\r\n3. **`application/x-www-form-urlencoded`**：普通表单提交（键值对 URL 编码）。\r\n4. **`text/html`**：HTML 文档渲染。\r\n5. **`text/plain`**：纯文本内容（如日志）。\r\n6. **`text/css`** / **`text/javascript`**：CSS 或 JS 文件类型。\r\n7. **`image/png`** / **`image/jpeg`**：图片资源格式。\r\n8. **`application/octet-stream`**：二进制流（如文件下载）。\r\n9. **`application/xml`**：XML 数据格式（传统接口）。"},{"title":"CSS动画和JS实现的动画分别有哪些优缺点？","answer":""},{"title":"AST语法树是什么？","answer":""},{"title":"CSR和SSR(前端渲染与后端渲染)区别是什么？","answer":""},{"title":"你知道哪些图标处理方案?","answer":""},{"title":"常见的登录鉴权方式有哪些？","answer":"1. **Cookie + Session**\r\n\r\n- **原理**：用户登录后，服务器创建一个 `Session`，将用户信息存储在服务器端，同时生成一个唯一的 `SessionID`，并将其以 `Cookie` 的形式发送给客户端。客户端之后的每次请求都携带该 `Cookie`，服务器用 `SessionID` 确认用户身份。\r\n- **优点**：服务器管理会话状态，安全性较高；可以设置短期有效期，适合敏感信息。\r\n- **缺点**：会消耗服务器内存，难以扩展；需跨域配置。\r\n\r\n2. **JWT（JSON Web Token）**\r\n\r\n- **原理**：登录成功后，服务器生成一个加密的 `JWT`，该令牌包含用户信息或标识，发送给客户端。之后的请求，客户端携带该 `JWT`，服务器通过验证 `JWT` 的签名来确认用户身份。\r\n- **优点**：无状态、可跨域，适合分布式架构；可携带信息，支持用户角色验证。\r\n- **缺点**：令牌较长，增加请求负担；一旦泄露容易被滥用。\r\n\r\n3. **OAuth**\r\n\r\n- **原理**：OAuth 是一种授权协议，用户通过第三方平台（如 Google、Facebook）登录，将权限授予该平台来访问某些资源。OAuth 2.0 使用 `Access Token` 访问受保护资源，`Refresh Token` 则用于获取新的 `Access Token`。\r\n- **优点**：用户体验好，适用于第三方应用授权登录；支持多级权限。\r\n- **缺点**：流程复杂，难以实现；`Token` 可能泄露或失效。\r\n\r\n4. **SAML（Security Assertion Markup Language）**\r\n\r\n- **原理**：SAML 是基于 XML 的单点登录协议，通常用于企业系统中。用户请求通过 SAML 协议在多个系统之间共享认证状态，允许用户在不重新登录的情况下访问其他应用。\r\n- **优点**：适用于企业内部系统间的统一登录；支持跨域。\r\n- **缺点**：复杂度高，基于 XML 的消息传递效率低。\r\n\r\n5. **SSO（Single Sign-On）**\r\n\r\n- **原理**：单点登录允许用户使用一个登录凭据访问多个应用或系统。常用的实现方案包括基于 OAuth、SAML 或 CAS（Central Authentication Service）。\r\n- **优点**：提高用户体验，避免多次登录；适用于多系统集成。\r\n- **缺点**：一旦账户泄露，多个系统都会受到威胁。\r\n\r\n6. **基于短信或邮件的 OTP（一次性密码）**\r\n\r\n- **原理**：用户登录时接收一个一次性密码（通常通过短信或邮件发送），有效期较短。用户输入正确的 OTP 后，即可完成登录。\r\n- **优点**：安全性高，适合敏感操作的二次验证。\r\n- **缺点**：需要借助短信或邮件服务，成本较高。\r\n\r\n7. **指纹、面部识别等生物识别**\r\n\r\n- **原理**：利用设备上的生物识别传感器进行身份认证，例如指纹、面部识别等。通常用于设备级别的解锁，或结合其他鉴权方式进行身份确认。\r\n- **优点**：用户体验佳、难以复制；适合移动设备的安全验证。\r\n- **缺点**：设备依赖性强；难以在 web 应用中普遍使用。"}]