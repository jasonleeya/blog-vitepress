[{"title":"谈一谈你对前端框架的理解?","description":"","answer":"<p>前端框架（如Vue/React）是<strong>高效构建用户界面</strong>的工具，核心价值在于：</p>\n<ol>\n<li><strong>组件化开发</strong>：\n<ul>\n<li>将UI拆分为独立、可复用的组件，提升代码复用性与可维护性。</li>\n</ul>\n</li>\n<li><strong>数据驱动视图</strong>：\n<ul>\n<li>通过响应式或虚拟DOM机制，数据变化自动更新视图，减少手动DOM操作。</li>\n</ul>\n</li>\n<li><strong>生态整合</strong>：\n<ul>\n<li>提供路由（Vue Router/React Router）、状态管理（Pinia/Redux）、构建工具（Vite/Webpack）等完整开发链路支持。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>：\n<ul>\n<li>虚拟DOM Diff算法、SSR服务端渲染、代码分割等优化手段，提升应用性能。</li>\n</ul>\n</li>\n</ol>\n<p><strong>解决的问题</strong>：</p>\n<ul>\n<li>传统开发中手动操作DOM的低效与复杂度；</li>\n<li>大规模应用下代码组织混乱、维护困难；</li>\n<li>跨团队协作规范不统一。</li>\n</ul>\n"},{"title":"谈谈对 MVC、MVP、MVVM 模式的理解？","description":"<p><strong>1. MVC（Model-View-Controller）</strong></p>\n<ul>\n<li><strong>组成</strong>：\n<ul>\n<li><strong>Model</strong>：管理数据和业务逻辑。</li>\n<li><strong>View</strong>：负责 UI 展示。</li>\n<li><strong>Controller</strong>：接收用户输入，更新 Model，并通知 View 更新。</li>\n</ul>\n</li>\n<li><strong>交互</strong>：\n<ul>\n<li>用户操作 → <strong>Controller</strong> → 更新 Model → <strong>View</strong> 监听 Model 变化并渲染。</li>\n</ul>\n</li>\n<li><strong>特点</strong>：\n<ul>\n<li>View 可直接访问 Model，导致<strong>双向依赖</strong>（如观察者模式），耦合度较高。</li>\n<li>典型应用：传统后端框架（如 Spring MVC）、早期前端框架。</li>\n</ul>\n</li>\n<li><strong>问题</strong>：View 和 Model 的强耦合可能导致代码维护困难。</li>\n</ul>\n<p><strong>2. MVP（Model-View-Presenter）</strong></p>\n<ul>\n<li><strong>组成</strong>：\n<ul>\n<li><strong>Model</strong>：同 MVC，管理数据。</li>\n<li><strong>View</strong>：被动 UI，仅定义界面结构和触发事件。</li>\n<li><strong>Presenter</strong>：中介者，处理业务逻辑，更新 Model 并控制 View。</li>\n</ul>\n</li>\n<li><strong>交互</strong>：\n<ul>\n<li>用户操作 → <strong>View</strong> → 通知 Presenter → 更新 Model → Presenter 更新 View。</li>\n</ul>\n</li>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>View 与 Model 完全解耦</strong>，所有逻辑集中在 Presenter。</li>\n<li>更易测试（Mock View 即可测试 Presenter）。</li>\n<li>典型应用：桌面应用（如 Android 早期开发）。</li>\n</ul>\n</li>\n<li><strong>问题</strong>：Presenter 可能变得臃肿，需手动同步 View 和 Model。</li>\n</ul>\n<p><strong>3. MVVM（Model-View-ViewModel）</strong></p>\n<ul>\n<li><strong>组成</strong>：\n<ul>\n<li><strong>Model</strong>：数据层。</li>\n<li><strong>View</strong>：UI 展示。</li>\n<li><strong>ViewModel</strong>：通过数据绑定（Data Binding）连接 View 和 Model，暴露命令和状态。</li>\n</ul>\n</li>\n<li><strong>交互</strong>：\n<ul>\n<li><strong>双向绑定</strong>：View 的输入自动更新 ViewModel，ViewModel 变化自动同步到 View。</li>\n<li><strong>数据驱动</strong>：Model 变化 → ViewModel 更新 → View 自动渲染（如 Vue/React）。</li>\n</ul>\n</li>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>低耦合</strong>：View 不直接操作 Model，通过 ViewModel 代理。</li>\n<li><strong>高效开发</strong>：减少手动 DOM 操作（如 Vue 的 <code>v-model</code>）。</li>\n<li>典型应用：现代前端框架（Vue.js、React + MobX）。</li>\n</ul>\n</li>\n<li><strong>问题</strong>：过度依赖数据绑定可能导致调试困难或性能问题（如大型列表渲染）。</li>\n</ul>\n<p><strong>对比总结</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式</th>\n<th style=\"text-align:left\">核心思想</th>\n<th style=\"text-align:left\">通信方式</th>\n<th style=\"text-align:left\">适用场景</th>\n</tr>\n</thead>\n</table>\n","answer":""},{"title":"说说你对 SPA（单页应用）的理解?","description":"","answer":"<p>SPA（单页应用）是指<strong>通过前端路由动态渲染内容</strong>的 Web 应用，其核心特点是：</p>\n<ol>\n<li><strong>单次加载</strong>：首次访问加载完整 HTML、CSS 和 JS，后续页面切换通过 AJAX/API 获取数据，客户端动态更新 DOM，无需整页刷新。</li>\n<li><strong>前端路由</strong>：利用 <code>history API</code> 或 <code>hash</code> 实现 URL 变化与视图匹配，保持用户体验流畅性（如 Vue Router、React Router）。</li>\n<li><strong>优点</strong>：\n<ul>\n<li>交互流畅，接近原生应用体验；</li>\n<li>减轻服务器压力，前后端分离开发；</li>\n<li>支持复杂状态管理（如 Redux、Pinia）。</li>\n</ul>\n</li>\n<li><strong>挑战</strong>：\n<ul>\n<li><strong>SEO 不友好</strong>：传统爬虫难以抓取动态内容（可通过 SSR/SSG 优化）；</li>\n<li><strong>首屏性能</strong>：资源加载较慢（需代码分割、懒加载优化）；</li>\n<li><strong>内存管理</strong>：长期运行需警惕内存泄漏。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"SPA（单页应用）首屏加载速度慢怎么解决？","description":"","answer":"<p>单页面应用（SPA）首屏加载速度慢的问题可能由多种因素造成。以下是一些优化首屏加载速度的常见方法：</p>\n<ol>\n<li><strong>代码分割（Code Splitting）</strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>描述</strong>：将代码拆分成多个小块，只加载当前页面所需的代码。</p>\n</li>\n<li>\n<p><strong>实现</strong>：使用 Webpack 或其他打包工具进行动态导入，按需加载代码模块。</p>\n</li>\n<li>\n<p><strong>示例</strong>：使用 <code>React.lazy</code> 和 <code>Suspense</code> 进行组件级别的代码分割。</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#1E754F\">import</span><span style=\"color:#B07D48\"> React</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span><span style=\"color:#B07D48\"> Suspense</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> lazy</span><span style=\"color:#999999\"> }</span><span style=\"color:#1E754F\"> from</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">react</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> LazyComponent</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> lazy</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#AB5959\"> import</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">./LazyComponent</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> App</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    return</span><span style=\"color:#999999\"> (</span></span>\n<span class=\"line\"><span style=\"color:#999999\">        &#x3C;</span><span style=\"color:#998418\">Suspense</span><span style=\"color:#B07D48\"> fallback</span><span style=\"color:#999999\">={&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">Loading...</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">>}></span></span>\n<span class=\"line\"><span style=\"color:#999999\">            &#x3C;</span><span style=\"color:#998418\">LazyComponent</span><span style=\"color:#999999\"> /></span></span>\n<span class=\"line\"><span style=\"color:#999999\">        &#x3C;/</span><span style=\"color:#998418\">Suspense</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    );</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>懒加载（Lazy Loading）</strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>描述</strong>：只在需要时加载资源（如图片、组件）。</p>\n</li>\n<li>\n<p><strong>实现</strong>：使用 <code>IntersectionObserver</code> 或第三方库（如 <code>react-lazyload</code>）。</p>\n</li>\n<li>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#1E754F\">import</span><span style=\"color:#B07D48\"> React</span><span style=\"color:#1E754F\"> from</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">react</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> LazyImage</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> React</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">lazy</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#AB5959\"> import</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">./LazyImage</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> App</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    return</span><span style=\"color:#999999\"> (</span></span>\n<span class=\"line\"><span style=\"color:#999999\">        &#x3C;</span><span style=\"color:#998418\">React.Suspense</span><span style=\"color:#B07D48\"> fallback</span><span style=\"color:#999999\">={&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">Loading...</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">>}></span></span>\n<span class=\"line\"><span style=\"color:#999999\">            &#x3C;</span><span style=\"color:#998418\">LazyImage</span><span style=\"color:#999999\"> /></span></span>\n<span class=\"line\"><span style=\"color:#999999\">        &#x3C;/</span><span style=\"color:#998418\">React.Suspense</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    );</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<ol start=\"3\">\n<li><strong>减少初始加载资源</strong></li>\n</ol>\n<ul>\n<li><strong>描述</strong>：减少首屏渲染时需要加载的资源量（如 JS、CSS 文件）。</li>\n<li><strong>实现</strong>：合并和压缩 CSS 和 JS 文件，删除未使用的 CSS，减少 HTTP 请求数量。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>服务器端渲染（SSR）</strong></li>\n</ol>\n<ul>\n<li><strong>描述</strong>：将页面的初始内容在服务器端生成，以减少客户端的渲染时间。</li>\n<li><strong>实现</strong>：使用框架（如 Next.js、Nuxt.js）支持 SSR，优化首屏加载时间。</li>\n</ul>\n<ol start=\"5\">\n<li><strong>使用 Service Workers</strong></li>\n</ol>\n<ul>\n<li>\n<p><strong>描述</strong>：使用 Service Workers 缓存资源和页面，加速后续的访问。</p>\n</li>\n<li>\n<p><strong>实现</strong>：在应用中注册 Service Worker，缓存静态资源和 API 请求。</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#1E754F\">if</span><span style=\"color:#999999\"> (</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">serviceWorker</span><span style=\"color:#B5695977\">'</span><span style=\"color:#AB5959\"> in</span><span style=\"color:#B07D48\"> navigator</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    window</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">addEventListener</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">load</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">        navigator</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">serviceWorker</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">register</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">/service-worker.js</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span></span>\n<span class=\"line\"><span style=\"color:#999999\">            .</span><span style=\"color:#59873A\">then</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">registration</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">                console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">log</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">ServiceWorker registration successful:</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> registration</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">            })</span></span>\n<span class=\"line\"><span style=\"color:#999999\">            .</span><span style=\"color:#59873A\">catch</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">error</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">                console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">log</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">ServiceWorker registration failed:</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> error</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">            });</span></span>\n<span class=\"line\"><span style=\"color:#999999\">    });</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>优化数据请求</strong></li>\n</ol>\n<ul>\n<li><strong>描述</strong>：优化初始数据请求，减少请求时间。</li>\n<li><strong>实现</strong>：将请求数据分为初始必要的数据和后续加载的数据，减少首屏渲染时的数据请求。</li>\n</ul>\n<ol start=\"7\">\n<li>CDN</li>\n</ol>\n<p>静态资源走CDN，缩短下载时间。</p>\n<ol start=\"8\">\n<li><strong>使用性能分析工具</strong></li>\n</ol>\n<ul>\n<li><strong>描述</strong>：分析应用性能，找到瓶颈。</li>\n<li><strong>实现</strong>：使用 Chrome DevTools、Lighthouse 等工具来分析和优化首屏加载时间。</li>\n</ul>\n<p>通过结合这些方法，可以显著改善 SPA 的首屏加载速度，提高用户体验。</p>\n"},{"title":"常⻅兼容性问题","description":"","answer":"<p><a href=\"https://juejin.cn/post/7067808335034220574\" target=\"_blank\" rel=\"noopener noreferrer\">前端开发中常见的浏览器兼容性问题及解决方案大汇总</a></p>\n"},{"title":"HTML 中的 attribute 属性和 JavaScript 中的 property 属性的详解以及区别","description":"","answer":"<p><strong>attribute</strong>：是HTML标签上的某个属性，如id、class、value等以及自定义属性，它的值只能是字符串，关于这个属性一共有三个相关的方法，setAttribute、getAttribute、removeAttribute；\n<strong>property</strong>：是js获取的DOM对象上的属性值，比如a，你可以将它看作为一个基本的js对象。这个节点包括很多property，比如value，className以及一些方法onclik等方法。</p>\n<p><strong>注意</strong>：在使用setAttribute的时候，该函数一定接收两个参数，setAttribute（attributeName,value）,无论value的值是什么类型都会编译为字符串类型。在html标签中添加属性，本质上是跟在标签里面写属性时一样的，所以属性值最终都会编译为字符串类型。</p>\n"},{"title":"HTML 中的 attribute 属性和 JavaScript 中的 property 属性区别","description":"","answer":"<ul>\n<li><strong>Attribute</strong>：\n<ul>\n<li><strong>HTML 标签上的属性</strong>，定义在 HTML 中（如 <code>&lt;input id=&quot;name&quot; value=&quot;初始值&quot;&gt;</code>）。</li>\n<li>通过 <code>setAttribute()</code>/<code>getAttribute()</code> 操作，<strong>始终返回字符串</strong>。</li>\n</ul>\n</li>\n<li><strong>Property</strong>：\n<ul>\n<li><strong>DOM 对象（如元素节点）的属性</strong>，是 JavaScript 内存中的值。</li>\n<li>通过 <code>element.propertyName</code> 直接访问（如 <code>input.value</code>），<strong>类型多样</strong>（布尔、数字、对象等）。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"常见的 web 前端网络攻击有哪些？","description":"","answer":"<p><strong>1. XSS（跨站脚本攻击）</strong></p>\n<ul>\n<li><strong>原理</strong>：攻击者注入恶意脚本到页面中，窃取用户数据（如 Cookie）。</li>\n<li><strong>类型</strong>：存储型、反射型、DOM 型。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>输入内容转义（如 <code>&amp;</code> → <code>&amp;</code>）。</li>\n<li>使用 CSP（内容安全策略）限制脚本来源。</li>\n<li>避免 <code>innerHTML</code>，优先用 <code>textContent</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. CSRF（跨站请求伪造）</strong></p>\n<ul>\n<li><strong>原理</strong>：诱导用户发起非预期的请求（如修改密码）。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>关键操作校验 <code>Referer</code> 或 <code>Origin</code> 头。</li>\n<li>请求添加 CSRF Token（服务端生成并验证）。</li>\n<li>Cookie 设置 <code>SameSite=Strict/Lax</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>3. 点击劫持（Clickjacking）</strong></p>\n<ul>\n<li><strong>原理</strong>：通过透明 iframe 覆盖诱骗用户点击隐藏按钮。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>HTTP 头设置 <code>X-Frame-Options: DENY/SAMEORIGIN</code>。</li>\n<li>前端 JS 判断 <code>self === top</code> 防止嵌套。</li>\n</ul>\n</li>\n</ul>\n<p><strong>4. 中间人攻击（MITM）</strong></p>\n<ul>\n<li><strong>原理</strong>：劫持通信链路窃取或篡改数据。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>全站启用 HTTPS（HTTP/2 + HSTS 强制跳转）。</li>\n<li>避免混合内容（HTTP 与 HTTPS 混用）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>5. CORS 配置错误</strong></p>\n<ul>\n<li><strong>原理</strong>：不当的跨域策略导致敏感数据泄露。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>服务端严格设置 <code>Access-Control-Allow-Origin</code>（避免 <code>*</code>）。</li>\n<li>限制预检请求（<code>OPTIONS</code>）的响应头范围。</li>\n</ul>\n</li>\n</ul>\n<p><strong>6. DDoS（CC 攻击）</strong></p>\n<ul>\n<li><strong>原理</strong>：高频请求耗尽服务器资源。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>前端添加验证码或行为验证（如滑动拼图）。</li>\n<li>服务端限流（IP 频率限制）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"7\">\n<li>恶意文件上传**</li>\n</ol>\n<ul>\n<li><strong>原理</strong>：上传可执行文件（如 <code>.php</code>）到服务器。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>前端限制文件类型（白名单校验）。</li>\n<li>服务端重命名文件并扫描内容。</li>\n</ul>\n</li>\n</ul>\n<p><strong>8. DNS 劫持</strong></p>\n<ul>\n<li><strong>原理</strong>：篡改 DNS 解析结果导向恶意站点。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>使用 HTTPS 加密通信。</li>\n<li>启用 DNS over HTTPS（DoH）。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"什么是虚拟 DOM?其优点有哪些？","description":"<p>虚拟 DOM（Virtual DOM）是一种<strong>用 JavaScript 对象模拟真实 DOM 结构的中间层</strong>，常见于 React、Vue 等框架，其核心原理与优点如下：</p>\n<p><strong>一、虚拟 DOM 的核心原理</strong></p>\n<ol>\n<li><strong>结构映射</strong>：将真实 DOM 抽象为轻量的 JS 对象（如 <code>{ type: 'div', props: { className: 'box' }, children: [...] }</code>）。</li>\n<li><strong>差异比对（Diff）</strong>：状态变化时生成新虚拟 DOM，与旧版本对比，找出最小变更（差异）。</li>\n<li><strong>批量更新</strong>：将差异一次性应用到真实 DOM，减少直接操作次数。</li>\n</ol>\n<p><strong>二、虚拟 DOM 的核心优点</strong></p>\n<ol>\n<li><strong>性能优化</strong>\n<ul>\n<li><strong>减少直接 DOM 操作</strong>：真实 DOM 操作（如修改 <code>innerHTML</code>）会触发重排/重绘，成本高昂。</li>\n<li><strong>批量更新与合并</strong>：通过差异比对避免频繁的 DOM 修改，降低渲染开销。</li>\n</ul>\n</li>\n<li><strong>跨平台能力</strong>\n<ul>\n<li><strong>抽象渲染逻辑</strong>：虚拟 DOM 可对接不同平台（浏览器 DOM、移动端原生组件、Canvas 等），如 React Native。</li>\n</ul>\n</li>\n<li><strong>开发体验提升</strong>\n<ul>\n<li><strong>声明式编程</strong>：开发者关注数据与 UI 的关系，而非手动操作 DOM（如 <code>document.getElementById</code>）。</li>\n<li><strong>自动优化</strong>：框架处理底层 DOM 更新，简化复杂 UI 的维护。</li>\n</ul>\n</li>\n<li><strong>高效的 Diff 算法</strong>\n<ul>\n<li><strong>同级对比</strong>：React 等框架采用分层对比策略，时间复杂度从 O(n³) 优化至 O(n)。</li>\n<li><strong>Key 值优化</strong>：通过 <code>key</code> 标识元素，减少不必要的节点销毁与重建。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、虚拟 DOM 的适用场景</strong></p>\n<ul>\n<li><strong>动态复杂 UI</strong>：频繁交互的页面（如数据看板、编辑器）。</li>\n<li><strong>跨平台应用</strong>：一套代码适配多端渲染。</li>\n<li><strong>框架级优化</strong>：与状态管理、组件化结合，构建高效应用。</li>\n</ul>\n<p><strong>四、与传统直接操作 DOM 的对比</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>场景</strong></th>\n<th style=\"text-align:left\"><strong>直接操作 DOM</strong></th>\n<th style=\"text-align:left\"><strong>虚拟 DOM</strong></th>\n</tr>\n</thead>\n</table>\n","answer":""},{"title":"DOM 树和渲染树有什么区别？","description":"","answer":"<p>DOM 树和渲染树（Render Tree）的核心区别在于<strong>作用范围和节点过滤</strong>：</p>\n<ol>\n<li><strong>节点范围</strong>：\n<ul>\n<li><strong>DOM 树</strong>：包含 HTML 文档所有节点（包括隐藏元素如 <code>display: none</code> 或 <code>&lt;script&gt;</code>）。</li>\n<li><strong>渲染树</strong>：仅包含<strong>可见节点</strong>（如 <code>display: none</code> 的元素会被排除）。</li>\n</ul>\n</li>\n<li><strong>构建依据</strong>：\n<ul>\n<li>DOM 树由 HTML 解析直接生成，反映文档结构。</li>\n<li>渲染树由 DOM 树 + CSSOM（CSS 样式规则）组合生成，决定实际渲染内容。</li>\n</ul>\n</li>\n<li><strong>节点对应关系</strong>：\n<ul>\n<li>DOM 节点与渲染树节点不一定一一对应（如 <code>visibility: hidden</code> 的元素仍占用渲染树空间）。</li>\n</ul>\n</li>\n<li><strong>核心作用</strong>：\n<ul>\n<li>DOM 树提供文档结构操作能力（如 JS 增删节点）。</li>\n<li>渲染树驱动浏览器布局（Layout）和绘制（Paint），直接影响页面渲染性能。</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例</strong>：</p>\n<ul>\n<li><code>&lt;div style=&quot;display: none&quot;&gt;</code> 会出现在 DOM 树中，但不会进入渲染树。</li>\n<li><code>&lt;span&gt;Hello&lt;/span&gt;</code> 在渲染树中可能被合并到父级文本块中。</li>\n</ul>\n"},{"title":"Vue 与 React的区别，分别在哪些场景下使用更合适？","description":"","answer":"<p>一、核心区别</p>\n<ol>\n<li><strong>数据绑定与响应式机制</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：采用<strong>双向数据绑定</strong>（如<code>v-model</code>），通过<code>getter/setter</code>劫持数据变化，自动追踪依赖并更新视图，简化了表单交互开发137。</li>\n<li><strong>React</strong>：坚持<strong>单向数据流</strong>，需通过<code>setState</code>显式更新状态，依赖虚拟DOM的<code>diff</code>算法优化渲染性能，强调数据的不可变性169。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>模板与语法</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：使用基于HTML的模板语法（如<code>v-if</code>、<code>v-for</code>），逻辑与视图分离更直观，适合偏好声明式开发的团队268。</li>\n<li><strong>React</strong>：完全依赖<strong>JSX</strong>（JavaScript XML），将HTML与JavaScript混合编写，提供更高的灵活性，适合函数式编程爱好者6910。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>组件通信与复用</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：通过<code>props</code>传递数据、<code>$emit</code>触发事件，支持<code>provide/inject</code>跨层级通信；逻辑复用多依赖<code>mixins</code>或<code>Composition API</code>17。</li>\n<li><strong>React</strong>：父组件通过<code>props</code>传递回调函数，跨层级通信使用<code>Context API</code>；逻辑复用通过<strong>HOC（高阶组件）<strong>或</strong>Hooks</strong>实现159。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>状态管理</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：内置<strong>Vuex/Pinia</strong>，支持直接修改状态，深度集成响应式系统，开发体验更简洁179。</li>\n<li><strong>React</strong>：依赖第三方库如<strong>Redux/MobX</strong>，强调不可变数据与纯函数，需通过<code>dispatch</code>触发状态变更，适合复杂状态流156。</li>\n</ul>\n<ol start=\"5\">\n<li><strong>生态系统与工具链</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：官方提供全家桶（Vue Router、Vuex、Vite），适合快速搭建轻量级应用；中文文档友好，学习曲线平缓3610。</li>\n<li><strong>React</strong>：社区生态庞大（如Next.js、React Native），工具链灵活但需自行选型；适合企业级应用与跨平台开发5610。</li>\n</ul>\n<p>二、适用场景</p>\n<ol>\n<li><strong>选择Vue的场景</strong></li>\n</ol>\n<ul>\n<li><strong>中小型项目</strong>：快速原型开发、表单密集型应用（如后台管理系统），Vue的响应式系统能显著减少手动编码量368。</li>\n<li><strong>团队新手较多</strong>：模板语法直观，文档详尽，适合传统Web开发者快速上手610。</li>\n<li><strong>渐进式集成</strong>：需逐步替换旧项目（如jQuery），通过CDN引入局部功能升级510。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>选择React的场景</strong></li>\n</ol>\n<ul>\n<li><strong>大型复杂应用</strong>：如社交平台、实时协作工具，React的单向数据流与虚拟DOM优化更易维护高性能动态界面569。</li>\n<li><strong>跨平台开发</strong>：借助<strong>React Native</strong>实现iOS/Android代码复用，适用于需原生性能的移动端项目510。</li>\n<li><strong>强类型与测试需求</strong>：结合TypeScript，提升代码健壮性；生命周期管理严格，适合微前端架构569。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>其他考量因素</strong></li>\n</ol>\n<ul>\n<li><strong>团队经验</strong>：熟悉函数式编程选React，偏好HTML模板选Vue610。</li>\n<li><strong>长期维护性</strong>：React的不可变数据与TypeScript支持降低重构风险；Vue的渐进式升级路径更明确（如Vue2→3平滑迁移）59。</li>\n</ul>\n"},{"title":"从浏览器输入 URL 后都经历了什么","description":"","answer":"<ul>\n<li>\n<p>通过DNS解析获得网址的对应IP地址</p>\n</li>\n<li>\n<p>浏览器与远程web服务器 通过TCP三次握手协商来建立一个 TCP/IP 连接</p>\n</li>\n<li>\n<p>浏览器 通过TCP/IP连接 向web服务器 发送一个 HTTP 请求</p>\n</li>\n<li>\n<p>服务器的永久重定向响应</p>\n</li>\n<li>\n<p>浏览器跟踪重定向地址</p>\n</li>\n<li>\n<p>服务器处理请求</p>\n</li>\n<li>\n<p>服务器返回一个 HTTP 响应</p>\n</li>\n<li>\n<p>浏览器渲染:解析HTML、解析CSS、解析JS、Render树</p>\n</li>\n</ul>\n"},{"title":"回流和重绘有什么区别？","description":"","answer":"<p><strong>1. 触发原因</strong></p>\n<ul>\n<li><strong>回流（Reflow）</strong>：当元素的<strong>几何属性或布局发生变化</strong>（如宽高、位置、字体大小、窗口缩放等），浏览器需重新计算元素的几何信息并更新布局树。</li>\n<li><strong>重绘（Repaint）</strong>：当元素的<strong>样式变化但不影响布局</strong>（如颜色、背景、透明度等），浏览器只需重新绘制受影响区域。</li>\n</ul>\n<p><strong>2. 性能影响</strong></p>\n<ul>\n<li><strong>回流比重绘代价更高</strong>：回流会导致子元素及后续元素的连锁重新计算（“布局抖动”），而重绘仅涉及像素更新。</li>\n<li><strong>回流必定触发重绘</strong>：布局变化后必然需要重新绘制，但重绘不一定触发回流。</li>\n</ul>\n<p><strong>3. 常见触发场景</strong></p>\n<ul>\n<li><strong>回流</strong>：\n<ul>\n<li>修改元素的尺寸、位置、边距（如 <code>width</code>、<code>margin</code>、<code>position</code>）。</li>\n<li>增删可见 DOM 元素。</li>\n<li>读取某些属性（如 <code>offsetTop</code>、<code>scrollHeight</code>）会强制同步回流。</li>\n</ul>\n</li>\n<li><strong>重绘</strong>：\n<ul>\n<li>修改颜色（<code>color</code>）、背景（<code>background</code>）、阴影（<code>box-shadow</code>）。</li>\n<li>隐藏元素但保留布局（如 <code>visibility: hidden</code>）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>优化策略</strong></p>\n<ol>\n<li><strong>减少回流次数</strong>：\n<ul>\n<li>使用 <code>transform</code> 或 <code>opacity</code> 代替直接修改 <code>top/left</code>（触发 GPU 加速，跳过回流）。</li>\n<li>避免逐行修改样式，通过 <code>class</code> 或 <code>cssText</code> 批量更新。</li>\n<li>使用 <code>DocumentFragment</code> 批量操作 DOM。</li>\n</ul>\n</li>\n<li><strong>避免强制同步布局</strong>：\n<ul>\n<li>避免在循环中频繁读取布局属性（如 <code>offsetWidth</code>），会强制浏览器立即回流。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"你知道哪些性能优化手段？","description":"","answer":"<p><strong>一、网络请求优化</strong></p>\n<ol>\n<li><strong>减少请求次数</strong>\n<ul>\n<li>合并资源（CSS/JS 文件、雪碧图）。</li>\n<li>使用 HTTP/2 多路复用降低队头阻塞。</li>\n</ul>\n</li>\n<li><strong>资源压缩与缓存</strong>\n<ul>\n<li>开启 Gzip/Brotli 压缩。</li>\n<li>强缓存（<code>Cache-Control</code>）与协商缓存（<code>ETag</code>）合理配置。</li>\n</ul>\n</li>\n<li><strong>CDN 加速</strong>：静态资源分发至边缘节点，减少传输延迟。</li>\n</ol>\n<p><strong>二、资源加载优化</strong></p>\n<ol>\n<li><strong>按需加载</strong>\n<ul>\n<li>路由懒加载（React.lazy + Suspense）。</li>\n<li>图片懒加载（<code>loading=&quot;lazy&quot;</code> 或 IntersectionObserver）。</li>\n</ul>\n</li>\n<li><strong>预加载关键资源</strong>\n<ul>\n<li><code>&lt;link rel=&quot;preload&quot;&gt;</code> 提前加载字体、核心 JS/CSS。</li>\n<li>异步脚本（<code>async/defer</code>）避免阻塞渲染。</li>\n</ul>\n</li>\n<li><strong>资源体积优化</strong>\n<ul>\n<li>代码分包（Webpack SplitChunks）。</li>\n<li>图片格式优化（WebP/AVIF）、响应式图片（<code>srcset</code>）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、渲染性能优化</strong></p>\n<ol>\n<li><strong>减少重排与重绘</strong>\n<ul>\n<li>避免频繁操作样式，使用 <code>transform/opacity</code> 触发 GPU 加速。</li>\n<li>批量 DOM 更新（DocumentFragment）。</li>\n</ul>\n</li>\n<li><strong>优化长列表</strong>\n<ul>\n<li>虚拟滚动（React Virtualized、Vue Virtual Scroller）。</li>\n</ul>\n</li>\n<li><strong>避免强制同步布局</strong>\n<ul>\n<li>分离读写操作（如先读取布局属性，再统一修改）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>四、代码执行优化</strong></p>\n<ol>\n<li><strong>减少主线程阻塞</strong>\n<ul>\n<li>长任务拆分（Web Workers）。</li>\n<li>防抖/节流（resize、scroll 事件）。</li>\n</ul>\n</li>\n<li><strong>内存管理</strong>\n<ul>\n<li>及时解绑事件监听、清除定时器。</li>\n<li>避免内存泄漏（闭包、全局变量滥用）。</li>\n</ul>\n</li>\n<li><strong>Tree Shaking</strong>：删除未使用代码（ES Module 静态分析）。</li>\n</ol>\n<p><strong>五、其他关键优化</strong></p>\n<ol>\n<li><strong>SSR/SSG</strong>：服务端渲染（如 Next.js）提升首屏速度。</li>\n<li><strong>Web Vitals 指标优化</strong>\n<ul>\n<li>LCP：优先加载关键资源，优化图片/字体。</li>\n<li>FID：减少主线程长任务，延迟非关键 JS。</li>\n<li>CLS：预留图片/广告位尺寸，避免布局偏移。</li>\n</ul>\n</li>\n<li><strong>性能监控</strong>\n<ul>\n<li>Lighthouse 评分分析。</li>\n<li>埋点上报（FP/FCP/LCP 等关键指标）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结</strong></p>\n<p>性能优化需结合具体场景，核心思路是 <strong>减少负载、加速渲染、避免阻塞</strong>。通过工具分析瓶颈（如 Chrome DevTools Performance 面板），渐进式优化并持续监控。</p>\n"},{"title":"前端动画有哪些实现方式？","description":"","answer":"<ol>\n<li><strong>CSS动画</strong>：使用 <code>transition</code> 和 <code>@keyframes</code> 实现简单动画，性能优化好，适合交互动效（如悬停、加载）。</li>\n<li><strong>JavaScript动画库</strong>：如 <strong>GSAP</strong>、Anime.js，适合复杂动画（时间轴、路径动画），控制精细。</li>\n<li><strong>SVG动画</strong>：通过 <code>&lt;animate&gt;</code> 标签或操作DOM属性，适合矢量图形动画（如图标变形）。</li>\n<li><strong>Canvas/WebGL</strong>：用 <strong>Canvas API</strong> 或 <strong>Three.js</strong> 实现高性能动画（游戏、数据可视化）。</li>\n<li><strong>框架内置动画</strong>：如 Vue 的 <code>&lt;Transition&gt;</code> 组件、React 的 <strong>React Spring</strong>，与框架深度集成。</li>\n<li><strong>Web Animations API</strong>：原生JS API，融合CSS和JS动画能力，可控性强。</li>\n</ol>\n"},{"title":"Canvas 和 SVG 的区别","description":"","answer":"<p>Canvas 是<strong>位图</strong>，通过 JavaScript 动态绘制，适合高频渲染（如动画、游戏），但元素不可单独操作；</p>\n<p>SVG 是<strong>矢量图</strong>，基于 XML 描述图形，支持缩放无损、DOM 事件绑定，适合静态或交互复杂图形（如图标、图表）。Canvas 性能更高，SVG 更易维护和交互。</p>\n"},{"title":"如何判断用户设备？","description":"","answer":"<ol>\n<li>使用 navigator.userAgent（用户代理字符串）</li>\n<li>使用 CSS 媒体查询</li>\n<li>js判断视口宽度</li>\n<li>第三方库（mobile-detect.js等）</li>\n</ol>\n"},{"title":"你知道哪些自适应的方案？","description":"","answer":"<ol>\n<li><strong>媒体查询（Media Queries）</strong>\n通过CSS <code>@media</code> 根据屏幕尺寸适配不同样式，如断点布局（Bootstrap栅格系统）。</li>\n<li><strong>弹性布局（Flexbox/Grid）</strong>\n使用 <code>Flexbox</code> 或 <code>CSS Grid</code> 实现弹性容器，自动适应不同屏幕尺寸。</li>\n<li><strong>百分比/视口单位（vw/vh）</strong>\n用 <code>%</code>、<code>vw</code>（视口宽度单位）或 <code>vh</code>（视口高度单位）动态调整元素尺寸。</li>\n<li><strong>Rem适配方案</strong>\n结合 <code>rem</code>（根元素字体大小）和 <code>JavaScript</code> 动态计算根字体（如根据屏幕宽度设置 <code>1rem = 屏幕宽度的1/10</code>）。</li>\n<li><strong>响应式图片</strong>\n使用 <code>&lt;picture&gt;</code> 标签或 <code>srcset</code> 属性适配不同分辨率，结合 <code>max-width: 100%</code> 防止图片溢出。</li>\n</ol>\n"},{"title":" 前端需要注意哪些 SEO","description":"","answer":"<ol>\n<li><strong>语义化 HTML</strong>\n合理使用 <code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code> 等标签，增强内容可读性。</li>\n<li><strong>标题与 Meta 标签</strong>\n确保每个页面有唯一的 <code>&lt;title&gt;</code> 和 <code>meta description</code>，准确描述页面内容。</li>\n<li><strong>图片优化</strong>\n添加 <code>alt</code> 属性，压缩图片体积（WebP格式），使用 <code>srcset</code> 适配不同分辨率。</li>\n<li><strong>友好的 URL 结构</strong>\n采用静态路径（如 <code>/blog/seo-tips</code>），避免 <code>#</code> 路由或动态参数混乱。</li>\n<li><strong>移动端适配</strong>\n响应式设计 + <code>viewport</code> 配置，确保移动端体验良好（影响 Google 排名）。</li>\n<li><strong>性能优化</strong>\n压缩资源、减少渲染阻塞（如懒加载）、提升加载速度（Lighthouse 评分）。</li>\n<li><strong>避免纯 SPA 问题</strong>\n单页应用（如 React/Vue）需结合 SSR（服务端渲染）或预渲染，保证爬虫抓取内容。</li>\n<li><strong>结构化数据（Schema）</strong>\n使用 JSON-LD 标记关键信息（如产品价格、评分），提升搜索富片段展示。</li>\n<li><strong>外链与内链优化</strong>\n合理设置 <code>&lt;a&gt;</code> 标签的 <code>href</code>，避免死链，利用 <code>rel=&quot;nofollow&quot;</code> 控制权重。</li>\n<li><strong>Sitemap 与 robots.txt</strong>\n提交 XML 站点地图，配置爬虫抓取规则。</li>\n</ol>\n"},{"title":"cookie 和 session 有什么区别","description":"","answer":"<ol>\n<li><strong>存储位置</strong>\n<ul>\n<li>Cookie：数据存储在<strong>客户端</strong>（浏览器），通过请求头自动传递。</li>\n<li>Session：数据存储在<strong>服务端</strong>，客户端仅保存 Session ID（通常通过 Cookie 存储）。</li>\n</ul>\n</li>\n<li><strong>安全性</strong>\n<ul>\n<li>Cookie：易被篡改或窃取（需配合 <code>HttpOnly</code>、<code>Secure</code> 等属性提升安全性）。</li>\n<li>Session：敏感数据存于服务端，仅暴露 ID，安全性更高。</li>\n</ul>\n</li>\n<li><strong>存储大小限制</strong>\n<ul>\n<li>Cookie：单域名下通常限制为 <strong>4KB</strong> 左右。</li>\n<li>Session：服务端存储，理论无严格大小限制。</li>\n</ul>\n</li>\n<li><strong>生命周期</strong>\n<ul>\n<li>Cookie：可设置过期时间（如 <code>Expires</code> 或 <code>Max-Age</code>），支持长期保存。</li>\n<li>Session：依赖服务端配置，通常浏览器关闭即失效（或服务端主动清理）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"懒加载和预加载有什么区别？","description":"","answer":"<ol>\n<li><strong>加载时机</strong>\n<ul>\n<li><strong>懒加载</strong>：延迟加载非关键资源（如图片、组件），当用户即将需要时（如滚动到视口）触发。</li>\n<li><strong>预加载</strong>：提前加载后续可能需要的资源（如下一页内容），在空闲时间或用户操作前完成。</li>\n</ul>\n</li>\n<li><strong>核心目的</strong>\n<ul>\n<li><strong>懒加载</strong>：优化首屏加载速度，减少初始请求压力。</li>\n<li><strong>预加载</strong>：提升后续操作的流畅性，减少用户等待时间。</li>\n</ul>\n</li>\n<li><strong>典型场景</strong>\n<ul>\n<li><strong>懒加载</strong>：长列表、图库、非首屏内容。</li>\n<li><strong>预加载</strong>：幻灯片切换、关键功能模块、预测用户下一步行为。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>\n<ul>\n<li><strong>懒加载</strong>：通过 <code>Intersection Observer</code> 监听元素可见性，或动态 <code>import()</code> 异步加载组件。</li>\n<li><strong>预加载</strong>：使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>fetch()</code> 提前请求资源。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？","description":"","answer":"<p><strong>使用 1x1 像素透明 GIF 图片发送埋点请求的核心原因</strong>：</p>\n<ol>\n<li><strong>无跨域限制</strong>：\n<code>&lt;img&gt;</code> 标签天然支持跨域请求，无需 CORS 配置，避免浏览器拦截。</li>\n<li><strong>性能损耗低</strong>：\n1x1 透明 GIF 体积极小（约 43B），传输快且不占用额外资源，对页面性能影响最小。</li>\n<li><strong>兼容性强</strong>：\n所有浏览器均支持 GIF 格式，且图片加载无阻塞问题（相比脚本或 AJAX）。</li>\n<li><strong>无副作用</strong>：\n透明图片不会干扰页面展示，无需处理内容返回（服务器只需响应 204/200 状态码）。</li>\n<li><strong>数据传参灵活</strong>：\n通过 URL 的 query 参数携带埋点数据（如 <code>?event=click&amp;user=123</code>），服务端解析日志即可。</li>\n</ol>\n"},{"title":"简述一下 PWA","description":"","answer":"<p><strong>PWA（渐进式网络应用）的核心要点</strong>：</p>\n<ol>\n<li><strong>核心能力</strong>：\n<ul>\n<li><strong>离线可用</strong>：通过 <code>Service Worker</code> 缓存资源，实现弱网或无网访问。</li>\n<li><strong>类原生体验</strong>：支持添加到主屏幕、全屏模式、推送通知（Push API）。</li>\n</ul>\n</li>\n<li><strong>关键技术</strong>：\n<ul>\n<li><strong>Service Worker</strong>：后台脚本管理缓存与网络代理。</li>\n<li><strong>Web App Manifest</strong>：定义应用图标、启动页等元数据（<code>manifest.json</code>）。</li>\n<li><strong>HTTPS 强制</strong>：确保通信安全。</li>\n</ul>\n</li>\n<li><strong>核心优势</strong>：\n<ul>\n<li><strong>响应式设计</strong>：适配多端（PC/移动）。</li>\n<li><strong>低流量消耗</strong>：优先加载缓存资源。</li>\n<li><strong>无安装依赖</strong>：通过浏览器访问，支持渐进增强（逐步支持高级功能）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"前端埋点有哪些方案？","description":"","answer":"<ol>\n<li><strong>代码埋点（手动埋点）</strong>\n在代码中插入上报逻辑（如点击/曝光事件），灵活但维护成本高。</li>\n<li><strong>可视化埋点</strong>\n通过工具（如GrowingIO）配置事件，无代码侵入，适合非技术人员操作。</li>\n<li><strong>无埋点（全埋点）</strong>\n自动采集全量用户行为（如点击、页面停留），通过后端过滤分析，数据全但处理复杂。</li>\n<li><strong>服务端埋点</strong>\n由后端记录日志（如API请求），避免客户端数据丢失，但无法捕获前端交互细节。</li>\n<li><strong>基于Image/Beacon的请求</strong>\n使用 <code>new Image().src</code> 或 <code>navigator.sendBeacon()</code> 发送数据，避免阻塞页面。</li>\n</ol>\n"},{"title":"简述一下 WebAssembly","description":"","answer":"<ol>\n<li><strong>定位</strong>：\n<ul>\n<li>一种<strong>二进制指令格式</strong>，能在浏览器中高性能执行（接近原生速度），与JS互补，非替代。</li>\n</ul>\n</li>\n<li><strong>核心能力</strong>：\n<ul>\n<li><strong>高性能计算</strong>：适用于图形渲染、游戏、加密等CPU密集型任务。</li>\n<li><strong>跨语言支持</strong>：C/C++/Rust等语言可编译成Wasm，复用现有生态。</li>\n<li><strong>沙箱安全</strong>：运行在隔离内存环境中，避免恶意代码攻击。</li>\n</ul>\n</li>\n<li><strong>应用场景</strong>：\n<ul>\n<li>浏览器内高性能应用（如FFmpeg视频解码）。</li>\n<li>跨平台应用（结合Web/桌面/移动端）。</li>\n<li>模块化加速（如JS性能瓶颈的数学计算）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"如何给自己团队的大型前端项目设计单元测试？","description":"","answer":"<ol>\n<li><strong>选型与分层</strong>\n<ul>\n<li><strong>框架</strong>：选主流工具（如Jest+Vue Test Utils/React Testing Library），确保生态支持。</li>\n<li><strong>分层策略</strong>：按模块拆分（Utils → Components → Hooks → API层），优先覆盖核心逻辑与公共模块。</li>\n</ul>\n</li>\n<li><strong>覆盖率与规范</strong>\n<ul>\n<li><strong>阈值设定</strong>：核心代码覆盖率不低于80%（如业务Utils），UI组件可放宽。</li>\n<li><strong>Mock策略</strong>：用<code>jest.mock</code>隔离API、第三方库，避免真实网络请求。</li>\n</ul>\n</li>\n<li><strong>组件测试重点</strong>\n<ul>\n<li><strong>渲染校验</strong>：验证Props传递与条件渲染（如<code>toBeInTheDocument</code>）。</li>\n<li><strong>交互测试</strong>：模拟用户操作（点击/输入），断言状态或事件触发正确性。</li>\n</ul>\n</li>\n<li><strong>工程化集成</strong>\n<ul>\n<li><strong>Husky + Lint</strong>：提交代码前自动跑测试，拦截失败用例。</li>\n<li><strong>CI流水线</strong>：集成到Jenkins/GitHub Actions，生成可视化报告（如Jest HTML Reporter）。</li>\n</ul>\n</li>\n<li><strong>维护与优化</strong>\n<ul>\n<li><strong>快照测试</strong>：监控UI意外变更（慎用，避免频繁失效）。</li>\n<li><strong>测试可读性</strong>：用例命名清晰（<code>describe</code>场景，<code>it</code>预期结果），定期Review冗余用例。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"ECharts 是什么？能够用来做什么？","description":"","answer":"<p><code>ECharts</code>（百度开源的<strong>可视化图表库</strong>）是一个基于<code>JavaScript</code>的开源可视化图表库，可以用来创建丰富、交互式的数据可视化图表。</p>\n<p><code>ECharts</code>能够用来展示各种类型的图表，包括<strong>折线图、柱状图、条形图、散点图、饼图、雷达图、地图</strong>等。它支持动态更新数据，通过交互操作，可以实现数据的<strong>筛选、排序、缩放</strong>等功能。</p>\n<p><code>ECharts</code>提供了丰富的配置项和API，使开发者可以根据自己的需求灵活定制图表的样式和行为，同时还支持多种数据格式的导入和导出。它适用于各类<strong>数据分析、数据可视化、大屏展示</strong>等场景，可以帮助用户更直观地理解和分析数据，从而做出更好的决策。</p>\n"},{"title":"如何提高前端代码的可维护性和可拓展性？","description":"","answer":"<ol>\n<li><strong>模块化与组件化</strong>\n<ul>\n<li>按功能拆分独立模块/组件，遵循<strong>单一职责原则</strong>（如UI与逻辑分离），降低耦合度。</li>\n</ul>\n</li>\n<li><strong>统一代码规范</strong>\n<ul>\n<li>使用ESLint+Prettier强制代码风格，制定命名规则（如<code>动词+名词</code>函数名），增强可读性。</li>\n</ul>\n</li>\n<li><strong>类型系统</strong>\n<ul>\n<li>引入TypeScript，明确接口类型与数据结构，减少隐式错误，提升重构信心。</li>\n</ul>\n</li>\n<li><strong>设计模式应用</strong>\n<ul>\n<li>常用模式：工厂模式（创建对象）、策略模式（算法替换）、观察者模式（事件通信），提升扩展性。</li>\n</ul>\n</li>\n<li><strong>文档与注释</strong>\n<ul>\n<li>关键逻辑添加注释，维护组件API文档（如Storybook），降低新人上手成本。</li>\n</ul>\n</li>\n<li><strong>自动化测试</strong>\n<ul>\n<li>核心逻辑覆盖单元测试（Jest），复杂交互补充E2E测试（Cypress），保障迭代安全。</li>\n</ul>\n</li>\n<li><strong>状态管理规范</strong>\n<ul>\n<li>使用Redux/Pinia集中管理全局状态，避免Props多层透传，逻辑更易追踪。</li>\n</ul>\n</li>\n<li><strong>工程化工具链</strong>\n<ul>\n<li>配置Alias简化导入路径，利用Webpack/Vite实现按需加载，优化构建流程。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"列举一些常见的 content-type","description":"","answer":"<ol>\n<li><strong><code>application/json</code></strong>：JSON 数据交互，如 REST API 请求/响应。</li>\n<li><strong><code>multipart/form-data</code></strong>：表单文件上传（支持二进制数据）。</li>\n<li><strong><code>application/x-www-form-urlencoded</code></strong>：普通表单提交（键值对 URL 编码）。</li>\n<li><strong><code>text/html</code></strong>：HTML 文档渲染。</li>\n<li><strong><code>text/plain</code></strong>：纯文本内容（如日志）。</li>\n<li><strong><code>text/css</code></strong> / <strong><code>text/javascript</code></strong>：CSS 或 JS 文件类型。</li>\n<li><strong><code>image/png</code></strong> / <strong><code>image/jpeg</code></strong>：图片资源格式。</li>\n<li><strong><code>application/octet-stream</code></strong>：二进制流（如文件下载）。</li>\n<li><strong><code>application/xml</code></strong>：XML 数据格式（传统接口）。</li>\n</ol>\n"},{"title":"CSS 动画和 JS 实现的动画分别有哪些优缺点？","description":"<p><strong>一、CSS动画</strong></p>\n<p><strong>优点</strong></p>\n<ol>\n<li>\n<p><strong>高性能</strong></p>\n<ul>\n<li><strong>硬件加速</strong>：浏览器自动优化，优先使用GPU渲染（如<code>transform</code>、<code>opacity</code>属性）。</li>\n<li><strong>主线程无阻塞</strong>：动画运行在合成线程，不影响JS执行。</li>\n</ul>\n</li>\n<li>\n<p><strong>开发便捷</strong></p>\n<ul>\n<li><strong>声明式语法</strong>：通过<code>transition</code>或<code>@keyframes</code>快速定义，无需编写脚本。</li>\n<li><strong>简单位移效果</strong>：适合简单过渡（如悬停、颜色渐变）。</li>\n</ul>\n</li>\n<li>\n<p><strong>代码简洁</strong></p>\n<ul>\n<li><strong>低维护成本</strong>：动画逻辑与样式集中管理，适合团队协作。</li>\n</ul>\n</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>\n<p><strong>控制能力有限</strong></p>\n<ul>\n<li><strong>难以动态调整</strong>：无法实时修改动画参数（如暂停后反向播放）。</li>\n<li><strong>状态管理弱</strong>：无法监听动画中间状态（如精确到每帧的回调）。</li>\n</ul>\n</li>\n<li>\n<p><strong>复杂动画实现困难</strong></p>\n<ul>\n<li><strong>路径动画</strong>：需依赖SVG或复杂关键帧。</li>\n<li><strong>物理效果</strong>：难以实现弹簧、缓动等高级运动曲线。</li>\n</ul>\n</li>\n<li>\n<p><strong>兼容性限制</strong></p>\n<ul>\n<li><strong>部分属性不支持</strong>：如<code>box-shadow</code>的平滑过渡可能卡顿。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、JS动画</strong></p>\n<p><strong>优点</strong></p>\n<ol>\n<li>\n<p><strong>高度可控</strong></p>\n<ul>\n<li><strong>逐帧控制</strong>：通过<code>requestAnimationFrame</code>或库（如GSAP）精确操控动画生命周期。</li>\n<li><strong>动态参数</strong>：运行时修改速度、方向、暂停/继续。</li>\n</ul>\n</li>\n<li>\n<p><strong>复杂动画支持</strong></p>\n<ul>\n<li><strong>物理引擎</strong>：实现惯性滚动、弹性碰撞等效果（如<code>react-spring</code>）。</li>\n<li><strong>路径动画</strong>：自由定义贝塞尔曲线或SVG路径跟踪。</li>\n</ul>\n</li>\n<li>\n<p><strong>跨场景兼容性</strong></p>\n<ul>\n<li><strong>全属性支持</strong>：任意CSS属性、Canvas/WebGL渲染均可控制。</li>\n<li><strong>旧浏览器降级</strong>：通过Polyfill或JS逻辑兼容。</li>\n</ul>\n</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>\n<p><strong>性能风险</strong></p>\n<ul>\n<li><strong>主线程压力</strong>：频繁JS计算可能导致帧率下降（需优化代码或使用Web Workers）。</li>\n<li><strong>内存泄漏</strong>：未正确取消动画帧或事件监听会累积性能负担。</li>\n</ul>\n</li>\n<li>\n<p><strong>开发复杂度高</strong></p>\n<ul>\n<li><strong>代码量大</strong>：需手动管理动画逻辑（开始、暂停、结束）。</li>\n<li><strong>学习曲线陡峭</strong>：掌握<code>requestAnimationFrame</code>、时间函数等概念。</li>\n</ul>\n</li>\n<li>\n<p><strong>包体积增加</strong></p>\n<ul>\n<li><strong>依赖库体积</strong>：引入GSAP等库可能增加打包体积（GSAP核心约40KB）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、选型决策树</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>场景</strong></th>\n<th><strong>推荐方案</strong></th>\n<th><strong>示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>简单过渡（如悬停效果）</strong></td>\n<td>CSS动画</td>\n<td>按钮颜色渐变、图标旋转</td>\n</tr>\n<tr>\n<td><strong>复杂交互（如手势拖动）</strong></td>\n<td>JS动画（GSAP/原生）</td>\n<td>图片缩放、滑动菜单</td>\n</tr>\n<tr>\n<td><strong>物理动画（如弹性滚动）</strong></td>\n<td>JS动画（专用库）</td>\n<td>下拉刷新、卡片弹窗</td>\n</tr>\n<tr>\n<td><strong>3D变换/粒子效果</strong></td>\n<td>JS + WebGL/Canvas</td>\n<td>数据可视化、游戏特效</td>\n</tr>\n<tr>\n<td><strong>60FPS高性能需求</strong></td>\n<td>CSS动画或优化后的JS</td>\n<td>页面滚动视差、轮播图</td>\n</tr>\n</tbody>\n</table>\n<p><strong>四、性能优化技巧</strong></p>\n<p><strong>CSS动画优化</strong></p>\n<ul>\n<li>优先使用<code>transform</code>和<code>opacity</code>触发GPU加速；</li>\n<li>避免频繁重排（如动画中修改<code>width</code>/<code>height</code>）。</li>\n</ul>\n<p><strong>JS动画优化</strong></p>\n<ul>\n<li>使用<code>will-change: transform</code>预声明动画元素；</li>\n<li>批量DOM操作（如使用<code>DocumentFragment</code>）；</li>\n<li>限制帧率：对非关键动画采用<code>setTimeout</code>降频（如30FPS）。</li>\n</ul>\n<p><strong>五、推荐工具链</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>类型</strong></th>\n<th><strong>工具推荐</strong></th>\n<th><strong>核心优势</strong></th>\n</tr>\n</thead>\n</table>\n","answer":""},{"title":"AST 语法树是什么？","description":"","answer":"<p>AST（抽象语法树）是源代码的<strong>结构化树形表示</strong>，通过解析代码语法生成，用于程序分析、转换和执行。</p>\n<p><strong>具体描述</strong>：</p>\n<ol>\n<li>\n<p><strong>生成过程</strong>：</p>\n<ul>\n<li><strong>词法分析</strong>：将代码拆分为词法单元（Token），如变量名、运算符；</li>\n<li><strong>语法分析</strong>：根据语法规则（如ES规范）将Token组合为树形结构，每个节点代表一种语法结构（如循环、函数声明）。</li>\n</ul>\n</li>\n<li>\n<p><strong>核心作用</strong>：</p>\n<ul>\n<li><strong>代码转换</strong>：Babel利用AST进行ES6+转ES5、JSX编译；</li>\n<li><strong>静态分析</strong>：ESLint检查代码规范，Webpack分析依赖；</li>\n<li><strong>代码压缩</strong>：移除注释、未引用代码（如Terser）。</li>\n</ul>\n</li>\n<li>\n<p><strong>示例结构</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> add</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">a</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> b</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#1E754F\"> return</span><span style=\"color:#B07D48\"> a</span><span style=\"color:#AB5959\"> +</span><span style=\"color:#B07D48\"> b</span><span style=\"color:#999999\">;</span><span style=\"color:#999999\"> }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<pre><code class=\"language-json\"><div class=\"language-json \"><span class=\"lang\">json</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// AST 简略结构  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">{</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">  \"</span><span style=\"color:#998418\">type</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">FunctionDeclaration</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">  \"</span><span style=\"color:#998418\">id</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#99841877\"> \"</span><span style=\"color:#998418\">type</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">Identifier</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#99841877\"> \"</span><span style=\"color:#998418\">name</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">add</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\"> },</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">  \"</span><span style=\"color:#998418\">params</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [</span><span style=\"color:#A0ADA0\">/* a, b */</span><span style=\"color:#999999\">],</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">  \"</span><span style=\"color:#998418\">body</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">    \"</span><span style=\"color:#998418\">type</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">BlockStatement</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">    \"</span><span style=\"color:#998418\">body</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [{</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">      \"</span><span style=\"color:#998418\">type</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">ReturnStatement</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">      \"</span><span style=\"color:#998418\">argument</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">        \"</span><span style=\"color:#998418\">type</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">BinaryExpression</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">        \"</span><span style=\"color:#998418\">operator</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">+</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">        \"</span><span style=\"color:#998418\">left</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#99841877\"> \"</span><span style=\"color:#998418\">type</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">Identifier</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#99841877\"> \"</span><span style=\"color:#998418\">name</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">a</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\"> },</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#99841877\">        \"</span><span style=\"color:#998418\">right</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#99841877\"> \"</span><span style=\"color:#998418\">type</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">Identifier</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">,</span><span style=\"color:#99841877\"> \"</span><span style=\"color:#998418\">name</span><span style=\"color:#99841877\">\"</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">b</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\"> }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">      }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">    }]</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ol>\n<p><strong>工具应用</strong>：</p>\n<ul>\n<li><strong>解析库</strong>：@babel/parser、acorn；</li>\n<li><strong>操作库</strong>：@babel/traverse（遍历修改AST）；</li>\n<li><strong>生成代码</strong>：@babel/generator。</li>\n</ul>\n"},{"title":"CSR 和 SSR (前端渲染与后端渲染)区别是什么？","description":"<p><strong>一、核心流程对比</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>阶段</strong></th>\n<th><strong>CSR（如React/Vue SPA）</strong></th>\n<th><strong>SSR（如Next.js/Nuxt.js）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>HTML请求</strong></td>\n<td>返回空HTML骨架（<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>）</td>\n<td>返回完整渲染的HTML（含首屏内容）</td>\n</tr>\n<tr>\n<td><strong>资源加载</strong></td>\n<td>需下载JS/CSS后才开始渲染</td>\n<td>HTML直出，并行加载JS/CSS（流式渲染优化）</td>\n</tr>\n<tr>\n<td><strong>数据获取</strong></td>\n<td>客户端通过API二次请求（可能多次往返）</td>\n<td>服务器直接获取数据并注入HTML（减少客户端请求）</td>\n</tr>\n<tr>\n<td><strong>交互就绪时间</strong></td>\n<td>需等待JS解析执行完成后才能交互</td>\n<td>HTML可立即展示，但交互需等待JS水合（Hydration）完成</td>\n</tr>\n</tbody>\n</table>\n<p><strong>二、关键差异点详解</strong></p>\n<p><strong>1. 首屏性能</strong></p>\n<ul>\n<li><strong>CSR</strong>：\n<ul>\n<li><strong>TTFB（首字节时间）快</strong>：服务器仅返回空HTML。</li>\n<li><strong>FP（首次绘制）延迟</strong>：需等待JS下载执行后渲染内容，白屏时间长。</li>\n</ul>\n</li>\n<li><strong>SSR</strong>：\n<ul>\n<li><strong>FP/FCP（首次内容渲染）快</strong>：HTML直出，用户立即看到内容。</li>\n<li><strong>TTI（可交互时间）延迟</strong>：需等待JS水合完成后才能响应点击。</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. SEO友好性</strong></p>\n<ul>\n<li><strong>CSR</strong>：\n<ul>\n<li>传统SPA对搜索引擎爬虫不友好（早期爬虫不执行JS）。</li>\n<li>可通过预渲染（Prerender SPA Plugin）或动态渲染（Dynamic Rendering）补救。</li>\n</ul>\n</li>\n<li><strong>SSR</strong>：\n<ul>\n<li>天生友好，HTML直接包含完整内容（无需JS执行）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>3. 服务器压力</strong></p>\n<ul>\n<li><strong>CSR</strong>：\n<ul>\n<li>服务器仅提供静态资源和API，压力小。</li>\n</ul>\n</li>\n<li><strong>SSR</strong>：\n<ul>\n<li>每次请求需实时渲染页面，高并发下CPU负载高（需缓存优化）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>4. 开发体验</strong></p>\n<ul>\n<li><strong>CSR</strong>：\n<ul>\n<li>前后端完全解耦，前端可独立开发（Mock API）。</li>\n</ul>\n</li>\n<li><strong>SSR</strong>：\n<ul>\n<li>需处理同构代码（服务器与客户端兼容性），复杂度高（如<code>window</code>对象不存在于Node环境）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>三、选型决策矩阵</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>指标</strong></th>\n<th><strong>优先选择CSR</strong></th>\n<th><strong>优先选择SSR</strong></th>\n</tr>\n</thead>\n</table>\n","answer":""},{"title":"你知道哪些图标处理方案?","description":"","answer":"<p>以下是前端开发中常见的图标处理方案及其优缺点分析，结合了多种技术实现和工具推荐：</p>\n<p><strong>1. SVG Sprite</strong></p>\n<p><strong>原理</strong>：将多个 SVG 图标合并为一个文件，通过 <code>&lt;symbol&gt;</code> 定义图标模板，使用 <code>&lt;use&gt;</code> 引用具体图标。<br>\n<strong>优点</strong>：</p>\n<ul>\n<li><strong>矢量无损缩放</strong>：适配不同分辨率屏幕，不会失真。</li>\n<li><strong>样式可控</strong>：支持通过 CSS 修改颜色、大小、添加动画效果。</li>\n<li><strong>减少 HTTP 请求</strong>：单文件加载，提升性能。<br>\n<strong>缺点</strong>：</li>\n<li><strong>兼容性限制</strong>：IE9+ 及现代浏览器支持，旧版 IE 需 Polyfill。</li>\n<li><strong>复杂图形性能问题</strong>：渲染复杂 SVG 可能影响性能。</li>\n</ul>\n<p><strong>工具推荐</strong>：</p>\n<ul>\n<li>手动合并或使用构建工具（如 Gulp）自动化生成。</li>\n<li>示例代码：<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">svg</span><span style=\"color:#B07D48\"> style</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">display: none;</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">symbol</span><span style=\"color:#B07D48\"> id</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">icon-home</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> viewBox</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">0 0 32 32</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#1E754F\">path</span><span style=\"color:#B07D48\"> d</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">M16 1.333q2.99 0 5.703 1.161t4.677 3.125...</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">/></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;/</span><span style=\"color:#1E754F\">symbol</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">svg</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">svg</span><span style=\"color:#999999\">>&#x3C;</span><span style=\"color:#1E754F\">use</span><span style=\"color:#B07D48\"> xlink:href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">#icon-home</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">/>&#x3C;/</span><span style=\"color:#1E754F\">svg</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>2. 字体图标（Icon Font）</strong></p>\n<p><strong>原理</strong>：将矢量图标打包为字体文件，通过 CSS 类名引用 Unicode 字符。<br>\n<strong>优点</strong>：</p>\n<ul>\n<li><strong>兼容性强</strong>：支持 IE8+ 及现代浏览器。</li>\n<li><strong>灵活调整</strong>：通过 <code>font-size</code> 和 <code>color</code> 控制大小和颜色。</li>\n<li><strong>轻量高效</strong>：单字体文件替代多图片请求。<br>\n<strong>缺点</strong>：</li>\n<li><strong>仅支持单色</strong>：无法实现多色或渐变效果。</li>\n<li><strong>字体文件冗余</strong>：公共图标库包含未使用图标，增加体积。</li>\n</ul>\n<p><strong>工具推荐</strong>：</p>\n<ul>\n<li><strong>Icomoon</strong>：支持上传 SVG 并生成字体文件，提供在线编辑和云端管理。</li>\n<li><strong>阿里巴巴矢量图标库</strong>：丰富的免费图标资源，支持按需打包。</li>\n<li>示例代码：<pre><code class=\"language-css\"><div class=\"language-css \"><span class=\"lang\">css</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">@</span><span style=\"color:#1E754F\">font-face</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  font-family</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">iconfont</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  src</span><span style=\"color:#999999\">:</span><span style=\"color:#998418\"> url</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">iconfont.woff2</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span><span style=\"color:#998418\"> format</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">woff2</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">icon-home</span><span style=\"color:#999999\">::</span><span style=\"color:#B07D48\">before</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> content</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#A65E2B\">\\e600</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">;</span><span style=\"color:#999999\"> }</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">i</span><span style=\"color:#B07D48\"> class</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">iconfont icon-home</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">i</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>3. CSS Sprites（雪碧图）</strong></p>\n<p><strong>原理</strong>：将多个小图标合并为一张大图，通过 <code>background-position</code> 定位显示。<br>\n<strong>优点</strong>：</p>\n<ul>\n<li><strong>减少 HTTP 请求</strong>：单图加载提升性能。</li>\n<li><strong>兼容性好</strong>：支持所有浏览器，适合 PC 端。<br>\n<strong>缺点</strong>：</li>\n<li><strong>维护成本高</strong>：新增/修改图标需重新生成图片和 CSS。</li>\n<li><strong>适配性问题</strong>：高 DPR 屏幕需多套图，增加复杂度。</li>\n</ul>\n<p><strong>工具推荐</strong>：</p>\n<ul>\n<li><strong>Gulp 或 Webpack 插件</strong>：如 <code>gulp.spritesmith</code> 自动化生成雪碧图和 CSS。</li>\n<li>示例代码：<pre><code class=\"language-css\"><div class=\"language-css \"><span class=\"lang\">css</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">icon</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  background-image</span><span style=\"color:#999999\">:</span><span style=\"color:#998418\"> url</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">sprites.png</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  width</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 40</span><span style=\"color:#AB5959\">px</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  height</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 40</span><span style=\"color:#AB5959\">px</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">icon-home</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> background-position</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 0</span><span style=\"color:#2F798A\"> 0</span><span style=\"color:#999999\">;</span><span style=\"color:#999999\"> }</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>4. 内联 SVG</strong></p>\n<p><strong>原理</strong>：直接嵌入 SVG 代码到 HTML 中。<br>\n<strong>优点</strong>：</p>\n<ul>\n<li><strong>矢量无损</strong>：适配任意分辨率，支持多色和渐变。</li>\n<li><strong>交互性强</strong>：可通过 JavaScript 动态修改属性。<br>\n<strong>缺点</strong>：</li>\n<li><strong>代码冗余</strong>：重复使用相同图标时需多次嵌入 SVG。</li>\n<li><strong>SEO 不友好</strong>：大量内联代码可能影响页面结构。</li>\n</ul>\n<p><strong>优化方案</strong>：</p>\n<ul>\n<li><strong>SVG Sprites</strong>：通过 <code>&lt;symbol&gt;</code> 和 <code>&lt;use&gt;</code> 复用图标，减少重复代码。</li>\n<li>示例代码：<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">svg</span><span style=\"color:#B07D48\"> xmlns</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">http://www.w3.org/2000/svg</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> viewBox</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">0 0 24 24</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#1E754F\">path</span><span style=\"color:#B07D48\"> d</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">M12 2L2 12h3v8h6v-6h2v6h6v-8h3L12 2z</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">/></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;/</span><span style=\"color:#1E754F\">svg</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>5. Data URI（Base64 编码）</strong></p>\n<p><strong>原理</strong>：将图标转换为 Base64 字符串，直接嵌入 CSS 或 HTML。<br>\n<strong>优点</strong>：</p>\n<ul>\n<li><strong>减少 HTTP 请求</strong>：无需额外加载图片文件。</li>\n<li><strong>适合小图标</strong>：简化部署流程。<br>\n<strong>缺点</strong>：</li>\n<li><strong>增加文件体积</strong>：Base64 编码后体积增大约 30%。</li>\n<li><strong>无法缓存</strong>：重复使用时代码冗余。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>极小图标（如 1x1 像素分隔符）。</li>\n<li>示例代码：<pre><code class=\"language-css\"><div class=\"language-css \"><span class=\"lang\">css</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">icon</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  background</span><span style=\"color:#999999\">:</span><span style=\"color:#998418\"> url</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">data:image/svg+xml;base64,PHN2ZyB4bWxucz0ia...</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>6. UnoCSS 图标方案</strong></p>\n<p><strong>原理</strong>：通过原子化 CSS 框架（如 UnoCSS）直接引用图标库，无需生成字体或雪碧图。<br>\n<strong>优点</strong>：</p>\n<ul>\n<li><strong>零运行时开销</strong>：按需生成 CSS，体积极小。</li>\n<li><strong>灵活易用</strong>：通过类名直接调用图标，支持动态调整大小和颜色。<br>\n<strong>缺点</strong>：</li>\n<li><strong>依赖构建工具</strong>：需配置 Vite 或 Webpack 插件。</li>\n</ul>\n<p><strong>工具推荐</strong>：</p>\n<ul>\n<li><strong>UnoCSS 图标预设</strong>：集成 Iconify、Material Design 等图标库。</li>\n<li>示例代码：<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#B07D48\"> class</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">i-mdi-home text-2xl text-red-500</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>选型建议</strong></p>\n<ol>\n<li><strong>优先 SVG</strong>：现代项目首选 SVG Sprites 或内联 SVG，兼顾清晰度与灵活性。</li>\n<li><strong>兼容旧浏览器</strong>：使用字体图标（如 Icomoon）支持 IE8+。</li>\n<li><strong>性能敏感场景</strong>：CSS Sprites 或 Data URI 减少请求。</li>\n<li><strong>开发效率优先</strong>：UnoCSS 或现成图标库（如 Font Awesome）快速集成。</li>\n</ol>\n<p><strong>扩展阅读</strong>：</p>\n<ul>\n<li>多色图标处理可参考 Icomoon 的多路径支持。</li>\n<li>高 DPR 适配方案需结合 <code>srcset</code> 或媒体查询。</li>\n</ul>\n"},{"title":"Blob，ArrayBuffer，Base64 有什么区别？","description":"","answer":"<p>Blob、ArrayBuffer和Base64是在Web开发中处理二进制数据的不同表示和操作方式。</p>\n<ol>\n<li>Blob（Binary Large Object）： Blob是一种表示二进制数据的对象，可以存储大量的数据。它常用于处理文件、图像、音频和视频等媒体数据。Blob对象可以通过<code>new Blob()</code>构造函数创建，也可以从其他数据源（例如，通过XMLHttpRequest下载的数据）生成。Blob提供了一些方法和属性，用于读取和操作二进制数据。</li>\n<li>ArrayBuffer： ArrayBuffer是一种用于表示通用的二进制数据缓冲区的对象。它在内存中分配一块连续的、固定大小的原始二进制数据，并提供了一些方法和属性来读取和操作这些数据。ArrayBuffer不直接访问二进制数据，而是通过TypedArray视图或DataView对象来读写数据。</li>\n<li>Base64： Base64是一种将二进制数据转换为可打印字符的编码方式。它通过将二进制数据按照一定规则进行编码，生成由A-Z、a-z、0-9和一些特殊字符组成的字符串。Base64编码后的数据可以用于在文本协议中传输二进制数据，例如在网络请求中传递图片数据或在HTML中嵌入图片。</li>\n</ol>\n<p>区别：</p>\n<ul>\n<li>Blob和ArrayBuffer都是用于表示和处理二进制数据的对象，但Blob通常用于处理大量数据和文件，而ArrayBuffer用于处理更小粒度的数据。</li>\n<li>Blob对象提供了一些方法和属性，用于操作和读取二进制数据，而ArrayBuffer本身并不直接提供数据访问方法，需要通过TypedArray视图或DataView对象来读写数据。</li>\n<li>Base64是一种编码方式，用于将二进制数据转换为可打印字符，以便在文本协议中传输。Base64编码后的数据可以作为字符串进行处理，而Blob和ArrayBuffer是二进制数据的对象表示。</li>\n</ul>\n<p>需要根据具体的使用场景和需求选择适合的数据表示和处理方式。</p>\n"},{"title":"常见的登录鉴权方式有哪些？","description":"","answer":"<ol>\n<li><strong>Cookie + Session</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：用户登录后，服务器创建一个 <code>Session</code>，将用户信息存储在服务器端，同时生成一个唯一的 <code>SessionID</code>，并将其以 <code>Cookie</code> 的形式发送给客户端。客户端之后的每次请求都携带该 <code>Cookie</code>，服务器用 <code>SessionID</code> 确认用户身份。</li>\n<li><strong>优点</strong>：服务器管理会话状态，安全性较高；可以设置短期有效期，适合敏感信息。</li>\n<li><strong>缺点</strong>：会消耗服务器内存，难以扩展；需跨域配置。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>JWT（JSON Web Token）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：登录成功后，服务器生成一个加密的 <code>JWT</code>，该令牌包含用户信息或标识，发送给客户端。之后的请求，客户端携带该 <code>JWT</code>，服务器通过验证 <code>JWT</code> 的签名来确认用户身份。</li>\n<li><strong>优点</strong>：无状态、可跨域，适合分布式架构；可携带信息，支持用户角色验证。</li>\n<li><strong>缺点</strong>：令牌较长，增加请求负担；一旦泄露容易被滥用。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>OAuth</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：OAuth 是一种授权协议，用户通过第三方平台（如 Google、Facebook）登录，将权限授予该平台来访问某些资源。OAuth 2.0 使用 <code>Access Token</code> 访问受保护资源，<code>Refresh Token</code> 则用于获取新的 <code>Access Token</code>。</li>\n<li><strong>优点</strong>：用户体验好，适用于第三方应用授权登录；支持多级权限。</li>\n<li><strong>缺点</strong>：流程复杂，难以实现；<code>Token</code> 可能泄露或失效。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>SAML（Security Assertion Markup Language）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：SAML 是基于 XML 的单点登录协议，通常用于企业系统中。用户请求通过 SAML 协议在多个系统之间共享认证状态，允许用户在不重新登录的情况下访问其他应用。</li>\n<li><strong>优点</strong>：适用于企业内部系统间的统一登录；支持跨域。</li>\n<li><strong>缺点</strong>：复杂度高，基于 XML 的消息传递效率低。</li>\n</ul>\n<ol start=\"5\">\n<li><strong>SSO（Single Sign-On）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：单点登录允许用户使用一个登录凭据访问多个应用或系统。常用的实现方案包括基于 OAuth、SAML 或 CAS（Central Authentication Service）。</li>\n<li><strong>优点</strong>：提高用户体验，避免多次登录；适用于多系统集成。</li>\n<li><strong>缺点</strong>：一旦账户泄露，多个系统都会受到威胁。</li>\n</ul>\n<ol start=\"6\">\n<li><strong>基于短信或邮件的 OTP（一次性密码）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：用户登录时接收一个一次性密码（通常通过短信或邮件发送），有效期较短。用户输入正确的 OTP 后，即可完成登录。</li>\n<li><strong>优点</strong>：安全性高，适合敏感操作的二次验证。</li>\n<li><strong>缺点</strong>：需要借助短信或邮件服务，成本较高。</li>\n</ul>\n<ol start=\"7\">\n<li><strong>指纹、面部识别等生物识别</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：利用设备上的生物识别传感器进行身份认证，例如指纹、面部识别等。通常用于设备级别的解锁，或结合其他鉴权方式进行身份确认。</li>\n<li><strong>优点</strong>：用户体验佳、难以复制；适合移动设备的安全验证。</li>\n<li><strong>缺点</strong>：设备依赖性强；难以在 web 应用中普遍使用。</li>\n</ul>\n"},{"title":"ChatGPT 的对话功能实现，为什么选择 SSE 协议而非 Websocket ？","description":"","answer":"<p>ChatGPT 的对话功能实现选择 Server-Sent Events (SSE) 协议而非 WebSocket，主要是基于两者在使用场景和实现复杂度上的差异。</p>\n<p>以下是原因分析：</p>\n<ol>\n<li>数据流单向性适合 SSE：\nSSE 是单向的：SSE 是由服务器主动推送消息到客户端的单向数据流协议，客户端只需要接收服务器传来的消息。这种模式适合像 ChatGPT 这样的应用场景，因为用户请求发送到服务器后，服务器只需要持续向客户端推送生成的对话数据。客户端没有必要频繁地向服务器发送数据（除了初次请求）。\nWebSocket 是双向的：WebSocket 是全双工通信协议，允许客户端和服务器互相发送消息。虽然 WebSocket 功能更强大，但 ChatGPT 场景中并不需要客户端和服务器之间的高频双向通信。</li>\n<li>实现和维护复杂度：\nSSE 简单易用：SSE 只需要服务器推送消息，客户端可以通过标准的 EventSource API 轻松接收消息，并且基于 HTTP 协议实现。无需像 WebSocket 那样进行复杂的连接握手和状态管理。这使得 SSE 在实现和维护上相对简单。\nWebSocket 较复杂：WebSocket 在建立连接时需要进行协议升级，并且要管理双向通信，增加了复杂度。尤其在某些代理、防火墙等网络环境中，WebSocket 的握手和长连接更容易遇到阻碍。</li>\n<li>兼容性和可靠性：\nSSE 通过 HTTP/1.1 实现：SSE 是基于 HTTP/1.1 的长连接协议，通常能够更好地穿透代理服务器、防火墙等网络设施。这在需要保证消息推送可靠性时非常重要。\nWebSocket 需要协议升级：WebSocket 需要从 HTTP 升级到 WebSocket 协议 (ws 或 wss)，某些网络环境可能会阻断这种升级过程，从而影响连接的可靠性。</li>\n<li>自动重连和消息重发：\nSSE 提供自动重连功能：如果网络中断或连接丢失，SSE 会自动尝试重连，且服务器可以通过 Last-Event-ID 实现消息重发，从而保证消息不会丢失。\nWebSocket 重连复杂：WebSocket 需要自行实现重连逻辑和消息重发功能，增加了开发的复杂度和维护成本。</li>\n<li>使用场景的适配性：\nSSE 适合较低频的消息推送：SSE 适用于不需要高频交互、消息量适中但要求可靠推送的应用场景，如实时通知、数据流等。ChatGPT 的对话功能正符合这种情况，消息从服务器按需推送到客户端即可。\nWebSocket 适合高频双向通信：WebSocket 更适合需要双向、低延迟、高频数据交互的应用场景，比如在线游戏、实时协作工具等。ChatGPT 的场景则不需要这种双向高频通信。</li>\n<li>资源效率和性能：\nSSE 使用较少的资源：SSE 是通过 HTTP 长连接传输数据，资源消耗较少，尤其是在只需要单向通信的场景中，避免了 WebSocket 双向通信带来的额外负载。\nWebSocket 性能较优但资源消耗大：WebSocket 在高频双向通信时有更高的性能，但对于像 ChatGPT 这种场景，其双向通信能力未被充分利用，反而会增加资源开销。</li>\n</ol>\n"},{"title":"Redux 和 Vuex 的设计思想是什么？","description":"","answer":"<p>Redux 和 Vuex 都是用于状态管理的库，分别用于 React 和 Vue 框架。它们的设计思想在许多方面有相似之处，但也有各自的独特之处。</p>\n<p>下面是对 Redux 和 Vuex 设计思想的详细比较：</p>\n<p><strong>Redux</strong></p>\n<p><strong>设计思想</strong>：</p>\n<ol>\n<li><strong>单一数据源</strong>：\n<ul>\n<li>Redux 强调应用的所有状态都集中在一个单一的 <code>store</code> 中。这个设计简化了状态的管理和调试。</li>\n</ul>\n</li>\n<li><strong>状态不可变性</strong>：\n<ul>\n<li>Redux 采用不可变数据结构，每次状态的变化都会创建一个新的状态对象，而不是直接修改原有状态。这有助于追踪状态的变化并实现高效的 UI 渲染。</li>\n</ul>\n</li>\n<li><strong>纯函数（Reducers）</strong>：\n<ul>\n<li>状态的更新由纯函数（称为 reducers）负责。纯函数意味着相同的输入始终产生相同的输出，不依赖于外部状态或副作用。</li>\n</ul>\n</li>\n<li><strong>单向数据流</strong>：\n<ul>\n<li>Redux 遵循单向数据流的原则。数据流动的方向是：<code>action</code> -&gt; <code>reducer</code> -&gt; <code>store</code> -&gt; 视图。通过这种方式，可以明确跟踪数据的变化和流动。</li>\n</ul>\n</li>\n<li><strong>中间件</strong>：\n<ul>\n<li>Redux 支持中间件的机制，可以在 <code>dispatch</code> 和 <code>reducer</code> 之间插入逻辑。这对于处理异步操作和其他副作用很有用。</li>\n</ul>\n</li>\n<li><strong>可预测的状态管理</strong>：\n<ul>\n<li>Redux 的设计使得状态变化变得可预测。状态变化的逻辑集中在 reducers 中，可以通过 action 和 reducer 组合跟踪状态的变化。</li>\n</ul>\n</li>\n</ol>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>适用于大型应用或复杂状态管理场景。适合需要高度可控和可预测状态的应用。</li>\n</ul>\n<p><strong>Vuex</strong></p>\n<p><strong>设计思想</strong>：</p>\n<ol>\n<li><strong>集中式存储</strong>：\n<ul>\n<li>Vuex 提供集中式的状态管理，所有组件的状态都存储在一个全局的 <code>store</code> 中，保证应用的状态集中管理。</li>\n</ul>\n</li>\n<li><strong>状态、变更和行动分离</strong>：\n<ul>\n<li>Vuex 将状态（state）、变更（mutations）、和行动（actions）进行明确的分离。状态是存储的状态，变更通过同步的 mutation 进行，异步操作通过 actions 进行。</li>\n</ul>\n</li>\n<li><strong>Mutation 必须是同步的</strong>：\n<ul>\n<li>Vuex 强调 mutation 函数必须是同步的，所有状态的更改都必须通过 mutation，这保证了状态更改的可追踪性和调试性。</li>\n</ul>\n</li>\n<li><strong>状态可追踪</strong>：\n<ul>\n<li>通过 Vuex 的 <code>store</code> 结构，可以清晰地跟踪状态的变化和应用的状态。</li>\n</ul>\n</li>\n<li><strong>Getter 函数</strong>：\n<ul>\n<li>Vuex 提供 getter 函数，允许计算状态的派生数据。它类似于 Vue 的计算属性，用于从 store 的状态派生出新的数据。</li>\n</ul>\n</li>\n<li><strong>插件系统</strong>：\n<ul>\n<li>Vuex 支持插件，可以扩展 Vuex 的功能，例如日志记录、持久化存储等。</li>\n</ul>\n</li>\n</ol>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>适用于 Vue.js 应用，特别是中大型应用。适合需要集中式状态管理的场景。</li>\n</ul>\n"},{"title":"什么是 Electron？它用于什么场景？","description":"<p><strong>一句话总结</strong></p>\n<p><strong>Electron 是一个基于 Chromium 和 Node.js 的框架，允许使用 HTML/CSS/JavaScript 构建跨平台桌面应用，融合了 Web 的灵活性与 Native 的系统级能力。</strong></p>\n<p><strong>核心原理</strong></p>\n<ol>\n<li>\n<p><strong>双进程架构</strong>：</p>\n<ul>\n<li><strong>主进程（Main Process）</strong>：运行 Node.js，负责窗口管理、系统 API 调用（如文件操作、菜单栏）。</li>\n<li><strong>渲染进程（Renderer Process）</strong>：运行 Chromium，渲染 Web 页面（每个窗口独立进程），通过 IPC 与主进程通信。</li>\n</ul>\n</li>\n<li>\n<p><strong>技术栈整合</strong>：</p>\n<ul>\n<li><strong>Chromium</strong>：提供 Web 渲染引擎，支持现代 CSS/JS 特性。</li>\n<li><strong>Node.js</strong>：访问操作系统 API（如文件系统、网络、硬件）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>适用场景</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>场景</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>典型案例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>跨平台桌面应用</strong></td>\n<td>一次开发，编译 Windows/macOS/Linux 三端应用，减少维护成本</td>\n<td><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener noreferrer\">VS Code</a>、<a href=\"https://slack.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Slack</a></td>\n</tr>\n<tr>\n<td><strong>需要 Native 能力的 Web 应用</strong></td>\n<td>突破浏览器沙箱限制，调用系统 API（如托盘图标、通知、剪贴板）</td>\n<td><a href=\"https://www.figma.com/downloads/\" target=\"_blank\" rel=\"noopener noreferrer\">Figma 桌面版</a>、<a href=\"https://www.postman.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Postman</a></td>\n</tr>\n<tr>\n<td><strong>快速原型开发</strong></td>\n<td>前端团队复用技术栈快速验证桌面端想法，无需学习 C++/C# 等 Native 语言</td>\n<td>内部工具、数据可视化平台</td>\n</tr>\n<tr>\n<td><strong>混合型应用</strong></td>\n<td>结合 Web UI 和 Native 模块（如 C++ 插件）处理高性能任务（如音视频编解码）</td>\n<td><a href=\"https://discord.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Discord</a>、<a href=\"https://www.twitch.tv/\" target=\"_blank\" rel=\"noopener noreferrer\">Twitch</a></td>\n</tr>\n</tbody>\n</table>\n<p><strong>优缺点分析</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n</tr>\n</thead>\n</table>\n","answer":""},{"title":"如何在前端中集成 WebAssembly？","description":"<p><strong>前端集成 WebAssembly 的核心步骤与最佳实践</strong></p>\n<p>WebAssembly（Wasm）允许将高性能的 C/C++/Rust 代码运行在浏览器中，与 JavaScript 无缝交互。以下是集成方案与优化策略：</p>\n<p><strong>一、核心集成流程</strong></p>\n<p><strong>1. 编译 Wasm 模块</strong></p>\n<ul>\n<li>\n<p><strong>C/C++ 示例（使用 Emscripten）</strong>：</p>\n<pre><code class=\"language-shell\"><div class=\"language-shell \"><span class=\"lang\">shell</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\"># 安装 Emscripten</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">git</span><span style=\"color:#B56959\"> clone</span><span style=\"color:#B56959\"> https://github.com/emscripten-core/emsdk.git</span></span>\n<span class=\"line\"><span style=\"color:#998418\">cd</span><span style=\"color:#B56959\"> emsdk</span><span style=\"color:#999999\"> &#x26;&#x26;</span><span style=\"color:#59873A\"> ./emsdk</span><span style=\"color:#B56959\"> install</span><span style=\"color:#B56959\"> latest</span><span style=\"color:#999999\"> &#x26;&#x26;</span><span style=\"color:#59873A\"> ./emsdk</span><span style=\"color:#B56959\"> activate</span><span style=\"color:#B56959\"> latest</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\"># 编译 C 代码为 Wasm</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">emcc</span><span style=\"color:#B56959\"> fibonacci.c</span><span style=\"color:#A65E2B\"> -O3</span><span style=\"color:#A65E2B\"> -s</span><span style=\"color:#B56959\"> WASM=</span><span style=\"color:#2F798A\">1</span><span style=\"color:#A65E2B\"> -o</span><span style=\"color:#B56959\"> fibonacci.js</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// JavaScript 调用</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> Module</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> require</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">./fibonacci.js</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">Module</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">onRuntimeInitialized</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">  console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">log</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">Module</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">_fibonacci</span><span style=\"color:#999999\">(</span><span style=\"color:#2F798A\">10</span><span style=\"color:#999999\">));</span><span style=\"color:#A0ADA0\"> // 调用 C 函数</span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>Rust 示例（使用 wasm-pack）</strong>：</p>\n<pre><code class=\"language-shell\"><div class=\"language-shell \"><span class=\"lang\">shell</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\"># 创建 Rust 库</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">cargo</span><span style=\"color:#B56959\"> new</span><span style=\"color:#A65E2B\"> --lib</span><span style=\"color:#B56959\"> wasm-lib</span><span style=\"color:#999999\"> &#x26;&#x26;</span><span style=\"color:#998418\"> cd</span><span style=\"color:#B56959\"> wasm-lib</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">wasm-pack</span><span style=\"color:#B56959\"> build</span><span style=\"color:#A65E2B\"> --target</span><span style=\"color:#B56959\"> web</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// JavaScript 调用</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">import</span><span style=\"color:#B07D48\"> init</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span><span style=\"color:#B07D48\"> add</span><span style=\"color:#999999\"> }</span><span style=\"color:#1E754F\"> from</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">./wasm-lib/pkg/wasm_lib.js</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">await</span><span style=\"color:#59873A\"> init</span><span style=\"color:#999999\">();</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">log</span><span style=\"color:#999999\">(</span><span style=\"color:#59873A\">add</span><span style=\"color:#999999\">(</span><span style=\"color:#2F798A\">2</span><span style=\"color:#999999\">,</span><span style=\"color:#2F798A\"> 3</span><span style=\"color:#999999\">));</span><span style=\"color:#A0ADA0\"> // 输出 5</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>2. 在 HTML/JavaScript 中加载</strong></p>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">  // 加载并实例化 Wasm</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">  WebAssembly</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">instantiateStreaming</span><span style=\"color:#999999\">(</span><span style=\"color:#59873A\">fetch</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">module.wasm</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">),</span><span style=\"color:#B07D48\"> importObject</span><span style=\"color:#999999\">)</span></span>\n<span class=\"line\"><span style=\"color:#999999\">    .</span><span style=\"color:#59873A\">then</span><span style=\"color:#999999\">(({</span><span style=\"color:#B07D48\"> instance</span><span style=\"color:#999999\"> })</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">      instance</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">exportedFunction</span><span style=\"color:#999999\">();</span></span>\n<span class=\"line\"><span style=\"color:#999999\">    });</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>二、数据交互与内存管理</strong></p>\n<p><strong>1. 共享内存（线性内存）</strong></p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 创建共享内存</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> memory</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> new</span><span style=\"color:#B07D48\"> WebAssembly</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">Memory</span><span style=\"color:#999999\">({</span><span style=\"color:#998418\"> initial</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 256</span><span style=\"color:#999999\"> });</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> buffer</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> new</span><span style=\"color:#59873A\"> Uint8Array</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">memory</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">buffer</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 传递指针给 Wasm</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">instance</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">processData</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">buffer</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">byteOffset</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>2. 字符串处理</strong></p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// JavaScript 到 Wasm</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> str</span><span style=\"color:#999999\"> =</span><span style=\"color:#B5695977\"> \"</span><span style=\"color:#B56959\">Hello</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> encoder</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> new</span><span style=\"color:#59873A\"> TextEncoder</span><span style=\"color:#999999\">();</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> encoded</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> encoder</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">encode</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">str</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> ptr</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> instance</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">alloc</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">encoded</span><span style=\"color:#999999\">.</span><span style=\"color:#998418\">length</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">new</span><span style=\"color:#59873A\"> Uint8Array</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">memory</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">buffer</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> ptr</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> encoded</span><span style=\"color:#999999\">.</span><span style=\"color:#998418\">length</span><span style=\"color:#999999\">).</span><span style=\"color:#59873A\">set</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">encoded</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// Wasm 到 JavaScript</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> decoder</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> new</span><span style=\"color:#59873A\"> TextDecoder</span><span style=\"color:#999999\">();</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> outputPtr</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> instance</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">getResult</span><span style=\"color:#999999\">();</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> outputLength</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> instance</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">getResultLength</span><span style=\"color:#999999\">();</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> result</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> decoder</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">decode</span><span style=\"color:#999999\">(</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  new</span><span style=\"color:#59873A\"> Uint8Array</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">memory</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">buffer</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> outputPtr</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> outputLength</span><span style=\"color:#999999\">)</span></span>\n<span class=\"line\"><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>三、性能优化策略</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>优化方向</strong></th>\n<th><strong>具体措施</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>减少内存拷贝</strong></td>\n<td>使用共享内存传递大数组，避免 JS 与 Wasm 间复制数据</td>\n</tr>\n<tr>\n<td><strong>并行化计算</strong></td>\n<td>结合 Web Workers 实现多线程（需 Wasm 支持线程）</td>\n</tr>\n<tr>\n<td><strong>SIMD 加速</strong></td>\n<td>启用 WebAssembly SIMD 指令集（如 <code>-msimd128</code> 编译选项）</td>\n</tr>\n<tr>\n<td><strong>模块缓存</strong></td>\n<td>IndexedDB 存储已编译的 Wasm 模块，加速二次加载</td>\n</tr>\n</tbody>\n</table>\n<p><strong>四、工具链与框架集成</strong></p>\n<p><strong>1. 现代构建工具</strong></p>\n<ul>\n<li><strong>Webpack</strong>：通过 <code>wasm-loader</code> 直接导入 Wasm 文件<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// webpack.config.js</span></span>\n<span class=\"line\"><span style=\"color:#998418\">module</span><span style=\"color:#999999\">.</span><span style=\"color:#998418\">exports</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  module</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">    rules</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [{</span><span style=\"color:#998418\"> test</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> /</span><span style=\"color:#BDA437\">\\.</span><span style=\"color:#AB5E3F\">wasm</span><span style=\"color:#1E754F\">$</span><span style=\"color:#B5695977\">/</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> type</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">webassembly/async</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\"> }]</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  },</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  experiments</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> asyncWebAssembly</span><span style=\"color:#999999\">:</span><span style=\"color:#1E754F\"> true</span><span style=\"color:#999999\"> }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li><strong>Vite</strong>：原生支持 <code>.wasm</code> 文件导入<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#1E754F\">import</span><span style=\"color:#B07D48\"> init</span><span style=\"color:#1E754F\"> from</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">./lib.wasm</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">init</span><span style=\"color:#999999\">().</span><span style=\"color:#59873A\">then</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\"> =></span><span style=\"color:#998418\"> exports</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">run</span><span style=\"color:#999999\">());</span><span style=\"color:#AB5959\">**</span><span style=\"color:#2F798A\">2.</span><span style=\"color:#B07D48\"> 框架封装示例</span><span style=\"color:#393A34\">（</span><span style=\"color:#B07D48\">React</span><span style=\"color:#393A34\">）</span><span style=\"color:#AB5959\">**</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// useWasm hook</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">import</span><span style=\"color:#999999\"> {</span><span style=\"color:#B07D48\"> useEffect</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> useState</span><span style=\"color:#999999\"> }</span><span style=\"color:#1E754F\"> from</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">react</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> useWasm</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">url</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  const</span><span style=\"color:#999999\"> [</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> setExports</span><span style=\"color:#999999\">]</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> useState</span><span style=\"color:#999999\">(</span><span style=\"color:#AB5959\">null</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  useEffect</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    WebAssembly</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">instantiateStreaming</span><span style=\"color:#999999\">(</span><span style=\"color:#59873A\">fetch</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">url</span><span style=\"color:#999999\">))</span></span>\n<span class=\"line\"><span style=\"color:#999999\">      .</span><span style=\"color:#59873A\">then</span><span style=\"color:#999999\">(({</span><span style=\"color:#B07D48\"> instance</span><span style=\"color:#999999\"> })</span><span style=\"color:#999999\"> =></span><span style=\"color:#59873A\"> setExports</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">instance</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">exports</span><span style=\"color:#999999\">));</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  },</span><span style=\"color:#999999\"> [</span><span style=\"color:#B07D48\">url</span><span style=\"color:#999999\">]);</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#998418\"> exports</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 组件中使用</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> ImageProcessor</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  const</span><span style=\"color:#B07D48\"> wasm</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> useWasm</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">/image.wasm</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  const</span><span style=\"color:#59873A\"> processImage</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#B07D48\"> wasm</span><span style=\"color:#999999\">?.</span><span style=\"color:#59873A\">filter</span><span style=\"color:#999999\">(</span><span style=\"color:#A0ADA0\">/*...*/</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#999999\"> &#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#B07D48\"> onClick</span><span style=\"color:#999999\">={</span><span style=\"color:#B07D48\">processImage</span><span style=\"color:#999999\">}></span><span style=\"color:#393A34\">处理图片</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">>;</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>五、调试与错误处理</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>工具/方法</strong></th>\n<th><strong>用途</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>浏览器 DevTools</strong></td>\n<td>Sources 面板调试 Wasm（需启用 <strong>Debug Symbols</strong> <code>-g</code> 编译）</td>\n</tr>\n<tr>\n<td><strong>Console 日志</strong></td>\n<td>通过 <code>console.log</code> 包装函数在 Wasm 中输出调试信息</td>\n</tr>\n<tr>\n<td><strong>错误边界（React）</strong></td>\n<td>捕获 Wasm 模块加载失败时的 UI 降级</td>\n</tr>\n</tbody>\n</table>\n<p><strong>六、典型应用场景</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>场景</strong></th>\n<th><strong>技术方案</strong></th>\n<th><strong>案例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>图像处理</strong></td>\n<td>使用 Wasm 加速滤镜/压缩算法（如 libjpeg-turbo）</td>\n<td>Squoosh（Google 图片优化工具）</td>\n</tr>\n<tr>\n<td><strong>游戏引擎</strong></td>\n<td>物理引擎/3D 计算（如 Unity WebGL 导出）</td>\n<td>Figma 设计工具中的渲染优化</td>\n</tr>\n<tr>\n<td><strong>加密计算</strong></td>\n<td>高性能加密算法（如 AES-256）</td>\n<td>区块链钱包前端</td>\n</tr>\n<tr>\n<td><strong>音视频编解码</strong></td>\n<td>FFmpeg 编译为 Wasm 处理流媒体</td>\n<td>Zoom 网页客户端</td>\n</tr>\n</tbody>\n</table>\n<p><strong>七、安全与兼容性</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>策略</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n</table>\n","answer":""},{"title":"请谈谈你对 GraphQL 的理解","description":"<p>GraphQL 是一种由 Facebook 开发的 <strong>API 查询语言和运行时</strong>，通过声明式数据获取和强类型 Schema 定义，解决 RESTful API 的**过度获取（Over-fetching）<strong>与</strong>不足获取（Under-fetching）**问题，提升前后端协作效率。</p>\n<p><strong>核心理解与优势</strong></p>\n<p><strong>一、对比 RESTful API 的核心优势</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>痛点</strong></th>\n<th><strong>RESTful 方案</strong></th>\n<th><strong>GraphQL 方案</strong></th>\n</tr>\n</thead>\n</table>\n","answer":""},{"title":"数据Mock是什么？","description":"","answer":""},{"title":"debugger 是做什么的？你平时如何调试程序？","description":"","answer":""},{"title":"前端加密算法有哪些？","description":"","answer":""},{"title":"前端领域有哪些跨端方案？","description":"","answer":""},{"title":"说说你对 flutter 的了解","description":"","answer":""}]