[{"title":"谈一谈你对前端框架的理解?","answer":"<p>前端框架（如Vue/React）是<strong>高效构建用户界面</strong>的工具，核心价值在于：</p>\n<ol>\n<li><strong>组件化开发</strong>：\n<ul>\n<li>将UI拆分为独立、可复用的组件，提升代码复用性与可维护性。</li>\n</ul>\n</li>\n<li><strong>数据驱动视图</strong>：\n<ul>\n<li>通过响应式或虚拟DOM机制，数据变化自动更新视图，减少手动DOM操作。</li>\n</ul>\n</li>\n<li><strong>生态整合</strong>：\n<ul>\n<li>提供路由（Vue Router/React Router）、状态管理（Pinia/Redux）、构建工具（Vite/Webpack）等完整开发链路支持。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>：\n<ul>\n<li>虚拟DOM Diff算法、SSR服务端渲染、代码分割等优化手段，提升应用性能。</li>\n</ul>\n</li>\n</ol>\n<p><strong>解决的问题</strong>：</p>\n<ul>\n<li>传统开发中手动操作DOM的低效与复杂度；</li>\n<li>大规模应用下代码组织混乱、维护困难；</li>\n<li>跨团队协作规范不统一。</li>\n</ul>\n"},{"title":"谈谈对 MVC、MVP、MVVM 模式的理解？","answer":"<p><strong>1. MVC（Model-View-Controller）</strong></p>\n<ul>\n<li><strong>组成</strong>：\n<ul>\n<li><strong>Model</strong>：管理数据和业务逻辑。</li>\n<li><strong>View</strong>：负责 UI 展示。</li>\n<li><strong>Controller</strong>：接收用户输入，更新 Model，并通知 View 更新。</li>\n</ul>\n</li>\n<li><strong>交互</strong>：\n<ul>\n<li>用户操作 → <strong>Controller</strong> → 更新 Model → <strong>View</strong> 监听 Model 变化并渲染。</li>\n</ul>\n</li>\n<li><strong>特点</strong>：\n<ul>\n<li>View 可直接访问 Model，导致<strong>双向依赖</strong>（如观察者模式），耦合度较高。</li>\n<li>典型应用：传统后端框架（如 Spring MVC）、早期前端框架。</li>\n</ul>\n</li>\n<li><strong>问题</strong>：View 和 Model 的强耦合可能导致代码维护困难。</li>\n</ul>\n<p><strong>2. MVP（Model-View-Presenter）</strong></p>\n<ul>\n<li><strong>组成</strong>：\n<ul>\n<li><strong>Model</strong>：同 MVC，管理数据。</li>\n<li><strong>View</strong>：被动 UI，仅定义界面结构和触发事件。</li>\n<li><strong>Presenter</strong>：中介者，处理业务逻辑，更新 Model 并控制 View。</li>\n</ul>\n</li>\n<li><strong>交互</strong>：\n<ul>\n<li>用户操作 → <strong>View</strong> → 通知 Presenter → 更新 Model → Presenter 更新 View。</li>\n</ul>\n</li>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>View 与 Model 完全解耦</strong>，所有逻辑集中在 Presenter。</li>\n<li>更易测试（Mock View 即可测试 Presenter）。</li>\n<li>典型应用：桌面应用（如 Android 早期开发）。</li>\n</ul>\n</li>\n<li><strong>问题</strong>：Presenter 可能变得臃肿，需手动同步 View 和 Model。</li>\n</ul>\n<p><strong>3. MVVM（Model-View-ViewModel）</strong></p>\n<ul>\n<li><strong>组成</strong>：\n<ul>\n<li><strong>Model</strong>：数据层。</li>\n<li><strong>View</strong>：UI 展示。</li>\n<li><strong>ViewModel</strong>：通过数据绑定（Data Binding）连接 View 和 Model，暴露命令和状态。</li>\n</ul>\n</li>\n<li><strong>交互</strong>：\n<ul>\n<li><strong>双向绑定</strong>：View 的输入自动更新 ViewModel，ViewModel 变化自动同步到 View。</li>\n<li><strong>数据驱动</strong>：Model 变化 → ViewModel 更新 → View 自动渲染（如 Vue/React）。</li>\n</ul>\n</li>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>低耦合</strong>：View 不直接操作 Model，通过 ViewModel 代理。</li>\n<li><strong>高效开发</strong>：减少手动 DOM 操作（如 Vue 的 <code>v-model</code>）。</li>\n<li>典型应用：现代前端框架（Vue.js、React + MobX）。</li>\n</ul>\n</li>\n<li><strong>问题</strong>：过度依赖数据绑定可能导致调试困难或性能问题（如大型列表渲染）。</li>\n</ul>\n<p><strong>对比总结</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">模式</th>\n<th style=\"text-align:left\">核心思想</th>\n<th style=\"text-align:left\">通信方式</th>\n<th style=\"text-align:left\">适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>MVC</strong></td>\n<td style=\"text-align:left\">分层解耦，View 直接依赖 Model</td>\n<td style=\"text-align:left\">多向通信（可能循环依赖）</td>\n<td style=\"text-align:left\">传统后端、简单前端应用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>MVP</strong></td>\n<td style=\"text-align:left\">Presenter 解耦 View 和 Model</td>\n<td style=\"text-align:left\">单向通信（View ↔ Presenter ↔ Model）</td>\n<td style=\"text-align:left\">桌面应用、需要高测试性的场景</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>MVVM</strong></td>\n<td style=\"text-align:left\">数据绑定自动同步，ViewModel 代理逻辑</td>\n<td style=\"text-align:left\">双向绑定（View ↔ ViewModel ↔ Model）</td>\n<td style=\"text-align:left\">现代前端框架（如 Vue、Angular）</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"说说你对SPA（单页应用）的理解?","answer":"<p>SPA（单页应用）是指<strong>通过前端路由动态渲染内容</strong>的 Web 应用，其核心特点是：</p>\n<ol>\n<li><strong>单次加载</strong>：首次访问加载完整 HTML、CSS 和 JS，后续页面切换通过 AJAX/API 获取数据，客户端动态更新 DOM，无需整页刷新。</li>\n<li><strong>前端路由</strong>：利用 <code>history API</code> 或 <code>hash</code> 实现 URL 变化与视图匹配，保持用户体验流畅性（如 Vue Router、React Router）。</li>\n<li><strong>优点</strong>：\n<ul>\n<li>交互流畅，接近原生应用体验；</li>\n<li>减轻服务器压力，前后端分离开发；</li>\n<li>支持复杂状态管理（如 Redux、Pinia）。</li>\n</ul>\n</li>\n<li><strong>挑战</strong>：\n<ul>\n<li><strong>SEO 不友好</strong>：传统爬虫难以抓取动态内容（可通过 SSR/SSG 优化）；</li>\n<li><strong>首屏性能</strong>：资源加载较慢（需代码分割、懒加载优化）；</li>\n<li><strong>内存管理</strong>：长期运行需警惕内存泄漏。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"SPA（单页应用）首屏加载速度慢怎么解决？","answer":"<ol>\n<li><strong>代码分割 + 懒加载</strong>：\n<ul>\n<li>用<code>import()</code>动态导入路由组件（Vue Router的<code>component: () =&gt; import('...')</code>），按需加载。</li>\n<li>使用Webpack的<code>SplitChunksPlugin</code>拆分公共代码和第三方库（如Vue、Vuex）。</li>\n</ul>\n</li>\n<li><strong>资源优化</strong>：\n<ul>\n<li>压缩JS/CSS（Terser、CSSNano）、图片转WebP/AVIF格式或用懒加载。</li>\n<li>开启Gzip/Brotli压缩（服务器配置）。</li>\n</ul>\n</li>\n<li><strong>预渲染（Prerender）或SSR</strong>：\n<ul>\n<li>对静态页面用<code>prerender-spa-plugin</code>预生成HTML，直接返回给用户。</li>\n<li>复杂场景用服务端渲染（如Nuxt.js），首屏直出HTML。</li>\n</ul>\n</li>\n<li><strong>CDN加速静态资源</strong>：\n<ul>\n<li>将第三方库（如Vue、lodash）通过CDN引入，减少打包体积。</li>\n</ul>\n</li>\n<li><strong>优化首屏关键资源</strong>：\n<ul>\n<li>内联关键CSS，异步加载非必要JS（如<code>async</code>/<code>defer</code>）。</li>\n<li>使用骨架屏（Skeleton）过渡，提升用户体验。</li>\n</ul>\n</li>\n<li><strong>缓存策略</strong>：\n<ul>\n<li>强缓存（Cache-Control）、协商缓存（ETag）减少重复请求。</li>\n<li>Service Worker做离线缓存（PWA）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>工具辅助</strong>：用Lighthouse分析性能瓶颈，针对性优化。</p>\n"},{"title":"常⻅兼容性问题","answer":"<p><a href=\"https://juejin.cn/post/7067808335034220574\">前端开发中常见的浏览器兼容性问题及解决方案大汇总</a></p>\n"},{"title":"HTML中的attribute属性和JavaScript中的property属性的详解以及区别","answer":"<p><strong>attribute</strong>：是HTML标签上的某个属性，如id、class、value等以及自定义属性，它的值只能是字符串，关于这个属性一共有三个相关的方法，setAttribute、getAttribute、removeAttribute；\n<strong>property</strong>：是js获取的DOM对象上的属性值，比如a，你可以将它看作为一个基本的js对象。这个节点包括很多property，比如value，className以及一些方法onclik等方法。</p>\n<p><strong>注意</strong>：在使用setAttribute的时候，该函数一定接收两个参数，setAttribute（attributeName,value）,无论value的值是什么类型都会编译为字符串类型。在html标签中添加属性，本质上是跟在标签里面写属性时一样的，所以属性值最终都会编译为字符串类型。</p>\n"},{"title":"HTML中的attribute属性和JavaScript中的property属性区别","answer":"<ul>\n<li><strong>Attribute</strong>：\n<ul>\n<li><strong>HTML 标签上的属性</strong>，定义在 HTML 中（如 <code>&lt;input id=&quot;name&quot; value=&quot;初始值&quot;&gt;</code>）。</li>\n<li>通过 <code>setAttribute()</code>/<code>getAttribute()</code> 操作，<strong>始终返回字符串</strong>。</li>\n</ul>\n</li>\n<li><strong>Property</strong>：\n<ul>\n<li><strong>DOM 对象（如元素节点）的属性</strong>，是 JavaScript 内存中的值。</li>\n<li>通过 <code>element.propertyName</code> 直接访问（如 <code>input.value</code>），<strong>类型多样</strong>（布尔、数字、对象等）。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"常见的 web 前端网络攻击有哪些？","answer":"<p><strong>1. XSS（跨站脚本攻击）</strong></p>\n<ul>\n<li><strong>原理</strong>：攻击者注入恶意脚本到页面中，窃取用户数据（如 Cookie）。</li>\n<li><strong>类型</strong>：存储型、反射型、DOM 型。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>输入内容转义（如 <code>&amp;</code> → <code>&amp;</code>）。</li>\n<li>使用 CSP（内容安全策略）限制脚本来源。</li>\n<li>避免 <code>innerHTML</code>，优先用 <code>textContent</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>2. CSRF（跨站请求伪造）</strong></p>\n<ul>\n<li><strong>原理</strong>：诱导用户发起非预期的请求（如修改密码）。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>关键操作校验 <code>Referer</code> 或 <code>Origin</code> 头。</li>\n<li>请求添加 CSRF Token（服务端生成并验证）。</li>\n<li>Cookie 设置 <code>SameSite=Strict/Lax</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>3. 点击劫持（Clickjacking）</strong></p>\n<ul>\n<li><strong>原理</strong>：通过透明 iframe 覆盖诱骗用户点击隐藏按钮。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>HTTP 头设置 <code>X-Frame-Options: DENY/SAMEORIGIN</code>。</li>\n<li>前端 JS 判断 <code>self === top</code> 防止嵌套。</li>\n</ul>\n</li>\n</ul>\n<p><strong>4. 中间人攻击（MITM）</strong></p>\n<ul>\n<li><strong>原理</strong>：劫持通信链路窃取或篡改数据。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>全站启用 HTTPS（HTTP/2 + HSTS 强制跳转）。</li>\n<li>避免混合内容（HTTP 与 HTTPS 混用）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>5. CORS 配置错误</strong></p>\n<ul>\n<li><strong>原理</strong>：不当的跨域策略导致敏感数据泄露。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>服务端严格设置 <code>Access-Control-Allow-Origin</code>（避免 <code>*</code>）。</li>\n<li>限制预检请求（<code>OPTIONS</code>）的响应头范围。</li>\n</ul>\n</li>\n</ul>\n<p><strong>6. DDoS（CC 攻击）</strong></p>\n<ul>\n<li><strong>原理</strong>：高频请求耗尽服务器资源。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>前端添加验证码或行为验证（如滑动拼图）。</li>\n<li>服务端限流（IP 频率限制）。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"7\">\n<li>恶意文件上传**</li>\n</ol>\n<ul>\n<li><strong>原理</strong>：上传可执行文件（如 <code>.php</code>）到服务器。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>前端限制文件类型（白名单校验）。</li>\n<li>服务端重命名文件并扫描内容。</li>\n</ul>\n</li>\n</ul>\n<p><strong>8. DNS 劫持</strong></p>\n<ul>\n<li><strong>原理</strong>：篡改 DNS 解析结果导向恶意站点。</li>\n<li><strong>防御</strong>：\n<ul>\n<li>使用 HTTPS 加密通信。</li>\n<li>启用 DNS over HTTPS（DoH）。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"什么是虚拟DOM?其优点有哪些？","answer":"<p>虚拟 DOM（Virtual DOM）是一种<strong>用 JavaScript 对象模拟真实 DOM 结构的中间层</strong>，常见于 React、Vue 等框架，其核心原理与优点如下：</p>\n<p><strong>一、虚拟 DOM 的核心原理</strong></p>\n<ol>\n<li><strong>结构映射</strong>：将真实 DOM 抽象为轻量的 JS 对象（如 <code>{ type: 'div', props: { className: 'box' }, children: [...] }</code>）。</li>\n<li><strong>差异比对（Diff）</strong>：状态变化时生成新虚拟 DOM，与旧版本对比，找出最小变更（差异）。</li>\n<li><strong>批量更新</strong>：将差异一次性应用到真实 DOM，减少直接操作次数。</li>\n</ol>\n<p><strong>二、虚拟 DOM 的核心优点</strong></p>\n<ol>\n<li><strong>性能优化</strong>\n<ul>\n<li><strong>减少直接 DOM 操作</strong>：真实 DOM 操作（如修改 <code>innerHTML</code>）会触发重排/重绘，成本高昂。</li>\n<li><strong>批量更新与合并</strong>：通过差异比对避免频繁的 DOM 修改，降低渲染开销。</li>\n</ul>\n</li>\n<li><strong>跨平台能力</strong>\n<ul>\n<li><strong>抽象渲染逻辑</strong>：虚拟 DOM 可对接不同平台（浏览器 DOM、移动端原生组件、Canvas 等），如 React Native。</li>\n</ul>\n</li>\n<li><strong>开发体验提升</strong>\n<ul>\n<li><strong>声明式编程</strong>：开发者关注数据与 UI 的关系，而非手动操作 DOM（如 <code>document.getElementById</code>）。</li>\n<li><strong>自动优化</strong>：框架处理底层 DOM 更新，简化复杂 UI 的维护。</li>\n</ul>\n</li>\n<li><strong>高效的 Diff 算法</strong>\n<ul>\n<li><strong>同级对比</strong>：React 等框架采用分层对比策略，时间复杂度从 O(n³) 优化至 O(n)。</li>\n<li><strong>Key 值优化</strong>：通过 <code>key</code> 标识元素，减少不必要的节点销毁与重建。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、虚拟 DOM 的适用场景</strong></p>\n<ul>\n<li><strong>动态复杂 UI</strong>：频繁交互的页面（如数据看板、编辑器）。</li>\n<li><strong>跨平台应用</strong>：一套代码适配多端渲染。</li>\n<li><strong>框架级优化</strong>：与状态管理、组件化结合，构建高效应用。</li>\n</ul>\n<p><strong>四、与传统直接操作 DOM 的对比</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>场景</strong></th>\n<th style=\"text-align:left\"><strong>直接操作 DOM</strong></th>\n<th style=\"text-align:left\"><strong>虚拟 DOM</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>简单更新</strong></td>\n<td style=\"text-align:left\">更快（无中间层）</td>\n<td style=\"text-align:left\">略慢（需生成和对比虚拟 DOM）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>复杂更新</strong></td>\n<td style=\"text-align:left\">性能差（频繁重排）</td>\n<td style=\"text-align:left\">性能优（批量更新）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>开发效率</strong></td>\n<td style=\"text-align:left\">低（手动更新）</td>\n<td style=\"text-align:left\">高（声明式编程）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>总结</strong></p>\n<p>虚拟 DOM 通过 <strong>JS 对象抽象</strong> 和 <strong>差异比对机制</strong>，在复杂场景下显著提升性能与开发效率，是现代前端框架的核心设计之一。其价值并非绝对性能最优，而是在开发体验与渲染效率之间找到最佳平衡。</p>\n"},{"title":"DOM树和渲染树有什么区别？","answer":"<p>DOM 树和渲染树（Render Tree）的核心区别在于<strong>作用范围和节点过滤</strong>：</p>\n<ol>\n<li><strong>节点范围</strong>：\n<ul>\n<li><strong>DOM 树</strong>：包含 HTML 文档所有节点（包括隐藏元素如 <code>display: none</code> 或 <code>&lt;script&gt;</code>）。</li>\n<li><strong>渲染树</strong>：仅包含<strong>可见节点</strong>（如 <code>display: none</code> 的元素会被排除）。</li>\n</ul>\n</li>\n<li><strong>构建依据</strong>：\n<ul>\n<li>DOM 树由 HTML 解析直接生成，反映文档结构。</li>\n<li>渲染树由 DOM 树 + CSSOM（CSS 样式规则）组合生成，决定实际渲染内容。</li>\n</ul>\n</li>\n<li><strong>节点对应关系</strong>：\n<ul>\n<li>DOM 节点与渲染树节点不一定一一对应（如 <code>visibility: hidden</code> 的元素仍占用渲染树空间）。</li>\n</ul>\n</li>\n<li><strong>核心作用</strong>：\n<ul>\n<li>DOM 树提供文档结构操作能力（如 JS 增删节点）。</li>\n<li>渲染树驱动浏览器布局（Layout）和绘制（Paint），直接影响页面渲染性能。</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例</strong>：</p>\n<ul>\n<li><code>&lt;div style=&quot;display: none&quot;&gt;</code> 会出现在 DOM 树中，但不会进入渲染树。</li>\n<li><code>&lt;span&gt;Hello&lt;/span&gt;</code> 在渲染树中可能被合并到父级文本块中。</li>\n</ul>\n"},{"title":"Vue与React的区别，分别在哪些场景下使用更合适？","answer":"<p>一、核心区别</p>\n<ol>\n<li><strong>数据绑定与响应式机制</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：采用<strong>双向数据绑定</strong>（如<code>v-model</code>），通过<code>getter/setter</code>劫持数据变化，自动追踪依赖并更新视图，简化了表单交互开发137。</li>\n<li><strong>React</strong>：坚持<strong>单向数据流</strong>，需通过<code>setState</code>显式更新状态，依赖虚拟DOM的<code>diff</code>算法优化渲染性能，强调数据的不可变性169。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>模板与语法</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：使用基于HTML的模板语法（如<code>v-if</code>、<code>v-for</code>），逻辑与视图分离更直观，适合偏好声明式开发的团队268。</li>\n<li><strong>React</strong>：完全依赖<strong>JSX</strong>（JavaScript XML），将HTML与JavaScript混合编写，提供更高的灵活性，适合函数式编程爱好者6910。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>组件通信与复用</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：通过<code>props</code>传递数据、<code>$emit</code>触发事件，支持<code>provide/inject</code>跨层级通信；逻辑复用多依赖<code>mixins</code>或<code>Composition API</code>17。</li>\n<li><strong>React</strong>：父组件通过<code>props</code>传递回调函数，跨层级通信使用<code>Context API</code>；逻辑复用通过<strong>HOC（高阶组件）<strong>或</strong>Hooks</strong>实现159。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>状态管理</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：内置<strong>Vuex/Pinia</strong>，支持直接修改状态，深度集成响应式系统，开发体验更简洁179。</li>\n<li><strong>React</strong>：依赖第三方库如<strong>Redux/MobX</strong>，强调不可变数据与纯函数，需通过<code>dispatch</code>触发状态变更，适合复杂状态流156。</li>\n</ul>\n<ol start=\"5\">\n<li><strong>生态系统与工具链</strong></li>\n</ol>\n<ul>\n<li><strong>Vue</strong>：官方提供全家桶（Vue Router、Vuex、Vite），适合快速搭建轻量级应用；中文文档友好，学习曲线平缓3610。</li>\n<li><strong>React</strong>：社区生态庞大（如Next.js、React Native），工具链灵活但需自行选型；适合企业级应用与跨平台开发5610。</li>\n</ul>\n<p>二、适用场景</p>\n<ol>\n<li><strong>选择Vue的场景</strong></li>\n</ol>\n<ul>\n<li><strong>中小型项目</strong>：快速原型开发、表单密集型应用（如后台管理系统），Vue的响应式系统能显著减少手动编码量368。</li>\n<li><strong>团队新手较多</strong>：模板语法直观，文档详尽，适合传统Web开发者快速上手610。</li>\n<li><strong>渐进式集成</strong>：需逐步替换旧项目（如jQuery），通过CDN引入局部功能升级510。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>选择React的场景</strong></li>\n</ol>\n<ul>\n<li><strong>大型复杂应用</strong>：如社交平台、实时协作工具，React的单向数据流与虚拟DOM优化更易维护高性能动态界面569。</li>\n<li><strong>跨平台开发</strong>：借助<strong>React Native</strong>实现iOS/Android代码复用，适用于需原生性能的移动端项目510。</li>\n<li><strong>强类型与测试需求</strong>：结合TypeScript，提升代码健壮性；生命周期管理严格，适合微前端架构569。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>其他考量因素</strong></li>\n</ol>\n<ul>\n<li><strong>团队经验</strong>：熟悉函数式编程选React，偏好HTML模板选Vue610。</li>\n<li><strong>长期维护性</strong>：React的不可变数据与TypeScript支持降低重构风险；Vue的渐进式升级路径更明确（如Vue2→3平滑迁移）59。</li>\n</ul>\n"},{"title":"<span id=\"browser\">从浏览器输入url后都经历了什么</span>","answer":"<ul>\n<li>\n<p>通过DNS解析获得网址的对应IP地址</p>\n</li>\n<li>\n<p>浏览器与远程web服务器 通过TCP三次握手协商来建立一个 TCP/IP 连接</p>\n</li>\n<li>\n<p>浏览器 通过TCP/IP连接 向web服务器 发送一个 HTTP 请求</p>\n</li>\n<li>\n<p>服务器的永久重定向响应</p>\n</li>\n<li>\n<p>浏览器跟踪重定向地址</p>\n</li>\n<li>\n<p>服务器处理请求</p>\n</li>\n<li>\n<p>服务器返回一个 HTTP 响应</p>\n</li>\n<li>\n<p>浏览器渲染:解析HTML、解析CSS、解析JS、Render树</p>\n</li>\n</ul>\n"},{"title":"<span id=\"reflow-and-repaint\">回流和重绘有什么区别？</span>","answer":"<p><strong>1. 触发原因</strong></p>\n<ul>\n<li><strong>回流（Reflow）</strong>：当元素的<strong>几何属性或布局发生变化</strong>（如宽高、位置、字体大小、窗口缩放等），浏览器需重新计算元素的几何信息并更新布局树。</li>\n<li><strong>重绘（Repaint）</strong>：当元素的<strong>样式变化但不影响布局</strong>（如颜色、背景、透明度等），浏览器只需重新绘制受影响区域。</li>\n</ul>\n<p><strong>2. 性能影响</strong></p>\n<ul>\n<li><strong>回流比重绘代价更高</strong>：回流会导致子元素及后续元素的连锁重新计算（“布局抖动”），而重绘仅涉及像素更新。</li>\n<li><strong>回流必定触发重绘</strong>：布局变化后必然需要重新绘制，但重绘不一定触发回流。</li>\n</ul>\n<p><strong>3. 常见触发场景</strong></p>\n<ul>\n<li><strong>回流</strong>：\n<ul>\n<li>修改元素的尺寸、位置、边距（如 <code>width</code>、<code>margin</code>、<code>position</code>）。</li>\n<li>增删可见 DOM 元素。</li>\n<li>读取某些属性（如 <code>offsetTop</code>、<code>scrollHeight</code>）会强制同步回流。</li>\n</ul>\n</li>\n<li><strong>重绘</strong>：\n<ul>\n<li>修改颜色（<code>color</code>）、背景（<code>background</code>）、阴影（<code>box-shadow</code>）。</li>\n<li>隐藏元素但保留布局（如 <code>visibility: hidden</code>）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>优化策略</strong></p>\n<ol>\n<li><strong>减少回流次数</strong>：\n<ul>\n<li>使用 <code>transform</code> 或 <code>opacity</code> 代替直接修改 <code>top/left</code>（触发 GPU 加速，跳过回流）。</li>\n<li>避免逐行修改样式，通过 <code>class</code> 或 <code>cssText</code> 批量更新。</li>\n<li>使用 <code>DocumentFragment</code> 批量操作 DOM。</li>\n</ul>\n</li>\n<li><strong>避免强制同步布局</strong>：\n<ul>\n<li>避免在循环中频繁读取布局属性（如 <code>offsetWidth</code>），会强制浏览器立即回流。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"你知道哪些性能优化手段？","answer":"<p><strong>一、网络请求优化</strong></p>\n<ol>\n<li><strong>减少请求次数</strong>\n<ul>\n<li>合并资源（CSS/JS 文件、雪碧图）。</li>\n<li>使用 HTTP/2 多路复用降低队头阻塞。</li>\n</ul>\n</li>\n<li><strong>资源压缩与缓存</strong>\n<ul>\n<li>开启 Gzip/Brotli 压缩。</li>\n<li>强缓存（<code>Cache-Control</code>）与协商缓存（<code>ETag</code>）合理配置。</li>\n</ul>\n</li>\n<li><strong>CDN 加速</strong>：静态资源分发至边缘节点，减少传输延迟。</li>\n</ol>\n<p><strong>二、资源加载优化</strong></p>\n<ol>\n<li><strong>按需加载</strong>\n<ul>\n<li>路由懒加载（React.lazy + Suspense）。</li>\n<li>图片懒加载（<code>loading=&quot;lazy&quot;</code> 或 IntersectionObserver）。</li>\n</ul>\n</li>\n<li><strong>预加载关键资源</strong>\n<ul>\n<li><code>&lt;link rel=&quot;preload&quot;&gt;</code> 提前加载字体、核心 JS/CSS。</li>\n<li>异步脚本（<code>async/defer</code>）避免阻塞渲染。</li>\n</ul>\n</li>\n<li><strong>资源体积优化</strong>\n<ul>\n<li>代码分包（Webpack SplitChunks）。</li>\n<li>图片格式优化（WebP/AVIF）、响应式图片（<code>srcset</code>）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、渲染性能优化</strong></p>\n<ol>\n<li><strong>减少重排与重绘</strong>\n<ul>\n<li>避免频繁操作样式，使用 <code>transform/opacity</code> 触发 GPU 加速。</li>\n<li>批量 DOM 更新（DocumentFragment）。</li>\n</ul>\n</li>\n<li><strong>优化长列表</strong>\n<ul>\n<li>虚拟滚动（React Virtualized、Vue Virtual Scroller）。</li>\n</ul>\n</li>\n<li><strong>避免强制同步布局</strong>\n<ul>\n<li>分离读写操作（如先读取布局属性，再统一修改）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>四、代码执行优化</strong></p>\n<ol>\n<li><strong>减少主线程阻塞</strong>\n<ul>\n<li>长任务拆分（Web Workers）。</li>\n<li>防抖/节流（resize、scroll 事件）。</li>\n</ul>\n</li>\n<li><strong>内存管理</strong>\n<ul>\n<li>及时解绑事件监听、清除定时器。</li>\n<li>避免内存泄漏（闭包、全局变量滥用）。</li>\n</ul>\n</li>\n<li><strong>Tree Shaking</strong>：删除未使用代码（ES Module 静态分析）。</li>\n</ol>\n<p><strong>五、其他关键优化</strong></p>\n<ol>\n<li><strong>SSR/SSG</strong>：服务端渲染（如 Next.js）提升首屏速度。</li>\n<li><strong>Web Vitals 指标优化</strong>\n<ul>\n<li>LCP：优先加载关键资源，优化图片/字体。</li>\n<li>FID：减少主线程长任务，延迟非关键 JS。</li>\n<li>CLS：预留图片/广告位尺寸，避免布局偏移。</li>\n</ul>\n</li>\n<li><strong>性能监控</strong>\n<ul>\n<li>Lighthouse 评分分析。</li>\n<li>埋点上报（FP/FCP/LCP 等关键指标）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结</strong></p>\n<p>性能优化需结合具体场景，核心思路是 <strong>减少负载、加速渲染、避免阻塞</strong>。通过工具分析瓶颈（如 Chrome DevTools Performance 面板），渐进式优化并持续监控。</p>\n"},{"title":"前端动画有哪些实现方式？","answer":"<ol>\n<li><strong>CSS动画</strong>：使用 <code>transition</code> 和 <code>@keyframes</code> 实现简单动画，性能优化好，适合交互动效（如悬停、加载）。</li>\n<li><strong>JavaScript动画库</strong>：如 <strong>GSAP</strong>、Anime.js，适合复杂动画（时间轴、路径动画），控制精细。</li>\n<li><strong>SVG动画</strong>：通过 <code>&lt;animate&gt;</code> 标签或操作DOM属性，适合矢量图形动画（如图标变形）。</li>\n<li><strong>Canvas/WebGL</strong>：用 <strong>Canvas API</strong> 或 <strong>Three.js</strong> 实现高性能动画（游戏、数据可视化）。</li>\n<li><strong>框架内置动画</strong>：如 Vue 的 <code>&lt;Transition&gt;</code> 组件、React 的 <strong>React Spring</strong>，与框架深度集成。</li>\n<li><strong>Web Animations API</strong>：原生JS API，融合CSS和JS动画能力，可控性强。</li>\n</ol>\n"},{"title":"Canvas 和 SVG 的区别","answer":"<p>Canvas 是<strong>位图</strong>，通过 JavaScript 动态绘制，适合高频渲染（如动画、游戏），但元素不可单独操作；</p>\n<p>SVG 是<strong>矢量图</strong>，基于 XML 描述图形，支持缩放无损、DOM 事件绑定，适合静态或交互复杂图形（如图标、图表）。Canvas 性能更高，SVG 更易维护和交互。</p>\n"},{"title":"如何判断用户设备？","answer":"<ol>\n<li>使用 navigator.userAgent（用户代理字符串）</li>\n<li>使用 CSS 媒体查询</li>\n<li>js判断视口宽度</li>\n<li>第三方库（mobile-detect.js等）</li>\n</ol>\n"},{"title":"你知道哪些自适应的方案？","answer":"<ol>\n<li><strong>媒体查询（Media Queries）</strong>\n通过CSS <code>@media</code> 根据屏幕尺寸适配不同样式，如断点布局（Bootstrap栅格系统）。</li>\n<li><strong>弹性布局（Flexbox/Grid）</strong>\n使用 <code>Flexbox</code> 或 <code>CSS Grid</code> 实现弹性容器，自动适应不同屏幕尺寸。</li>\n<li><strong>百分比/视口单位（vw/vh）</strong>\n用 <code>%</code>、<code>vw</code>（视口宽度单位）或 <code>vh</code>（视口高度单位）动态调整元素尺寸。</li>\n<li><strong>Rem适配方案</strong>\n结合 <code>rem</code>（根元素字体大小）和 <code>JavaScript</code> 动态计算根字体（如根据屏幕宽度设置 <code>1rem = 屏幕宽度的1/10</code>）。</li>\n<li><strong>响应式图片</strong>\n使用 <code>&lt;picture&gt;</code> 标签或 <code>srcset</code> 属性适配不同分辨率，结合 <code>max-width: 100%</code> 防止图片溢出。</li>\n</ol>\n"},{"title":" 前端需要注意哪些SEO","answer":"<ol>\n<li><strong>语义化 HTML</strong>\n合理使用 <code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code> 等标签，增强内容可读性。</li>\n<li><strong>标题与 Meta 标签</strong>\n确保每个页面有唯一的 <code>&lt;title&gt;</code> 和 <code>meta description</code>，准确描述页面内容。</li>\n<li><strong>图片优化</strong>\n添加 <code>alt</code> 属性，压缩图片体积（WebP格式），使用 <code>srcset</code> 适配不同分辨率。</li>\n<li><strong>友好的 URL 结构</strong>\n采用静态路径（如 <code>/blog/seo-tips</code>），避免 <code>#</code> 路由或动态参数混乱。</li>\n<li><strong>移动端适配</strong>\n响应式设计 + <code>viewport</code> 配置，确保移动端体验良好（影响 Google 排名）。</li>\n<li><strong>性能优化</strong>\n压缩资源、减少渲染阻塞（如懒加载）、提升加载速度（Lighthouse 评分）。</li>\n<li><strong>避免纯 SPA 问题</strong>\n单页应用（如 React/Vue）需结合 SSR（服务端渲染）或预渲染，保证爬虫抓取内容。</li>\n<li><strong>结构化数据（Schema）</strong>\n使用 JSON-LD 标记关键信息（如产品价格、评分），提升搜索富片段展示。</li>\n<li><strong>外链与内链优化</strong>\n合理设置 <code>&lt;a&gt;</code> 标签的 <code>href</code>，避免死链，利用 <code>rel=&quot;nofollow&quot;</code> 控制权重。</li>\n<li><strong>Sitemap 与 robots.txt</strong>\n提交 XML 站点地图，配置爬虫抓取规则。</li>\n</ol>\n"},{"title":"cookie 和 session有什么区别","answer":"<ol>\n<li><strong>存储位置</strong>\n<ul>\n<li>Cookie：数据存储在<strong>客户端</strong>（浏览器），通过请求头自动传递。</li>\n<li>Session：数据存储在<strong>服务端</strong>，客户端仅保存 Session ID（通常通过 Cookie 存储）。</li>\n</ul>\n</li>\n<li><strong>安全性</strong>\n<ul>\n<li>Cookie：易被篡改或窃取（需配合 <code>HttpOnly</code>、<code>Secure</code> 等属性提升安全性）。</li>\n<li>Session：敏感数据存于服务端，仅暴露 ID，安全性更高。</li>\n</ul>\n</li>\n<li><strong>存储大小限制</strong>\n<ul>\n<li>Cookie：单域名下通常限制为 <strong>4KB</strong> 左右。</li>\n<li>Session：服务端存储，理论无严格大小限制。</li>\n</ul>\n</li>\n<li><strong>生命周期</strong>\n<ul>\n<li>Cookie：可设置过期时间（如 <code>Expires</code> 或 <code>Max-Age</code>），支持长期保存。</li>\n<li>Session：依赖服务端配置，通常浏览器关闭即失效（或服务端主动清理）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"懒加载和预加载有什么区别？","answer":"<ol>\n<li><strong>加载时机</strong>\n<ul>\n<li><strong>懒加载</strong>：延迟加载非关键资源（如图片、组件），当用户即将需要时（如滚动到视口）触发。</li>\n<li><strong>预加载</strong>：提前加载后续可能需要的资源（如下一页内容），在空闲时间或用户操作前完成。</li>\n</ul>\n</li>\n<li><strong>核心目的</strong>\n<ul>\n<li><strong>懒加载</strong>：优化首屏加载速度，减少初始请求压力。</li>\n<li><strong>预加载</strong>：提升后续操作的流畅性，减少用户等待时间。</li>\n</ul>\n</li>\n<li><strong>典型场景</strong>\n<ul>\n<li><strong>懒加载</strong>：长列表、图库、非首屏内容。</li>\n<li><strong>预加载</strong>：幻灯片切换、关键功能模块、预测用户下一步行为。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>\n<ul>\n<li><strong>懒加载</strong>：通过 <code>Intersection Observer</code> 监听元素可见性，或动态 <code>import()</code> 异步加载组件。</li>\n<li><strong>预加载</strong>：使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>fetch()</code> 提前请求资源。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？","answer":"<p><strong>使用 1x1 像素透明 GIF 图片发送埋点请求的核心原因</strong>：</p>\n<ol>\n<li><strong>无跨域限制</strong>：\n<code>&lt;img&gt;</code> 标签天然支持跨域请求，无需 CORS 配置，避免浏览器拦截。</li>\n<li><strong>性能损耗低</strong>：\n1x1 透明 GIF 体积极小（约 43B），传输快且不占用额外资源，对页面性能影响最小。</li>\n<li><strong>兼容性强</strong>：\n所有浏览器均支持 GIF 格式，且图片加载无阻塞问题（相比脚本或 AJAX）。</li>\n<li><strong>无副作用</strong>：\n透明图片不会干扰页面展示，无需处理内容返回（服务器只需响应 204/200 状态码）。</li>\n<li><strong>数据传参灵活</strong>：\n通过 URL 的 query 参数携带埋点数据（如 <code>?event=click&amp;user=123</code>），服务端解析日志即可。</li>\n</ol>\n"},{"title":"简述一下 PWA","answer":"<p><strong>PWA（渐进式网络应用）的核心要点</strong>：</p>\n<ol>\n<li><strong>核心能力</strong>：\n<ul>\n<li><strong>离线可用</strong>：通过 <code>Service Worker</code> 缓存资源，实现弱网或无网访问。</li>\n<li><strong>类原生体验</strong>：支持添加到主屏幕、全屏模式、推送通知（Push API）。</li>\n</ul>\n</li>\n<li><strong>关键技术</strong>：\n<ul>\n<li><strong>Service Worker</strong>：后台脚本管理缓存与网络代理。</li>\n<li><strong>Web App Manifest</strong>：定义应用图标、启动页等元数据（<code>manifest.json</code>）。</li>\n<li><strong>HTTPS 强制</strong>：确保通信安全。</li>\n</ul>\n</li>\n<li><strong>核心优势</strong>：\n<ul>\n<li><strong>响应式设计</strong>：适配多端（PC/移动）。</li>\n<li><strong>低流量消耗</strong>：优先加载缓存资源。</li>\n<li><strong>无安装依赖</strong>：通过浏览器访问，支持渐进增强（逐步支持高级功能）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"前端埋点有哪些方案？","answer":"<ol>\n<li><strong>代码埋点（手动埋点）</strong>\n在代码中插入上报逻辑（如点击/曝光事件），灵活但维护成本高。</li>\n<li><strong>可视化埋点</strong>\n通过工具（如GrowingIO）配置事件，无代码侵入，适合非技术人员操作。</li>\n<li><strong>无埋点（全埋点）</strong>\n自动采集全量用户行为（如点击、页面停留），通过后端过滤分析，数据全但处理复杂。</li>\n<li><strong>服务端埋点</strong>\n由后端记录日志（如API请求），避免客户端数据丢失，但无法捕获前端交互细节。</li>\n<li><strong>基于Image/Beacon的请求</strong>\n使用 <code>new Image().src</code> 或 <code>navigator.sendBeacon()</code> 发送数据，避免阻塞页面。</li>\n</ol>\n"},{"title":"简述一下 WebAssembly","answer":"<ol>\n<li><strong>定位</strong>：\n<ul>\n<li>一种<strong>二进制指令格式</strong>，能在浏览器中高性能执行（接近原生速度），与JS互补，非替代。</li>\n</ul>\n</li>\n<li><strong>核心能力</strong>：\n<ul>\n<li><strong>高性能计算</strong>：适用于图形渲染、游戏、加密等CPU密集型任务。</li>\n<li><strong>跨语言支持</strong>：C/C++/Rust等语言可编译成Wasm，复用现有生态。</li>\n<li><strong>沙箱安全</strong>：运行在隔离内存环境中，避免恶意代码攻击。</li>\n</ul>\n</li>\n<li><strong>应用场景</strong>：\n<ul>\n<li>浏览器内高性能应用（如FFmpeg视频解码）。</li>\n<li>跨平台应用（结合Web/桌面/移动端）。</li>\n<li>模块化加速（如JS性能瓶颈的数学计算）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"如何给自己团队的大型前端项目设计单元测试？","answer":"<ol>\n<li><strong>选型与分层</strong>\n<ul>\n<li><strong>框架</strong>：选主流工具（如Jest+Vue Test Utils/React Testing Library），确保生态支持。</li>\n<li><strong>分层策略</strong>：按模块拆分（Utils → Components → Hooks → API层），优先覆盖核心逻辑与公共模块。</li>\n</ul>\n</li>\n<li><strong>覆盖率与规范</strong>\n<ul>\n<li><strong>阈值设定</strong>：核心代码覆盖率不低于80%（如业务Utils），UI组件可放宽。</li>\n<li><strong>Mock策略</strong>：用<code>jest.mock</code>隔离API、第三方库，避免真实网络请求。</li>\n</ul>\n</li>\n<li><strong>组件测试重点</strong>\n<ul>\n<li><strong>渲染校验</strong>：验证Props传递与条件渲染（如<code>toBeInTheDocument</code>）。</li>\n<li><strong>交互测试</strong>：模拟用户操作（点击/输入），断言状态或事件触发正确性。</li>\n</ul>\n</li>\n<li><strong>工程化集成</strong>\n<ul>\n<li><strong>Husky + Lint</strong>：提交代码前自动跑测试，拦截失败用例。</li>\n<li><strong>CI流水线</strong>：集成到Jenkins/GitHub Actions，生成可视化报告（如Jest HTML Reporter）。</li>\n</ul>\n</li>\n<li><strong>维护与优化</strong>\n<ul>\n<li><strong>快照测试</strong>：监控UI意外变更（慎用，避免频繁失效）。</li>\n<li><strong>测试可读性</strong>：用例命名清晰（<code>describe</code>场景，<code>it</code>预期结果），定期Review冗余用例。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"ECharts是什么？能够用来做什么？","answer":"<p><code>ECharts</code>（百度开源的<strong>可视化图表库</strong>）是一个基于<code>JavaScript</code>的开源可视化图表库，可以用来创建丰富、交互式的数据可视化图表。</p>\n<p><code>ECharts</code>能够用来展示各种类型的图表，包括<strong>折线图、柱状图、条形图、散点图、饼图、雷达图、地图</strong>等。它支持动态更新数据，通过交互操作，可以实现数据的<strong>筛选、排序、缩放</strong>等功能。</p>\n<p><code>ECharts</code>提供了丰富的配置项和API，使开发者可以根据自己的需求灵活定制图表的样式和行为，同时还支持多种数据格式的导入和导出。它适用于各类<strong>数据分析、数据可视化、大屏展示</strong>等场景，可以帮助用户更直观地理解和分析数据，从而做出更好的决策。</p>\n"},{"title":"如何提高前端代码的可维护性和可拓展性？","answer":"<ol>\n<li><strong>模块化与组件化</strong>\n<ul>\n<li>按功能拆分独立模块/组件，遵循<strong>单一职责原则</strong>（如UI与逻辑分离），降低耦合度。</li>\n</ul>\n</li>\n<li><strong>统一代码规范</strong>\n<ul>\n<li>使用ESLint+Prettier强制代码风格，制定命名规则（如<code>动词+名词</code>函数名），增强可读性。</li>\n</ul>\n</li>\n<li><strong>类型系统</strong>\n<ul>\n<li>引入TypeScript，明确接口类型与数据结构，减少隐式错误，提升重构信心。</li>\n</ul>\n</li>\n<li><strong>设计模式应用</strong>\n<ul>\n<li>常用模式：工厂模式（创建对象）、策略模式（算法替换）、观察者模式（事件通信），提升扩展性。</li>\n</ul>\n</li>\n<li><strong>文档与注释</strong>\n<ul>\n<li>关键逻辑添加注释，维护组件API文档（如Storybook），降低新人上手成本。</li>\n</ul>\n</li>\n<li><strong>自动化测试</strong>\n<ul>\n<li>核心逻辑覆盖单元测试（Jest），复杂交互补充E2E测试（Cypress），保障迭代安全。</li>\n</ul>\n</li>\n<li><strong>状态管理规范</strong>\n<ul>\n<li>使用Redux/Pinia集中管理全局状态，避免Props多层透传，逻辑更易追踪。</li>\n</ul>\n</li>\n<li><strong>工程化工具链</strong>\n<ul>\n<li>配置Alias简化导入路径，利用Webpack/Vite实现按需加载，优化构建流程。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"列举一些常见的content-type","answer":"<ol>\n<li><strong><code>application/json</code></strong>：JSON 数据交互，如 REST API 请求/响应。</li>\n<li><strong><code>multipart/form-data</code></strong>：表单文件上传（支持二进制数据）。</li>\n<li><strong><code>application/x-www-form-urlencoded</code></strong>：普通表单提交（键值对 URL 编码）。</li>\n<li><strong><code>text/html</code></strong>：HTML 文档渲染。</li>\n<li><strong><code>text/plain</code></strong>：纯文本内容（如日志）。</li>\n<li><strong><code>text/css</code></strong> / <strong><code>text/javascript</code></strong>：CSS 或 JS 文件类型。</li>\n<li><strong><code>image/png</code></strong> / <strong><code>image/jpeg</code></strong>：图片资源格式。</li>\n<li><strong><code>application/octet-stream</code></strong>：二进制流（如文件下载）。</li>\n<li><strong><code>application/xml</code></strong>：XML 数据格式（传统接口）。</li>\n</ol>\n"},{"title":"CSS动画和JS实现的动画分别有哪些优缺点？","answer":""},{"title":"AST语法树是什么？","answer":""},{"title":"CSR和SSR(前端渲染与后端渲染)区别是什么？","answer":""},{"title":"你知道哪些图标处理方案?","answer":""},{"title":"常见的登录鉴权方式有哪些？","answer":"<ol>\n<li><strong>Cookie + Session</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：用户登录后，服务器创建一个 <code>Session</code>，将用户信息存储在服务器端，同时生成一个唯一的 <code>SessionID</code>，并将其以 <code>Cookie</code> 的形式发送给客户端。客户端之后的每次请求都携带该 <code>Cookie</code>，服务器用 <code>SessionID</code> 确认用户身份。</li>\n<li><strong>优点</strong>：服务器管理会话状态，安全性较高；可以设置短期有效期，适合敏感信息。</li>\n<li><strong>缺点</strong>：会消耗服务器内存，难以扩展；需跨域配置。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>JWT（JSON Web Token）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：登录成功后，服务器生成一个加密的 <code>JWT</code>，该令牌包含用户信息或标识，发送给客户端。之后的请求，客户端携带该 <code>JWT</code>，服务器通过验证 <code>JWT</code> 的签名来确认用户身份。</li>\n<li><strong>优点</strong>：无状态、可跨域，适合分布式架构；可携带信息，支持用户角色验证。</li>\n<li><strong>缺点</strong>：令牌较长，增加请求负担；一旦泄露容易被滥用。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>OAuth</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：OAuth 是一种授权协议，用户通过第三方平台（如 Google、Facebook）登录，将权限授予该平台来访问某些资源。OAuth 2.0 使用 <code>Access Token</code> 访问受保护资源，<code>Refresh Token</code> 则用于获取新的 <code>Access Token</code>。</li>\n<li><strong>优点</strong>：用户体验好，适用于第三方应用授权登录；支持多级权限。</li>\n<li><strong>缺点</strong>：流程复杂，难以实现；<code>Token</code> 可能泄露或失效。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>SAML（Security Assertion Markup Language）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：SAML 是基于 XML 的单点登录协议，通常用于企业系统中。用户请求通过 SAML 协议在多个系统之间共享认证状态，允许用户在不重新登录的情况下访问其他应用。</li>\n<li><strong>优点</strong>：适用于企业内部系统间的统一登录；支持跨域。</li>\n<li><strong>缺点</strong>：复杂度高，基于 XML 的消息传递效率低。</li>\n</ul>\n<ol start=\"5\">\n<li><strong>SSO（Single Sign-On）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：单点登录允许用户使用一个登录凭据访问多个应用或系统。常用的实现方案包括基于 OAuth、SAML 或 CAS（Central Authentication Service）。</li>\n<li><strong>优点</strong>：提高用户体验，避免多次登录；适用于多系统集成。</li>\n<li><strong>缺点</strong>：一旦账户泄露，多个系统都会受到威胁。</li>\n</ul>\n<ol start=\"6\">\n<li><strong>基于短信或邮件的 OTP（一次性密码）</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：用户登录时接收一个一次性密码（通常通过短信或邮件发送），有效期较短。用户输入正确的 OTP 后，即可完成登录。</li>\n<li><strong>优点</strong>：安全性高，适合敏感操作的二次验证。</li>\n<li><strong>缺点</strong>：需要借助短信或邮件服务，成本较高。</li>\n</ul>\n<ol start=\"7\">\n<li><strong>指纹、面部识别等生物识别</strong></li>\n</ol>\n<ul>\n<li><strong>原理</strong>：利用设备上的生物识别传感器进行身份认证，例如指纹、面部识别等。通常用于设备级别的解锁，或结合其他鉴权方式进行身份确认。</li>\n<li><strong>优点</strong>：用户体验佳、难以复制；适合移动设备的安全验证。</li>\n<li><strong>缺点</strong>：设备依赖性强；难以在 web 应用中普遍使用。</li>\n</ul>\n"}]