[{"title":"什么是微前端?","description":"","answer":"<p>微前端是将大型前端应用拆解为独立模块的架构模式，支持独立开发、部署与技术栈异构。\n微前端通过将复杂应用拆分为多个小型子应用（如按业务模块划分），每个子应用可独立开发、测试、部署，并通过运行时集成（如模块联邦、iframe、Web Components）组合成完整应用。优势包括团队协作解耦、技术栈灵活、渐进升级能力，适合多团队维护的中后台系统或遗留项目重构。</p>\n"},{"title":"实现微前端有哪些技术方案？","description":"","answer":"<p>微前端实现方案包括<strong>运行时集成</strong>、<strong>构建时组合</strong>、<strong>Web Components</strong>、<strong>模块联邦</strong>等多种技术手段，核心在于独立开发与动态聚合。</p>\n<ol>\n<li><strong>运行时集成</strong>\n<ul>\n<li><strong>框架型</strong>：如 <code>single-spa</code>、<code>Qiankun</code>，主应用通过路由动态加载子应用，沙箱隔离资源。</li>\n<li><strong>iframe</strong>：天然隔离但通信复杂，体验割裂。</li>\n</ul>\n</li>\n<li><strong>构建时组合</strong>\n<ul>\n<li><strong>模块联邦</strong>（Webpack 5）：跨应用共享代码，依赖预构建，适合技术栈统一的项目。</li>\n</ul>\n</li>\n<li><strong>原生隔离</strong>\n<ul>\n<li><strong>Web Components</strong>：通过 Shadow DOM 和 Custom Elements 实现组件级隔离，但生态较弱。</li>\n</ul>\n</li>\n<li><strong>服务端聚合</strong>\n<ul>\n<li><strong>SSI/Nginx</strong>：服务端拼接 HTML 片段，简单但灵活性低。</li>\n</ul>\n</li>\n</ol>\n<p><strong>选型关键</strong>：根据团队规模、技术栈差异、隔离需求（如 CSS/JS 冲突）和部署复杂度综合权衡。</p>\n"},{"title":"微前端架构一般是如何做Js隔离的？","description":"","answer":"<p>微前端通过<strong>JS沙箱</strong>技术（如Proxy代理、快照隔离）限制子应用全局副作用，实现JS执行环境的隔离。</p>\n<ol>\n<li><strong>单例沙箱</strong>（Legacy Sandbox）：\n<ul>\n<li>通过重写 <code>window</code> 对象的属性存取（如<code>Proxy</code>），记录子应用修改的全局变量，卸载时恢复原始状态。</li>\n<li>适用场景：单页面同时仅运行一个子应用。</li>\n</ul>\n</li>\n<li><strong>多例沙箱</strong>（Proxy Sandbox）：\n<ul>\n<li>为每个子应用创建独立的<code>Proxy</code>代理对象，子应用操作全局变量实际指向沙箱内的虚拟环境，互不影响。</li>\n<li>优势：支持多子应用并行运行。</li>\n</ul>\n</li>\n<li><strong>快照沙箱</strong>（Snapshot Sandbox）：\n<ul>\n<li>子应用加载前保存全局对象快照，卸载时还原，通过<code>diff</code>恢复变更（兼容低版本浏览器，但无法多实例并行）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>其他方案</strong>：</p>\n<ul>\n<li><strong>iframe</strong>：天然JS隔离，但通信成本高；</li>\n<li><strong>Web Workers</strong>：独立线程运行JS，但无法直接操作DOM。</li>\n</ul>\n<p><strong>核心目标</strong>：避免全局变量污染（如<code>window</code>、<code>document</code>）、事件冲突，确保子应用独立销毁与加载。</p>\n"},{"title":"微前端可以解决什么问题？","description":"","answer":"<p>微前端主要解决<strong>巨石应用维护难、技术栈升级难、团队协作效率低</strong>的问题，实现复杂系统的解耦与渐进式演进。</p>\n<ol>\n<li><strong>拆分巨石应用</strong>：将庞大单体前端按业务模块拆分为独立子应用，降低代码耦合，提升可维护性；</li>\n<li><strong>独立开发部署</strong>：不同团队可独立开发、测试、部署子应用，避免协作阻塞，加快交付效率；</li>\n<li><strong>技术栈异构</strong>：允许子应用使用不同框架（如 Vue/React/Angular），兼容遗留系统，避免全量重构；</li>\n<li><strong>渐进升级</strong>：旧系统可逐步替换为新模块，降低技术迁移风险；</li>\n<li><strong>运行时隔离</strong>：通过沙箱机制避免 CSS/JS 全局污染，保障子应用独立性。</li>\n</ol>\n<p><strong>典型场景</strong>：中后台系统、多团队协作项目、长期迭代的复杂产品。</p>\n"},{"title":"低代码平台怎么设计渲染模块？","description":"","answer":"<p>低代码平台的渲染模块通过<strong>数据驱动 + 组件动态解析</strong>，将可视化配置的JSON描述转换为可交互的运行时界面。</p>\n<ol>\n<li><strong>配置解析引擎</strong>：将用户拖拽生成的DSL（如JSON Schema）解析为AST，映射到预置的原子组件（表单、表格等）；</li>\n<li><strong>组件动态加载</strong>：基于组件注册中心，按需加载本地或远程组件库，支持版本控制与热更新；</li>\n<li><strong>数据绑定机制</strong>：通过表达式引擎（如<code>\\{\\{data.field}}</code>）实现组件与数据模型的动态关联，处理表单校验、联动逻辑；</li>\n<li><strong>运行时沙箱</strong>：隔离渲染环境，防止组件样式/JS污染，支持实时预览与调试；</li>\n<li><strong>扩展能力</strong>：提供自定义插槽、生命周期钩子（如渲染前后事件），允许注入业务逻辑。</li>\n</ol>\n<p><strong>优化方向</strong>：缓存渲染结果、虚拟滚动性能优化、SSR兼容。</p>\n"},{"title":"在微前端中如何设计全局状态管理？","description":"","answer":""}]