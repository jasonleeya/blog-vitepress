[{"title":"HTTP/1.1 与 HTTP/2 的核心区别","answer":"<ul>\n<li><strong>多路复用</strong>：HTTP/2 允许在一个 TCP 连接上并行传输多个请求/响应，解决队头阻塞问题12。</li>\n<li><strong>二进制分帧</strong>：数据以二进制帧传输，提升解析效率16。</li>\n<li><strong>头部压缩</strong>：HPACK 算法减少冗余头部传输16。</li>\n<li><strong>服务器推送</strong>：服务端可主动推送资源（如 CSS/JS），减少请求延迟16。</li>\n</ul>\n"},{"title":"HTTP 2.0 和 3.0 有什么区别？","answer":"<ul>\n<li>HTTP/2.0 采用二进制格式传输数据，采用多路复用技术，可以只通过一个 TCP 连接传输所有的请求数据。采用头部压缩技术，解决了 HTTP/1.0 的 header 里携带的内容过大的问题。但是如果在传输的过程中存在丢包的情况的话，那么整个 TCP 就得重新传输，后面资源就会被阻塞。</li>\n<li>HTTP/3.0 放弃了 TCP 协议而是改用了 QUIC 协议，此协议基于传输层 UDP 协议。UDP 协议无需三次握手四次挥手，所以传输速率更高。并且它改善了多路复用产生的问题，如果出现丢包的情况，不需要整个重新发送，只需要重发丢掉的包就可以。HTTP/3.0 具有更低的延迟，效率甚至要比 HTTP/1.1 快 3 倍以上。</li>\n</ul>\n"},{"title":"HTTP 和 HTTPS 有什么区别？","answer":"<ol>\n<li>\n<p><code>HTTPS</code> 协议需要到 <code>CA</code> （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。</p>\n</li>\n<li>\n<p><code>HTTP</code> 是超文本传输协议，信息是明文传输，<code>HTTPS</code> 则是具有安全性的 <code>SSL</code> 加密传输协议。</p>\n</li>\n<li>\n<p><code>HTTP</code> 和 <code>HTTPS</code> 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是<code>443</code>。</p>\n</li>\n<li>\n<p><code>HTTP</code> 的连接很简单，是无状态的。<code>HTTPS</code> 协议是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议，比 <code>HTTP</code> 协议安全。</p>\n</li>\n</ol>\n"},{"title":"HTTPS 加密算法和加解密过程是啥？","answer":"<p><strong>HTTPS 加密算法与加解密过程</strong></p>\n<p>HTTPS 通过 <strong>混合加密机制</strong> 保障安全性，结合非对称加密（密钥交换）和对称加密（数据传输），同时依赖数字证书认证身份。以下是核心流程和算法：</p>\n<p><strong>一、核心加密算法</strong></p>\n<ol>\n<li>\n<p><strong>非对称加密</strong>（密钥交换）</p>\n<ul>\n<li><strong>算法</strong>：RSA、ECDHE（椭圆曲线迪菲-赫尔曼）</li>\n<li><strong>用途</strong>：安全协商对称密钥（如AES密钥），防止中间人窃听。</li>\n</ul>\n</li>\n<li>\n<p><strong>对称加密</strong>（数据传输）</p>\n<ul>\n<li><strong>算法</strong>：AES（128/256位）、ChaCha20</li>\n<li><strong>用途</strong>：加密实际传输的HTTP数据，效率高且安全性强。</li>\n</ul>\n</li>\n<li>\n<p><strong>哈希算法</strong>（完整性校验）</p>\n<ul>\n<li><strong>算法</strong>：SHA-256、SHA-384</li>\n<li><strong>用途</strong>：生成消息摘要，验证数据未被篡改。</li>\n</ul>\n</li>\n<li>\n<p><strong>数字签名</strong>（身份认证）</p>\n<ul>\n<li><strong>算法</strong>：RSA、ECDSA</li>\n<li><strong>用途</strong>：CA机构对服务器证书签名，客户端验证证书合法性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、HTTPS 加解密流程（以TLS 1.3为例）</strong></p>\n<p><strong>1. TCP 三次握手</strong></p>\n<ul>\n<li>建立基础通信连接（明文）。</li>\n</ul>\n<p><strong>2. TLS 握手阶段</strong></p>\n<ul>\n<li>\n<p><strong>Client Hello</strong></p>\n<ul>\n<li>客户端发送支持的TLS版本、加密套件列表、随机数（Client Random）。</li>\n</ul>\n</li>\n<li>\n<p><strong>Server Hello</strong></p>\n<ul>\n<li>服务端选择加密套件（如<code>TLS_AES_128_GCM_SHA256</code>），返回随机数（Server Random）、数字证书。</li>\n</ul>\n</li>\n<li>\n<p><strong>证书验证</strong></p>\n<ul>\n<li>客户端验证证书有效性（CA链校验、有效期、域名匹配等）。</li>\n</ul>\n</li>\n<li>\n<p><strong>密钥交换</strong>（ECDHE流程）</p>\n<ul>\n<li>服务端发送椭圆曲线参数和公钥（Server Params），并签名保证真实性。</li>\n<li>客户端生成临时密钥对，发送客户端公钥（Client Params）。</li>\n<li>双方通过ECDHE算法生成 <strong>预主密钥（Pre-Master Secret）</strong>。</li>\n</ul>\n</li>\n<li>\n<p><strong>生成会话密钥</strong></p>\n<ul>\n<li>客户端和服务端基于 <code>Client Random</code>、<code>Server Random</code>、<code>Pre-Master Secret</code>，通过哈希算法生成 <strong>对称密钥（Session Key）</strong>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>3. 加密通信阶段</strong></p>\n<ul>\n<li>使用对称密钥（如AES）加密HTTP数据，通过哈希算法校验完整性。</li>\n</ul>\n<p><strong>三、关键步骤详解</strong></p>\n<ol>\n<li>\n<p><strong>数字证书验证</strong></p>\n<ul>\n<li>证书包含服务器公钥、域名、CA签名等信息。</li>\n<li>浏览器内置信任的CA根证书，逐级验证证书链，确保服务器身份合法。</li>\n</ul>\n</li>\n<li>\n<p><strong>前向安全性（Forward Secrecy）</strong></p>\n<ul>\n<li>使用ECDHE等临时密钥算法，每次会话生成独立密钥，即使长期私钥泄露，历史通信仍安全。</li>\n</ul>\n</li>\n<li>\n<p><strong>对称密钥生成</strong></p>\n<ul>\n<li>通过HKDF（HMAC-based Key Derivation Function）扩展生成实际加密密钥。</li>\n</ul>\n</li>\n</ol>\n<p><strong>四、前端相关实践</strong></p>\n<ol>\n<li><strong>配置强制HTTPS</strong>\n<ul>\n<li>HTTP 响应头添加 <code>Strict-Transport-Security (HSTS)</code>，强制浏览器使用HTTPS。</li>\n</ul>\n</li>\n<li><strong>混合内容处理</strong>\n<ul>\n<li>避免页面中混合加载HTTP资源（图片、脚本），否则浏览器会标记“不安全”。</li>\n</ul>\n</li>\n<li><strong>证书监控</strong>\n<ul>\n<li>使用工具（如Lighthouse）检测证书有效期和配置错误。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结</strong></p>\n<p>HTTPS通过 <strong>非对称加密交换密钥 + 对称加密传输数据 + 数字证书认证身份</strong> 的三重机制，解决数据机密性、完整性和身份可信问题。<br>\n<strong>核心优势</strong>：在高效传输的同时，抵御窃听、篡改和中间人攻击，是前端安全通信的基石。</p>\n"},{"title":"说说网络分层里七层模型是哪七层","answer":"<p>网络七层模型（OSI）是国际标准化组织定义的网络通信分层框架，从物理传输到应用服务逐层抽象。</p>\n<p><strong>具体分层</strong>：</p>\n<ol>\n<li><strong>物理层</strong>：传输原始比特流（如网线、光纤）；</li>\n<li><strong>数据链路层</strong>：帧传输与MAC地址寻址（如交换机）；</li>\n<li><strong>网络层</strong>：IP寻址与路由选择（如路由器）；</li>\n<li><strong>传输层</strong>：端到端连接与可靠性（TCP/UDP）；</li>\n<li><strong>会话层</strong>：建立/管理会话（如RPC）；</li>\n<li><strong>表示层</strong>：数据格式转换与加密（如SSL/TLS）；</li>\n<li><strong>应用层</strong>：用户接口与协议（HTTP/FTP）。</li>\n</ol>\n<p>前端开发主要关注<strong>应用层（HTTP/WebSocket）<strong>和</strong>传输层（TCP）</strong>。</p>\n"},{"title":"TCP 和 UDP 有什么区别？","answer":"<p>TCP和UDP的核心区别在于<strong>可靠性、连接方式及传输效率</strong>，分别适用于不同场景。</p>\n<p><strong>具体差异</strong>：</p>\n<ol>\n<li>\n<p><strong>连接性</strong>：</p>\n<ul>\n<li><strong>TCP</strong>：面向连接（三次握手/四次挥手），确保可靠传输。</li>\n<li><strong>UDP</strong>：无连接，直接发送数据包，无连接开销。</li>\n</ul>\n</li>\n<li>\n<p><strong>可靠性</strong>：</p>\n<ul>\n<li><strong>TCP</strong>：保证数据顺序、完整性，自动重传丢包。</li>\n<li><strong>UDP</strong>：不保证送达，可能丢包或乱序。</li>\n</ul>\n</li>\n<li>\n<p><strong>传输效率</strong>：</p>\n<ul>\n<li><strong>TCP</strong>：因校验、重传、拥塞控制等机制，延迟较高。</li>\n<li><strong>UDP</strong>：无额外控制，传输速度快，实时性高。</li>\n</ul>\n</li>\n<li>\n<p><strong>头部开销</strong>：</p>\n<ul>\n<li><strong>TCP</strong>：头部较大（20-60字节），包含序列号、确认号等字段。</li>\n<li><strong>UDP</strong>：头部固定8字节，仅含端口和长度。</li>\n</ul>\n</li>\n</ol>\n<p><strong>应用场景</strong>：</p>\n<ul>\n<li><strong>TCP</strong>：HTTP/HTTPS、文件传输（FTP）、邮件（SMTP）等需可靠性的场景。</li>\n<li><strong>UDP</strong>：视频通话（如WebRTC）、直播流、DNS查询、在线游戏等实时性优先的场景。</li>\n</ul>\n<p><strong>总结</strong>：需要可靠传输选TCP，追求实时高效选UDP。</p>\n"},{"title":"HTTP状态码及其含义","answer":"<p>HTTP状态码用于表示请求的处理结果，分为五类，通过三位数字快速定位问题类型。</p>\n<p><strong>常见状态码</strong>：</p>\n<ol>\n<li><strong>1xx（信息）</strong>：请求已接收，继续处理（如101协议切换）。</li>\n<li><strong>2xx（成功）</strong>：请求正常处理（200 OK，201 Created）。</li>\n<li><strong>3xx（重定向）</strong>：需额外操作完成请求（301永久重定向，304缓存未修改）。</li>\n<li><strong>4xx（客户端错误）</strong>：请求有误（400参数错误，401未授权，403禁止访问，404未找到资源）。</li>\n<li><strong>5xx（服务端错误）</strong>：服务器处理失败（500内部错误，502网关错误，503服务不可用）。</li>\n</ol>\n<p><strong>前端关注重点</strong>：</p>\n<ul>\n<li><strong>200</strong>：成功获取资源；</li>\n<li><strong>304</strong>：缓存生效，减少请求；</li>\n<li><strong>404/403</strong>：检查资源路径/权限；</li>\n<li><strong>500/503</strong>：提示用户或重试。</li>\n</ul>\n"},{"title":"说是TCP的三次握手四次挥手","answer":"<p>TCP的三次握手和四次挥手是建立与断开可靠连接的核心机制，确保数据传输的完整性和有序性。</p>\n<p><strong>三次握手（建立连接）</strong>：</p>\n<ol>\n<li><strong>SYN</strong>：客户端发送SYN（同步）报文，包含初始序列号（Seq=x）。</li>\n<li><strong>SYN-ACK</strong>：服务端响应SYN+ACK（确认）报文，确认号=x+1，携带自身序列号（Seq=y）。</li>\n<li><strong>ACK</strong>：客户端发送ACK（确认）报文，确认号=y+1，双方进入连接状态。</li>\n</ol>\n<p><strong>四次挥手（断开连接）</strong>：</p>\n<ol>\n<li><strong>FIN</strong>：主动方（如客户端）发送FIN（结束）报文，进入FIN_WAIT_1状态。</li>\n<li><strong>ACK</strong>：被动方（如服务端）返回ACK确认，进入CLOSE_WAIT状态；主动方收到后进入FIN_WAIT_2状态。</li>\n<li><strong>FIN</strong>：被动方处理完数据后发送FIN报文，进入LAST_ACK状态。</li>\n<li><strong>ACK</strong>：主动方回复ACK确认，进入TIME_WAIT（等待2MSL确保对方收到），双方关闭连接。</li>\n</ol>\n<p><strong>关键点</strong>：</p>\n<ul>\n<li><strong>三次握手</strong>：防止历史重复连接初始化（两次无法确认双方收发能力）。</li>\n<li><strong>四次挥手</strong>：TCP全双工特性需双向独立关闭，且确保数据完整传输（如服务端可能仍有数据发送）。</li>\n</ul>\n<p><strong>通俗易懂版：</strong></p>\n<p>TCP的三次握手和四次挥手就像两个人打电话时的沟通流程，确保双方都能正常交流后再开始对话，以及礼貌地结束通话后再挂断。</p>\n<p><strong>三次握手（建立连接）</strong></p>\n<ol>\n<li>\n<p><strong>第一次握手</strong>：</p>\n<ul>\n<li>客户端发送“打招呼”信号（SYN）：“我要和你通话，能听到吗？”</li>\n<li>好比你打电话给朋友，先问：“喂，你在吗？”</li>\n</ul>\n</li>\n<li>\n<p><strong>第二次握手</strong>：</p>\n<ul>\n<li>服务端回复“收到”（SYN-ACK）：“我听到了！你能听到我吗？”</li>\n<li>朋友回答：“我在！你能听到我吗？”</li>\n</ul>\n</li>\n<li>\n<p><strong>第三次握手</strong>：</p>\n<ul>\n<li>客户端确认“收到回复”（ACK）：“能听到，开始聊吧！”</li>\n<li>你回应：“能听到，说吧！”</li>\n<li><strong>连接建立</strong>，双方开始传输数据。</li>\n</ul>\n</li>\n</ol>\n<p><strong>为什么是三次？</strong></p>\n<ul>\n<li>避免网络延迟导致的“重复拨号”。比如你第一次问“在吗？”没回应，又重复问，如果对方只回一次，两次握手可能误判连接已建立。</li>\n</ul>\n<p><strong>四次挥手（断开连接）</strong></p>\n<p>假设客户端主动挂断：</p>\n<ol>\n<li>\n<p><strong>第一次挥手</strong>：</p>\n<ul>\n<li>客户端说：“我说完了，准备挂电话了。”（FIN）</li>\n<li>比如你说：“今天先聊到这，我挂了啊。”</li>\n</ul>\n</li>\n<li>\n<p><strong>第二次挥手</strong>：</p>\n<ul>\n<li>服务端回复：“好的，知道了。”（ACK）</li>\n<li>朋友说：“行，等我确认一下还有没有要说的。”</li>\n</ul>\n</li>\n<li>\n<p><strong>第三次挥手</strong>：</p>\n<ul>\n<li>服务端确认后也说：“我也说完了，可以挂了。”（FIN）</li>\n<li>朋友补充：“对了，最后一点…好了，挂吧！”</li>\n</ul>\n</li>\n<li>\n<p><strong>第四次挥手</strong>：</p>\n<ul>\n<li>客户端最后确认：“收到，拜拜！”（ACK）</li>\n<li>你回答：“好的，拜拜！”</li>\n<li><strong>连接关闭</strong>，双方结束通话。</li>\n</ul>\n</li>\n</ol>\n<p><strong>为什么是四次？</strong></p>\n<ul>\n<li>因为挂电话要双方都确认。比如你说完挂断意图后，对方可能还有话要说，需要等对方说完再互相确认。</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li><strong>三次握手</strong>：互相确认“能听清吗？”，防止自说自话。</li>\n<li><strong>四次挥手</strong>：互相确认“都说完了吗？”，防止突然挂断漏话。</li>\n</ul>\n<p>这种机制确保网络传输像真实对话一样可靠，不丢数据、不乱顺序。</p>\n"},{"title":"**HTTP GET 和 POST 请求有什么区别？**","answer":"<p>HTTP GET 和 POST 请求的核心区别在于<strong>用途、数据传输方式及安全性</strong>，分别适用于获取资源和提交数据。</p>\n<p><strong>具体差异</strong>：</p>\n<ol>\n<li>\n<p><strong>用途</strong>：</p>\n<ul>\n<li><strong>GET</strong>：获取资源（如加载网页、查询数据），<strong>幂等且可缓存</strong>。</li>\n<li><strong>POST</strong>：提交资源（如表单提交、文件上传），<strong>非幂等且不缓存</strong>。</li>\n</ul>\n</li>\n<li>\n<p><strong>数据传输</strong>：</p>\n<ul>\n<li><strong>GET</strong>：参数通过URL拼接（如 <code>?key=value</code>），<strong>长度受限</strong>（约2048字符）。</li>\n<li><strong>POST</strong>：数据放在请求体（Body）中，<strong>支持更大数据量和多种格式</strong>（JSON、文件等）。</li>\n</ul>\n</li>\n<li>\n<p><strong>安全性</strong>：</p>\n<ul>\n<li><strong>GET</strong>：参数暴露在URL中，易被记录或泄露（如浏览器历史、日志）。</li>\n<li><strong>POST</strong>：数据隐藏于Body，<strong>相对安全</strong>（但未加密时仍可被截获）。</li>\n</ul>\n</li>\n<li>\n<p><strong>幂等性</strong>：</p>\n<ul>\n<li><strong>GET</strong>：多次请求结果相同（如刷新页面）。</li>\n<li><strong>POST</strong>：多次提交可能产生副作用（如重复下单）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>应用场景</strong>：</p>\n<ul>\n<li><strong>GET</strong>：搜索、分页、静态资源加载。</li>\n<li><strong>POST</strong>：登录、注册、支付等敏感操作。</li>\n</ul>\n<p><strong>总结</strong>：取数据用GET，传数据用POST；敏感信息避免GET，大数据量优先POST。</p>\n"},{"title":"Websoket 和HTTP有什么区别？","answer":"<p>WebSocket 和 HTTP 的核心区别在于<strong>通信模式与实时性</strong>，前者支持全双工实时交互，后者基于短连接的请求-响应模式。</p>\n<p><strong>具体差异</strong>：</p>\n<ol>\n<li>\n<p><strong>连接方式</strong>：</p>\n<ul>\n<li><strong>HTTP</strong>：短连接，每次请求需重新建立TCP连接（HTTP/1.1后支持Keep-Alive，但本质仍是串行请求）。</li>\n<li><strong>WebSocket</strong>：长连接，一次握手后保持连接，双方可主动推送数据。</li>\n</ul>\n</li>\n<li>\n<p><strong>通信模式</strong>：</p>\n<ul>\n<li><strong>HTTP</strong>：客户端发起请求 → 服务端响应（单向，实时性差）。</li>\n<li><strong>WebSocket</strong>：客户端/服务端均可主动发送消息（双向实时通信）。</li>\n</ul>\n</li>\n<li>\n<p><strong>头部开销</strong>：</p>\n<ul>\n<li><strong>HTTP</strong>：每次请求携带完整头部（如Cookie、User-Agent），冗余开销大。</li>\n<li><strong>WebSocket</strong>：建立连接后数据帧头部仅2~14字节，传输效率高。</li>\n</ul>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li><strong>HTTP</strong>：静态资源加载、RESTful API、传统网页交互。</li>\n<li><strong>WebSocket</strong>：实时聊天、在线游戏、股票行情推送、协同编辑。</li>\n</ul>\n</li>\n<li>\n<p><strong>协议关系</strong>：</p>\n<ul>\n<li><strong>WebSocket</strong>：基于HTTP协议升级（握手阶段使用HTTP），建立后独立于HTTP运行。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结</strong>：需实时双向通信（如消息推送）用WebSocket，传统数据交互用HTTP。</p>\n"},{"title":"http中的post请求发生了两次（多了一次options请求）的原因","answer":"<p>浏览器在发送某些跨域POST请求前会先发送<strong>OPTIONS预检请求</strong>，以确认服务器是否允许实际请求的方法和头信息，这是由CORS（跨域资源共享）安全机制触发的。</p>\n<p><strong>具体原因</strong>：</p>\n<ol>\n<li>\n<p><strong>非简单请求</strong>：当POST请求满足以下任一条件时，触发预检：</p>\n<ul>\n<li>自定义头部（如<code>Authorization</code>、<code>X-Custom-Header</code>）；</li>\n<li><code>Content-Type</code>非简单值（如<code>application/json</code>）；</li>\n<li>其他非安全方法或配置（如<code>DELETE</code>请求）。</li>\n</ul>\n</li>\n<li>\n<p><strong>预检流程</strong>：</p>\n<ul>\n<li><strong>OPTIONS请求</strong>：浏览器自动发送，询问服务器是否支持实际请求的方法和头；</li>\n<li><strong>服务器响应</strong>：需返回<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>等CORS头；</li>\n<li><strong>正式POST请求</strong>：预检通过后，浏览器发送真实POST请求。</li>\n</ul>\n</li>\n</ol>\n<p><strong>解决方案</strong>：</p>\n<ul>\n<li><strong>服务器配置</strong>：正确处理OPTIONS请求，返回允许的跨域头；</li>\n<li><strong>简化请求</strong>：避免自定义头，使用简单<code>Content-Type</code>（如<code>application/x-www-form-urlencoded</code>）。</li>\n</ul>\n"},{"title":"介绍下 HTTPS 中间人攻击","answer":"<p>HTTPS中间人攻击（MITM）是攻击者伪装成通信双方拦截并篡改数据的行为，其核心绕过HTTPS的安全机制窃取敏感信息。</p>\n<p><strong>攻击过程与防御</strong>：</p>\n<ol>\n<li>\n<p><strong>攻击步骤</strong>：</p>\n<ul>\n<li><strong>劫持连接</strong>：攻击者通过ARP欺骗、恶意WiFi等手段成为通信中间代理。</li>\n<li><strong>伪造证书</strong>：使用自签名证书或非法CA证书欺骗客户端（如用户忽略浏览器警告）。</li>\n<li><strong>解密中转</strong>：拦截客户端与服务端的TLS握手，分别建立加密连接，明文获取数据。</li>\n</ul>\n</li>\n<li>\n<p><strong>HTTPS防御机制</strong>：</p>\n<ul>\n<li><strong>证书链校验</strong>：浏览器验证证书是否由可信CA签发，域名是否匹配，是否过期或被吊销。</li>\n<li><strong>加密传输</strong>：通过非对称加密交换密钥，后续数据由对称加密保护（如AES-256）。</li>\n</ul>\n</li>\n<li>\n<p><strong>前端注意事项</strong>：</p>\n<ul>\n<li><strong>禁用混合内容</strong>：确保页面内所有资源（图片、脚本）均为HTTPS，避免降级攻击。</li>\n<li><strong>启用HSTS</strong>：通过HTTP头<code>Strict-Transport-Security</code>强制浏览器仅使用HTTPS。</li>\n<li><strong>用户教育</strong>：提示用户切勿在浏览器证书告警页面继续访问。</li>\n</ul>\n</li>\n</ol>\n<p><strong>真实案例</strong>：公共WiFi中攻击者伪造银行网站，诱导用户输入账号密码。HTTPS若正确配置可拦截此类攻击，但用户主动忽略证书错误仍会中招。</p>\n"},{"title":"DNS 协议了解多少？","answer":"<p>DNS协议是互联网中将域名转换为IP地址的核心系统，确保用户通过易记的域名访问网络资源。</p>\n<p><strong>核心要点</strong>：</p>\n<ol>\n<li>\n<p><strong>核心功能</strong>：</p>\n<ul>\n<li><strong>域名解析</strong>：将<code>www.example.com</code>转换为<code>93.184.216.34</code>（IPv4）或<code>2606:2800:220:1:248:1893:25c8:1946</code>（IPv6）。</li>\n<li><strong>分层结构</strong>：\n<ul>\n<li><strong>根域名服务器</strong>：全球13组，指向顶级域（如<code>.com</code>）。</li>\n<li><strong>顶级域（TLD）服务器</strong>：管理<code>.com</code>、<code>.org</code>等后缀。</li>\n<li><strong>权威域名服务器</strong>：托管具体域名的IP记录（如<code>example.com</code>）。</li>\n<li><strong>本地DNS服务器</strong>：由ISP或企业提供，缓存查询结果。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>查询流程</strong>（以访问<code>www.example.com</code>为例）：</p>\n<ul>\n<li><strong>递归查询</strong>（客户端→本地DNS）：\n<ol>\n<li>客户端向本地DNS请求解析。</li>\n<li>本地DNS依次查询根→<code>.com</code>→<code>example.com</code>权威服务器，最终返回IP。</li>\n</ol>\n</li>\n<li><strong>迭代查询</strong>（本地DNS自主完成多级查询）。</li>\n</ul>\n</li>\n<li>\n<p><strong>记录类型</strong>：</p>\n<ul>\n<li><strong>A记录</strong>：IPv4地址。</li>\n<li><strong>AAAA记录</strong>：IPv6地址。</li>\n<li><strong>CNAME</strong>：域名别名（如将<code>blog.example.com</code>指向<code>example.com</code>）。</li>\n<li><strong>MX记录</strong>：邮件服务器地址（如<code>mail.example.com</code>）。</li>\n<li><strong>TXT记录</strong>：文本信息（如SPF反垃圾邮件配置）。</li>\n</ul>\n</li>\n<li>\n<p><strong>协议细节</strong>：</p>\n<ul>\n<li><strong>传输协议</strong>：默认UDP 53端口（快速），数据超512字节或区域传输时用TCP。</li>\n<li><strong>缓存机制</strong>：TTL（生存时间）控制缓存有效期，减少重复查询。</li>\n</ul>\n</li>\n<li>\n<p><strong>安全性</strong>：</p>\n<ul>\n<li><strong>DNS劫持</strong>：篡改解析结果（如恶意WiFi）。</li>\n<li><strong>DNSSEC</strong>：通过数字签名验证响应真实性，防篡改。</li>\n<li><strong>DoH/DoT</strong>：DNS over HTTPS/TLS加密查询，防窃听。</li>\n</ul>\n</li>\n</ol>\n<p><strong>前端相关</strong>：</p>\n<ul>\n<li><strong>性能优化</strong>：减少DNS查询次数（合并域名、预解析<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>）。</li>\n<li><strong>CDN加速</strong>：通过智能DNS解析用户至最近节点。</li>\n</ul>\n<p><strong>示例命令</strong>：</p>\n<pre><code class=\"language-bash\"><div class=\"language-bash \"><span class=\"lang\">bash</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#59873A\">nslookup</span><span style=\"color:#B56959\"> www.example.com</span><span style=\"color:#A0ADA0\">      # 查询A记录  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">dig</span><span style=\"color:#B56959\"> example.com</span><span style=\"color:#B56959\"> MX</span><span style=\"color:#A0ADA0\">            # 查询MX记录  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>总结</strong>：DNS是互联网的“电话簿”，其高效解析依赖分层架构与缓存，安全性需结合DNSSEC和加密协议保障。</p>\n"},{"title":"什么是正向代理，反向代理?","answer":"<p>正向代理是<strong>客户端</strong>的代理，帮助客户端访问外部资源；反向代理是<strong>服务端</strong>的代理，替服务器接收并分发客户端请求。</p>\n<p><strong>正向代理（Forward Proxy）</strong></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li><strong>代理对象</strong>：代表客户端（如浏览器）访问目标服务器。</li>\n<li><strong>隐藏客户端</strong>：目标服务器只知道代理的IP，无法识别真实用户。</li>\n<li><strong>用途</strong>：\n<ul>\n<li>突破访问限制（如科学上网）；</li>\n<li>统一控制客户端访问权限（如企业内网过滤）；</li>\n<li>缓存资源加速访问（如代理服务器缓存静态文件）。<br>\n<strong>示例工具</strong>：Shadowsocks、Squid、Charles（开发调试）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>反向代理（Reverse Proxy）</strong></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li><strong>代理对象</strong>：代表服务端接收客户端请求，转发到内部服务器。</li>\n<li><strong>隐藏服务端</strong>：客户端不知道真实服务器IP，仅与代理交互。</li>\n<li><strong>用途</strong>：\n<ul>\n<li>负载均衡（如Nginx轮询分发请求到多台服务器）；</li>\n<li>安全防护（如隐藏后端服务，防御DDoS攻击）；</li>\n<li>统一SSL加密（由代理处理HTTPS，降低后端压力）；</li>\n<li>路由分发（如根据URL路径指向不同服务）。<br>\n<strong>示例工具</strong>：Nginx、HAProxy、Cloudflare CDN。</li>\n</ul>\n</li>\n</ul>\n<p><strong>对比总结</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>特征</strong></th>\n<th>正向代理</th>\n<th>反向代理</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>代理方向</strong></td>\n<td>客户端→代理→外部服务器</td>\n<td>客户端→代理→内部服务器</td>\n</tr>\n<tr>\n<td><strong>隐藏对象</strong></td>\n<td>客户端IP</td>\n<td>服务端IP和架构</td>\n</tr>\n<tr>\n<td><strong>客户端感知</strong></td>\n<td>需配置代理地址</td>\n<td>无感知，代理对客户端透明</td>\n</tr>\n<tr>\n<td><strong>典型场景</strong></td>\n<td>内网翻墙、缓存加速</td>\n<td>负载均衡、SSL卸载、API网关</td>\n</tr>\n</tbody>\n</table>\n<p><strong>前端应用场景</strong>：</p>\n<ul>\n<li><strong>正向代理</strong>：本地开发中配置Webpack代理解决跨域（如<code>devServer.proxy</code>）；</li>\n<li><strong>反向代理</strong>：生产环境用Nginx转发请求，实现动静分离或接口聚合。</li>\n</ul>\n"},{"title":"什么是 JWT","answer":"<p>JWT（JSON Web Token）是一种<strong>开放标准（RFC 7519）的轻量级身份验证和授权协议</strong>，通过JSON格式安全传输信息，通常用于无状态的用户身份验证。</p>\n<p><strong>核心组成</strong></p>\n<ol>\n<li>\n<p><strong>Header（头部）</strong>：</p>\n<ul>\n<li>声明令牌类型（<code>typ: &quot;JWT&quot;</code>）和签名算法（如<code>alg: &quot;HS256&quot;</code>）。</li>\n<li>示例：<code>{&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}</code> → Base64编码。</li>\n</ul>\n</li>\n<li>\n<p><strong>Payload（载荷）</strong>：</p>\n<ul>\n<li>携带用户身份数据（如用户ID、角色）和其他声明（如过期时间<code>exp</code>、签发者<code>iss</code>）。</li>\n<li>示例：<code>{&quot;sub&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;exp&quot;: 1717020000}</code> → Base64编码。</li>\n</ul>\n</li>\n<li>\n<p><strong>Signature（签名）</strong>：</p>\n<ul>\n<li>对前两部分拼接后的字符串，通过密钥（如<code>secretKey</code>）和指定算法（如HMAC SHA256）生成签名，防止数据篡改。</li>\n<li>公式：<code>签名 = HMACSHA256(base64(Header) + &quot;.&quot; + base64(Payload), secretKey)</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>工作流程</strong></p>\n<ol>\n<li><strong>登录认证</strong>：\n<ul>\n<li>用户提交凭证（如账号密码），服务端验证通过后生成JWT返回客户端。</li>\n</ul>\n</li>\n<li><strong>携带令牌</strong>：\n<ul>\n<li>客户端后续请求在<code>Authorization</code>头中添加<code>Bearer &lt;JWT&gt;</code>。</li>\n</ul>\n</li>\n<li><strong>服务端验证</strong>：\n<ul>\n<li>解析JWT签名是否有效，校验载荷（如是否过期）后授权访问。</li>\n</ul>\n</li>\n</ol>\n<p><strong>优点</strong></p>\n<ul>\n<li><strong>无状态</strong>：服务端无需存储会话（如Session），适合分布式系统。</li>\n<li><strong>跨域支持</strong>：轻松实现单点登录（SSO）。</li>\n<li><strong>数据自包含</strong>：减少数据库查询（如直接从Payload读取用户ID）。</li>\n</ul>\n<p><strong>缺点与注意事项</strong></p>\n<ul>\n<li><strong>无法主动失效</strong>：令牌在过期前有效（可通过黑名单或短有效期缓解）。</li>\n<li><strong>数据暴露风险</strong>：Payload仅Base64编码，敏感信息需加密（如JWE）。</li>\n<li><strong>存储安全</strong>：前端需防XSS攻击（避免<code>localStorage</code>，优先<code>HttpOnly Cookie</code>）。</li>\n</ul>\n<p><strong>前端应用示例</strong></p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 存储JWT  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">localStorage</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">setItem</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">token</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> jwt</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 请求时携带  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">fetch</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">/api/data</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#998418\">  headers</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B5695977\">    '</span><span style=\"color:#B56959\">Authorization</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> `</span><span style=\"color:#B56959\">Bearer </span><span style=\"color:#1E754F\">${</span><span style=\"color:#B56959\">localStorage</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">getItem</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">token</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span><span style=\"color:#1E754F\">}</span><span style=\"color:#B5695977\">`</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>总结</strong>：JWT适用于无状态、跨服务的认证场景，但需结合业务权衡安全性与便利性。</p>\n"},{"title":"如何避免缓存问题导致的资源更新失败？","answer":"<p>避免缓存导致资源更新失败的核心策略是<strong>强制客户端获取最新版本</strong>，可通过文件名哈希、版本号或缓存控制头实现。</p>\n<p><strong>具体方法</strong>：</p>\n<ol>\n<li>\n<p><strong>文件名哈希</strong>：</p>\n<ul>\n<li>构建工具（如Webpack）为资源生成唯一哈希（如<code>app.a3b4c5.js</code>），文件内容变化则哈希改变，直接更新引用路径。</li>\n</ul>\n</li>\n<li>\n<p><strong>查询参数版本化</strong>：</p>\n<ul>\n<li>在资源URL后添加版本参数（如<code>style.css?v=2.0.0</code>），更新版本号即可刷新缓存。</li>\n</ul>\n</li>\n<li>\n<p><strong>HTTP缓存头控制</strong>：</p>\n<ul>\n<li><strong>HTML文件</strong>：设置<code>Cache-Control: no-cache</code>或<code>max-age=0</code>，确保始终验证更新。</li>\n<li><strong>静态资源</strong>：设置长缓存<code>Cache-Control: max-age=31536000</code>，依赖文件名哈希（内容变则URL变）。</li>\n</ul>\n</li>\n<li>\n<p><strong>服务端配置</strong>：</p>\n<ul>\n<li>CDN或Nginx配置<code>ETag</code>/<code>Last-Modified</code>，结合内容变化自动刷新缓存。</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">&#x3C;!-- 文件名哈希 --></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">/app.3e4f5a.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">>  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">&#x3C;!-- 查询参数 --></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">/styles.css?v=20231001</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>总结</strong>：哈希文件名是生产环境最佳实践，开发环境可结合禁用缓存（如Chrome DevTools禁用缓存选项）快速调试。</p>\n"},{"title":"HTTPS 中的 SSL/TLS 是什么？","answer":"<p>HTTPS（Hypertext Transfer Protocol Secure）是HTTP的安全版本，它通过SSL/TLS协议对数据进行加密，确保数据在传输过程中保持机密性和完整性。下面是对SSL和TLS的详细介绍：</p>\n<p><strong>SSL（Secure Sockets Layer）</strong></p>\n<ul>\n<li><strong>定义</strong>：SSL是最早的安全协议，用于在网络上加密传输的数据。它确保数据在客户端和服务器之间的传输是安全的。</li>\n<li><strong>历史</strong>：SSL最初由Netscape开发，主要包括SSL 2.0和SSL 3.0两个版本。由于SSL 2.0和SSL 3.0存在一些安全漏洞，它们已经被淘汰。</li>\n</ul>\n<p><strong>TLS（Transport Layer Security）</strong></p>\n<ul>\n<li><strong>定义</strong>：TLS是SSL的继任者，是一种用于保护网络通信的加密协议。TLS对数据进行加密，确保数据在传输过程中不被窃取或篡改。</li>\n<li><strong>版本</strong>：TLS 从 TLS 1.0 开始，到当前的 TLS 1.3。每个版本都在前一个版本的基础上进行改进，增强了安全性和性能。</li>\n</ul>\n<p><strong>SSL/TLS 工作原理</strong></p>\n<ol>\n<li><strong>握手过程（Handshake）</strong>\n<ul>\n<li><strong>客户端发起连接</strong>：客户端向服务器发送一个“ClientHello”消息，包含了客户端支持的加密算法、TLS版本等信息。</li>\n<li><strong>服务器响应</strong>：服务器回应一个“ServerHello”消息，选择加密算法、TLS版本并发送服务器的数字证书。</li>\n<li><strong>证书验证</strong>：客户端使用服务器提供的证书验证服务器的身份。如果证书有效，客户端会生成一个“pre-master secret”并用服务器的公钥加密后发送给服务器。</li>\n<li><strong>密钥交换</strong>：服务器使用其私钥解密“pre-master secret”，双方使用这个密钥生成对称加密密钥（session key），用于加密后续的通信数据。</li>\n</ul>\n</li>\n<li><strong>数据加密和传输</strong>\n<ul>\n<li><strong>加密数据</strong>：客户端和服务器使用会话密钥对数据进行加密，然后进行数据传输。</li>\n<li><strong>数据完整性</strong>：数据不仅被加密，还通过消息认证码（MAC）进行完整性检查，防止数据被篡改。</li>\n</ul>\n</li>\n<li><strong>连接关闭</strong>\n<ul>\n<li><strong>关闭连接</strong>：当通信结束时，双方会通过“close_notify”消息来优雅地关闭连接，确保所有的数据都被正确传输。</li>\n</ul>\n</li>\n</ol>\n<p><strong>SSL/TLS 主要功能</strong></p>\n<ul>\n<li><strong>加密</strong>：SSL/TLS通过对数据进行加密，保护数据在传输过程中不被窃取。</li>\n<li><strong>身份验证</strong>：通过数字证书验证服务器的身份，防止中间人攻击。</li>\n<li><strong>数据完整性</strong>：通过消息认证码（MAC）确保数据在传输过程中没有被篡改。</li>\n</ul>\n<p><strong>常见的 SSL/TLS 证书类型</strong></p>\n<ul>\n<li><strong>自签名证书</strong>：由证书持有者自己签发的证书，通常用于开发和测试环境，不被浏览器信任。</li>\n<li><strong>域名验证证书（DV）</strong>：验证申请者对域名的控制权，适合个人和小型网站。</li>\n<li><strong>组织验证证书（OV）</strong>：验证申请者的身份和组织合法性，适合企业和组织。</li>\n<li><strong>扩展验证证书（EV）</strong>：提供最高级别的身份验证和信任，显示公司名称在地址栏中。</li>\n</ul>\n"},{"title":"前端单页应用 History 路由模式， 需要如何配置 nginx？","answer":"<p>前端单页应用使用 History 路由模式，需要将路由的控制交给前端，而不是后端处理，因此需要配置 nginx 让其将所有请求都指向 index.html 页面，让前端来处理路由。</p>\n<p>具体配置可以参考以下 nginx 配置：</p>\n<pre><code><div class=\"language- \"><span class=\"lang\"></span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span>bashCopy codeserver {</span></span>\n<span class=\"line\"><span>    listen       80;</span></span>\n<span class=\"line\"><span>    server_name  example.com; # 域名或 IP 地址</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    location / {</span></span>\n<span class=\"line\"><span>        root   /path/to/your/app; # 项目根目录</span></span>\n<span class=\"line\"><span>        index  index.html;</span></span>\n<span class=\"line\"><span>        try_files $uri $uri/ /index.html; # 将所有请求都指向 index.html 页面</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span></code></pre></div></code></pre>\n<p>以上配置中，<code>try_files</code> 指令会尝试将请求映射到对应的文件，如果找不到，则会将请求转发到 <code>/index.html</code> 页面，由前端来处理路由。同时，<code>root</code> 指令需要指向前端应用的根目录。</p>\n"}]