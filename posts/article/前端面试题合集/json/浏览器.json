[{"title":"常见的浏览器内核有哪些？","answer":""},{"title":"说一说从输入URL到页面呈现发生了什么？","answer":"<p><a href=\"#browser\">从浏览器输入url后都经历了什么</a></p>\n"},{"title":"浏览器重绘域重排的区别？","answer":"<p><a href=\"#reflow-and-repaint\">浏览器重绘域重排的区别？</a></p>\n"},{"title":"CSS加载会阻塞DOM吗？","answer":""},{"title":"script 标签defer和async的区别？","answer":""},{"title":"html文档渲染过程，css文件和js文件的下载，是否会阻塞渲染？","answer":"<p>浏览器内有多个进程，其中渲染进程被称为浏览器内核，负责页面渲染和执行 JS 脚本等。渲染进程负责浏览器的解析和渲染，内部有 JS 引擎线程、 GUI 渲染线程、事件循环管理线程、定时器线程、HTTP 线程。</p>\n<p>JS 引擎线程负责执行 JS 脚本，GUI 渲染线程负责页面的解析和渲染，两者是互斥的，也就是执行 JS 的时候页面是停止解析和渲染的。这是因为如果在页面渲染的同时 JS 引擎修改了页面元素，比如清空页面，会造成后续页面渲染的不必要和错误。而由于 JS 经常要操作 DOM ，就要涉及 JS 引擎线程和 GUI 渲染线程的通信，而线程间通信代价是非常昂贵的，这也是造成 JS 操作 DOM 效率不高的原因。</p>\n<p>浏览器的 HTML/CSS 的解析和渲染都属于 GUI渲染线程，所以和 JS 引擎线程是互斥、阻塞的。下面从代码实际运行的角度分析浏览器解析和渲染的顺序，以及互相间的阻塞关系。</p>\n<p><strong>CSS 阻塞</strong></p>\n<ul>\n<li>css 文件的下载和解析不会影响 DOM 的解析，但是会阻塞 DOM 的渲染。因为 CSSOM Tree 要和 DOM Tree 合成 Render Tree 才能绘制页面。下面的 test1 在 css 下载并解析完成前是默认样式， test2 在 css 下载并解析完成之前不会显示：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#B07D48\"> class</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">btn btn-primary</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test1</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test2</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>css 文件没下载并解析完成之前，后续的 js 脚本不能执行。下面的 alert('ok') 在 css 下载并解析完成之前不会弹出来：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    alert</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">ok</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>css 文件的下载不会阻塞前面的 js 脚本执行。下面的 alert('ok') 会在 css 下载完成前弹出：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    alert</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">ok</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p>所以在需要提前执行不操作 dom 元素的 js 时，不妨把 js 放到 css 文件之前。</p>\n<p><strong>js 阻塞</strong></p>\n<p>js 文件的下载和解析会阻塞 GUI 渲染进程，也就是会阻塞 DOM 和 CSS 的解析和渲染。</p>\n<p>js 文件没下载并解析完成之前，后续的 HTML 和 CSS 无法解析：</p>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>js 文件的下载不会阻塞前面 HTML 和 CSS 的解析：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>需要注意的点</strong></p>\n<ul>\n<li>第一，GUI 渲染线程会尽可能早的将内容呈现到屏幕上，并不会等到所有的 HTML 都解析完成之后再去构建和布局 Render Tree，而是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。下面 test1 会在 js 文件下载完成前渲染完成，而 test2 则会在 js 文件下载并执行完之后渲染：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test1</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test2</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>第二，文件的下载是不会被阻塞的，不管是 css 还是 js 文件，浏览器的主线程会在页面解析前开启下载，所以就算在外部脚本执行前删除脚本，脚本也还是会下载。</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">body</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    document</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">body</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">remove</span><span style=\"color:#999999\">()</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">>  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">body</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n"},{"title":"解释 JavaScript 的垃圾回收机制","answer":""},{"title":"浏览器有哪几种缓存，各种缓存的优先级是什么样的？","answer":""},{"title":"什么是浏览器的同源策略，以及跨域？","answer":"<p><a href=\"#cross-origin\">跨域的处理方案有哪些？</a></p>\n"},{"title":"请解释一下浏览器引擎的工作原理是什么？","answer":""},{"title":"V8引擎是什么，它是如何提高JavaScript执行性能的？","answer":""},{"title":"浏览器一帧都会干些什么？","answer":"<ul>\n<li>接受输入事件</li>\n<li>执行事件回调</li>\n<li>开始一帧</li>\n<li>执行 RAF (RequestAnimationFrame)</li>\n<li>页面布局，样式计算</li>\n<li>绘制渲染</li>\n<li>执行 RIC (RequestIdelCallback)</li>\n</ul>\n<p>第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。</p>\n"}]