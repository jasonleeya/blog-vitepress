[{"title":"常见的浏览器内核有哪些？","description":"","answer":"<p>浏览器内核的核心是<strong>实现网页渲染和脚本执行的基础引擎</strong>，常见内核可分为渲染引擎与 JavaScript 引擎两类。以下是具体分类与代表浏览器：</p>\n<p><strong>一、渲染引擎（Rendering Engine）</strong></p>\n<ol>\n<li><strong>Trident（IE 内核）</strong>\n<ul>\n<li><strong>特点</strong>：微软开发，兼容旧版 IE 标准，性能较差。</li>\n<li><strong>代表浏览器</strong>：IE（已停更）、旧版 Edge（2019 年前）、国内双核浏览器的兼容模式（如 360 浏览器）。</li>\n</ul>\n</li>\n<li><strong>Gecko（Firefox 内核）</strong>\n<ul>\n<li><strong>特点</strong>：开源，支持现代 Web 标准严格，扩展性强。</li>\n<li><strong>代表浏览器</strong>：Mozilla Firefox、Waterfox。</li>\n</ul>\n</li>\n<li><strong>WebKit（Safari 内核）</strong>\n<ul>\n<li><strong>特点</strong>：苹果主导，轻量高效，移动端优化。</li>\n<li><strong>代表浏览器</strong>：Safari、旧版 Chrome（2013 年前）。</li>\n</ul>\n</li>\n<li><strong>Blink（Chrome/Edge 内核）</strong>\n<ul>\n<li><strong>特点</strong>：WebKit 的分支，Google 主导开发，高性能，快速迭代。</li>\n<li><strong>代表浏览器</strong>：Chrome、新版 Edge（2019 后）、Opera、大部分国产浏览器（如 QQ 浏览器）。</li>\n</ul>\n</li>\n<li><strong>Presto（已废弃）</strong>\n<ul>\n<li><strong>特点</strong>：Opera 自主研发，渲染速度快，兼容性差。</li>\n<li><strong>历史浏览器</strong>：Opera（2013 年前）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、JavaScript 引擎</strong></p>\n<ol>\n<li><strong>V8（Chrome/Node.js）</strong>\n<ul>\n<li><strong>特点</strong>：Google 开发，高性能，支持即时编译（JIT）。</li>\n</ul>\n</li>\n<li><strong>SpiderMonkey（Firefox）</strong>\n<ul>\n<li><strong>特点</strong>：Mozilla 开发，首个 JavaScript 引擎。</li>\n</ul>\n</li>\n<li><strong>JavaScriptCore（Safari）</strong>\n<ul>\n<li><strong>特点</strong>：苹果开发，原名 Nitro，针对移动端优化。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、国内浏览器内核现状</strong></p>\n<ol>\n<li><strong>双核模式</strong>：\n<ul>\n<li>兼容模式：Trident（处理老旧政府/企业网站）。</li>\n<li>极速模式：Blink（默认模式，如 360 浏览器、搜狗浏览器）。</li>\n</ul>\n</li>\n<li><strong>自主内核（探索阶段）</strong>：\n<ul>\n<li>如华为 HarmonyOS 的 Ark 引擎（基于 Chromium 二次开发）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>四、核心差异与趋势</strong></p>\n<ul>\n<li><strong>性能对比</strong>：Blink &gt; WebKit &gt; Gecko &gt; Trident。</li>\n<li><strong>市场份额</strong>：Blink（Chrome/Edge 主导）&gt; WebKit（Safari 移动端优势）。</li>\n<li><strong>开发方向</strong>：Blink 持续推动 Web 新特性（如 WebGPU），Trident 逐渐淘汰。</li>\n</ul>\n<p><strong>总结</strong>：现代浏览器以 Blink 和 WebKit 为主流内核，兼容性测试需覆盖 Chrome、Safari、Firefox，国内项目额外关注双核浏览器的 Trident 模式。</p>\n"},{"title":"说一说从输入 URL 到页面呈现发生了什么？","description":"","answer":"<p><a href=\"#browser\" target=\"_blank\" rel=\"noopener noreferrer\">从浏览器输入url后都经历了什么</a></p>\n"},{"title":"浏览器重绘域重排的区别？","description":"","answer":"<p><a href=\"#reflow-and-repaint\" target=\"_blank\" rel=\"noopener noreferrer\">浏览器重绘域重排的区别？</a></p>\n"},{"title":"CSS 加载会阻塞 DOM 吗？","description":"","answer":"<p>CSS加载<strong>不会阻塞DOM的解析</strong>，但<strong>会阻塞页面的渲染</strong>。</p>\n<p>具体来说：</p>\n<ol>\n<li><strong>DOM解析不阻塞</strong>：浏览器会并行解析HTML和下载CSS文件，DOM树的构建可继续进行。</li>\n<li><strong>渲染阻塞</strong>：浏览器需等待CSSOM（CSS对象模型）构建完成后，才会生成渲染树（Render Tree），因此页面内容会保持空白，直到CSS加载完成。</li>\n<li><strong>优化手段</strong>：\n<ul>\n<li><strong>内联关键CSS</strong>：首屏样式直接写入HTML，减少外链阻塞时间。</li>\n<li><strong>异步加载非关键CSS</strong>：通过<code>&lt;link media=&quot;print&quot; onload=&quot;this.media='all'&quot;&gt;</code>实现异步加载。</li>\n<li><strong>CDN加速</strong>：缩短CSS文件加载耗时。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"script 标签 defer 和 async 的区别？","description":"","answer":"<p><code>defer</code> 和 <code>async</code> 是用于优化脚本加载的 HTML 属性，<strong>核心区别在于脚本的执行时机和顺序</strong>：</p>\n<p>一句话总结：</p>\n<ul>\n<li><strong><code>async</code></strong>：异步下载，下载完成后立即执行（执行顺序不确定）。</li>\n<li><strong><code>defer</code></strong>：异步下载，延迟到 HTML 解析完成后按顺序执行。</li>\n</ul>\n"},{"title":" html文档渲染过程，css 文件和 js 文件的下载，是否会阻塞渲染？","description":"","answer":"<p>浏览器内有多个进程，其中渲染进程被称为浏览器内核，负责页面渲染和执行 JS 脚本等。渲染进程负责浏览器的解析和渲染，内部有 JS 引擎线程、 GUI 渲染线程、事件循环管理线程、定时器线程、HTTP 线程。</p>\n<p>JS 引擎线程负责执行 JS 脚本，GUI 渲染线程负责页面的解析和渲染，两者是互斥的，也就是执行 JS 的时候页面是停止解析和渲染的。这是因为如果在页面渲染的同时 JS 引擎修改了页面元素，比如清空页面，会造成后续页面渲染的不必要和错误。而由于 JS 经常要操作 DOM ，就要涉及 JS 引擎线程和 GUI 渲染线程的通信，而线程间通信代价是非常昂贵的，这也是造成 JS 操作 DOM 效率不高的原因。</p>\n<p>浏览器的 HTML/CSS 的解析和渲染都属于 GUI渲染线程，所以和 JS 引擎线程是互斥、阻塞的。下面从代码实际运行的角度分析浏览器解析和渲染的顺序，以及互相间的阻塞关系。</p>\n<p><strong>CSS 阻塞</strong></p>\n<ul>\n<li>css 文件的下载和解析不会影响 DOM 的解析，但是会阻塞 DOM 的渲染。因为 CSSOM Tree 要和 DOM Tree 合成 Render Tree 才能绘制页面。下面的 test1 在 css 下载并解析完成前是默认样式， test2 在 css 下载并解析完成之前不会显示：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#B07D48\"> class</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">btn btn-primary</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test1</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test2</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>css 文件没下载并解析完成之前，后续的 js 脚本不能执行。下面的 alert('ok') 在 css 下载并解析完成之前不会弹出来：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    alert</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">ok</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>css 文件的下载不会阻塞前面的 js 脚本执行。下面的 alert('ok') 会在 css 下载完成前弹出：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    alert</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">ok</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p>所以在需要提前执行不操作 dom 元素的 js 时，不妨把 js 放到 css 文件之前。</p>\n<p><strong>js 阻塞</strong></p>\n<p>js 文件的下载和解析会阻塞 GUI 渲染进程，也就是会阻塞 DOM 和 CSS 的解析和渲染。</p>\n<p>js 文件没下载并解析完成之前，后续的 HTML 和 CSS 无法解析：</p>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>js 文件的下载不会阻塞前面 HTML 和 CSS 的解析：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>需要注意的点</strong></p>\n<ul>\n<li>第一，GUI 渲染线程会尽可能早的将内容呈现到屏幕上，并不会等到所有的 HTML 都解析完成之后再去构建和布局 Render Tree，而是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。下面 test1 会在 js 文件下载完成前渲染完成，而 test2 则会在 js 文件下载并执行完之后渲染：</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test1</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">test2</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li>第二，文件的下载是不会被阻塞的，不管是 css 还是 js 文件，浏览器的主线程会在页面解析前开启下载，所以就算在外部脚本执行前删除脚本，脚本也还是会下载。</li>\n</ul>\n<pre><code class=\"language-html\"><div class=\"language-html \"><span class=\"lang\">html</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">body</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    document</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">body</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">remove</span><span style=\"color:#999999\">()</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">>  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">link</span><span style=\"color:#B07D48\"> rel</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">stylesheet</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> href</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#B07D48\"> src</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">https://code.jquery.com/jquery-3.4.1.js</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">body</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n"},{"title":"解释 JavaScript 的垃圾回收机制","description":"","answer":"<p>JavaScript 的垃圾回收机制核心是<strong>自动管理内存，释放不再使用的对象所占用的内存空间</strong>。具体实现如下：</p>\n<p><strong>一、核心机制</strong></p>\n<ol>\n<li><strong>标记清除（Mark-Sweep）</strong>\n<ul>\n<li><strong>标记阶段</strong>：从根对象（全局变量、活动函数作用域链）出发，递归标记所有可达对象为“活动对象”。</li>\n<li><strong>清除阶段</strong>：遍历堆内存，回收未被标记的不可达对象。</li>\n<li><strong>优势</strong>：解决循环引用问题（现代浏览器主要算法）。</li>\n</ul>\n</li>\n<li><strong>引用计数（Reference Counting）</strong>\n<ul>\n<li><strong>原理</strong>：记录每个对象被引用的次数，当引用数为 0 时立即回收。</li>\n<li><strong>缺陷</strong>：无法处理循环引用（如两个对象互相引用），已逐渐被淘汰。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、内存泄漏常见场景</strong></p>\n<ol>\n<li>\n<p><strong>未释放的闭包</strong>：函数内部变量被外部引用，导致外部函数作用域无法回收。</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> createLeak</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  const</span><span style=\"color:#B07D48\"> data</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> new</span><span style=\"color:#59873A\"> Array</span><span style=\"color:#999999\">(</span><span style=\"color:#2F798A\">1e6</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 大对象</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#B07D48\"> console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">log</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">data</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 闭包保留 data 的引用</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> leak</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> createLeak</span><span style=\"color:#999999\">();</span><span style=\"color:#A0ADA0\"> // data 无法被回收</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>未清理的 DOM 引用</strong>：移除 DOM 元素后，未清除其 JS 变量引用。</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> button</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> document</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">getElementById</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">btn</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">document</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">body</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">removeChild</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">button</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // DOM 被移除</span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// button 变量仍引用该 DOM 对象 → 内存泄漏</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>未清除的定时器/事件监听</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> timer</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> setInterval</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {},</span><span style=\"color:#2F798A\"> 1000</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 忘记 clearInterval(timer) → 定时器持续占用内存</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ol>\n<p><strong>三、优化实践</strong></p>\n<ol>\n<li><strong>手动解除引用</strong>：不再使用的对象设为 <code>null</code>（如 <code>data = null</code>）。</li>\n<li><strong>弱引用</strong>：使用 <code>WeakMap</code>/<code>WeakSet</code>（键为弱引用，不影响垃圾回收）。</li>\n<li><strong>避免内存膨胀</strong>：分页加载大数据集，及时销毁无用缓存。</li>\n</ol>\n<p><strong>总结</strong>：理解垃圾回收机制可有效预防内存泄漏，关键是通过作用域管理和资源清理，确保对象及时变为“不可达”状态。</p>\n"},{"title":"浏览器有哪几种缓存，各种缓存的优先级是什么样的？","description":"","answer":"<p>浏览器缓存的核心是<strong>通过多级缓存策略减少网络请求，提升加载速度</strong>。优先级由高到低依次为：</p>\n<p><strong>一、缓存类型与优先级</strong></p>\n<ol>\n<li><strong>Service Worker 缓存</strong>（最高优先级）\n<ul>\n<li><strong>特点</strong>：可编程控制缓存策略，支持离线访问。</li>\n<li><strong>场景</strong>：PWA 应用、自定义缓存逻辑（如优先返回缓存，失败再请求网络）。</li>\n</ul>\n</li>\n<li><strong>Memory Cache（内存缓存）</strong>\n<ul>\n<li><strong>特点</strong>：浏览器内存缓存，快速读取但随进程关闭释放。</li>\n<li><strong>场景</strong>：页面刷新时，相同资源（如 Base64 图片）直接从内存加载。</li>\n</ul>\n</li>\n<li><strong>Disk Cache（磁盘缓存）</strong>\n<ul>\n<li><strong>特点</strong>：持久化缓存，容量大但读取速度较慢。</li>\n<li><strong>子类</strong>：\n<ul>\n<li><strong>强缓存</strong>（<code>Cache-Control</code> / <code>Expires</code>）：直接使用本地缓存，不发送请求。</li>\n<li><strong>协商缓存</strong>（<code>Last-Modified</code> / <code>ETag</code>）：发送请求验证，返回 <code>304</code> 复用缓存。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Push Cache（推送缓存）</strong>（最低优先级）\n<ul>\n<li><strong>特点</strong>：HTTP/2 服务器推送的临时缓存，会话结束即失效。</li>\n<li><strong>场景</strong>：多页面共享资源（如同一 CDN 的字体文件）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、缓存匹配流程</strong></p>\n<ol>\n<li><strong>请求资源时</strong>：\n<ul>\n<li><strong>Service Worker</strong> → <strong>Memory Cache</strong> → <strong>Disk Cache（强缓存优先）</strong> → <strong>Push Cache</strong> → <strong>网络请求（协商缓存）</strong>。</li>\n</ul>\n</li>\n<li><strong>示例</strong>：\n<ul>\n<li>若资源在 Service Worker 中命中，直接返回，不再检查其他缓存。</li>\n<li>若强缓存（如 <code>Cache-Control: max-age=3600</code>）有效，跳过网络请求。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、用户行为对缓存的影响</strong></p>\n<ul>\n<li><strong>正常刷新</strong>：跳过强缓存，触发协商缓存（可能返回 <code>304</code>）。</li>\n<li><strong>强制刷新（Ctrl+F5）</strong>：忽略所有缓存，直接请求最新资源。</li>\n<li><strong>关闭标签页</strong>：Memory Cache 失效，Disk Cache 保留。</li>\n</ul>\n<p><strong>总结</strong>：Service Worker 优先级最高，其次是内存和磁盘缓存，最后是 HTTP/2 推送缓存。合理配置 <code>Cache-Control</code> 和 <code>ETag</code> 可显著优化性能。</p>\n"},{"title":"什么是浏览器的同源策略，以及跨域？","description":"","answer":"<p><a href=\"#cross-origin\" target=\"_blank\" rel=\"noopener noreferrer\">跨域的处理方案有哪些？</a></p>\n"},{"title":"请解释一下浏览器引擎的工作原理是什么？","description":"","answer":"<p>浏览器引擎的核心工作原理是<strong>将网页代码（HTML/CSS/JS）转换为可视化页面和可交互程序</strong>，主要通过渲染引擎与 JavaScript 引擎协作完成。以下是具体流程：</p>\n<p><strong>一、核心模块分工</strong></p>\n<ol>\n<li><strong>渲染引擎（如 Blink/WebKit）</strong>\n<ul>\n<li><strong>HTML 解析</strong>：将 HTML 转换为 DOM 树（Document Object Model）。</li>\n<li><strong>CSS 解析</strong>：将 CSS 转换为 CSSOM 树（CSS Object Model）。</li>\n<li><strong>渲染树构建</strong>：合并 DOM 和 CSSOM 生成 Render Tree（仅包含可见元素）。</li>\n<li><strong>布局（Layout）</strong>：计算每个节点的几何位置（重排）。</li>\n<li><strong>绘制（Painting）</strong>：将布局结果栅格化为像素（重绘）。</li>\n<li><strong>合成（Compositing）</strong>：分层绘制，GPU 加速合成最终画面。</li>\n</ul>\n</li>\n<li><strong>JavaScript 引擎（如 V8/SpiderMonkey）</strong>\n<ul>\n<li><strong>解析（Parsing）</strong>：将 JS 代码转换为抽象语法树（AST）。</li>\n<li><strong>编译（Compilation）</strong>：即时编译（JIT）为机器码。</li>\n<li><strong>执行（Execution）</strong>：在调用栈中运行代码，通过事件循环处理异步任务。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、关键协作流程</strong></p>\n<ol>\n<li><strong>阻塞与并行</strong>\n<ul>\n<li><strong>HTML 解析</strong>：遇到 <code>&lt;script&gt;</code> 默认阻塞 DOM 构建（除非标记 <code>async/defer</code>）。</li>\n<li><strong>CSS 加载</strong>：阻塞渲染树合成（但 DOM 解析可继续）。</li>\n</ul>\n</li>\n<li><strong>关键渲染路径优化</strong>\n<ul>\n<li><strong>优化目标</strong>：最小化首次渲染时间（First Meaningful Paint）。</li>\n<li><strong>优化手段</strong>：\n<ul>\n<li>内联关键 CSS/JS</li>\n<li>预加载关键资源（<code>&lt;link rel=&quot;preload&quot;&gt;</code>）</li>\n<li>延迟非必要脚本（<code>async/defer</code>）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>交互响应机制</strong>\n<ul>\n<li><strong>事件循环（Event Loop）</strong>：通过任务队列（宏任务/微任务）调度 JS 执行与渲染更新。</li>\n<li><strong>帧率同步</strong>：<code>requestAnimationFrame</code> 确保动画与浏览器刷新率同步（通常 60fps）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、现代引擎优化特性</strong></p>\n<ol>\n<li><strong>渐进式渲染</strong>：流式解析 HTML，逐步显示内容（如 Chrome 的预渲染扫描器）。</li>\n<li><strong>GPU 加速</strong>：通过分层合成（Composite Layers）和光栅化线程减少主线程负载。</li>\n<li><strong>推测执行</strong>：预加载可能需要的资源（如 Chrome 的预加载器预测后续请求）。</li>\n</ol>\n<p><strong>四、示例引擎架构</strong></p>\n<ul>\n<li><strong>Chromium（Blink + V8）</strong>：\n<ul>\n<li>多进程架构（渲染进程、GPU 进程、浏览器主进程）</li>\n<li>支持 WebAssembly、WebGPU 等新标准</li>\n</ul>\n</li>\n<li><strong>Firefox（Gecko + SpiderMonkey）</strong>：\n<ul>\n<li>增量垃圾回收</li>\n<li>更严格的隐私保护策略</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结</strong>：浏览器引擎通过多阶段流水线将代码转化为交互式页面，其性能直接影响用户体验，理解原理有助于针对性优化网页性能。</p>\n"},{"title":"V8 引擎是什么，它是如何提高 JavaScript 执行性能的？","description":"","answer":"<p>V8 引擎是 <strong>Google 开发的高性能 JavaScript 引擎</strong>，核心目标是<strong>通过即时编译（JIT）和内存优化，让 JavaScript 执行速度接近原生代码</strong>。以下是其核心优化手段：</p>\n<p><strong>一、关键性能优化技术</strong></p>\n<ol>\n<li>\n<p><strong>即时编译（JIT）</strong></p>\n<ul>\n<li><strong>基线编译器（Ignition）</strong>：快速生成未优化的字节码，支持快速启动。</li>\n<li><strong>优化编译器（TurboFan）</strong>：根据代码运行时的类型反馈（Type Feedback）生成高度优化的机器码。</li>\n<li><strong>去优化（Deoptimization）</strong>：当假设失效（如变量类型突变）时，回退到字节码重新优化。</li>\n</ul>\n</li>\n<li>\n<p><strong>隐藏类（Hidden Class）与内联缓存（Inline Cache）</strong></p>\n<ul>\n<li>\n<p><strong>隐藏类</strong>：为动态对象的结构分配固定内存布局，减少属性访问耗时（类似静态语言的类结构）。</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 对象 a 和 b 共享同一隐藏类（结构相同）</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> a</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> x</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 1</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> y</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 2</span><span style=\"color:#999999\"> };</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> b</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> x</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 3</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> y</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 4</span><span style=\"color:#999999\"> };</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>内联缓存</strong>：缓存对象属性的内存偏移量，加速后续访问（如 <code>obj.x</code> 直接通过缓存定位）。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>高效垃圾回收（GC）</strong></p>\n<ul>\n<li><strong>分代式回收</strong>：\n<ul>\n<li><strong>新生代（Scavenge）</strong>：使用复制算法快速回收短期对象（如函数局部变量）。</li>\n<li><strong>老生代（Mark-Sweep/Compact）</strong>：标记-清除/整理算法处理长期存活对象（如全局变量）。</li>\n</ul>\n</li>\n<li><strong>增量标记与并行回收</strong>：减少主线程阻塞时间，避免页面卡顿。</li>\n</ul>\n</li>\n<li>\n<p><strong>热点代码优化</strong></p>\n<ul>\n<li><strong>函数内联（Inlining）</strong>：将小函数直接嵌入调用处，减少调用开销。</li>\n<li><strong>逃逸分析</strong>：识别未逃逸对象，直接在栈上分配内存（避免堆内存分配）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、其他优化特性</strong></p>\n<ol>\n<li><strong>WebAssembly 支持</strong>\n<ul>\n<li>直接编译 C/C++/Rust 等语言到机器码，突破 JavaScript 性能瓶颈（如游戏、音视频处理）。</li>\n</ul>\n</li>\n<li><strong>并发解析与编译</strong>\n<ul>\n<li>在后台线程预解析代码，减少主线程编译耗时（如流式解析大型脚本）。</li>\n</ul>\n</li>\n<li><strong>内存压缩指针（Pointer Compression）</strong>\n<ul>\n<li>将 64 位指针压缩为 32 位，减少内存占用（适用于堆内存小于 4GB 的场景）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、性能对比</strong></p>\n<ul>\n<li><strong>解释执行（如早期 JS 引擎）</strong>：逐行翻译代码，速度慢。</li>\n<li><strong>V8 JIT 优化</strong>：通过动态编译，性能提升 <strong>10~100 倍</strong>，接近 C++ 水平。</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 循环优化前（未编译）</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">for</span><span style=\"color:#999999\"> (</span><span style=\"color:#AB5959\">let</span><span style=\"color:#B07D48\"> i</span><span style=\"color:#999999\"> =</span><span style=\"color:#2F798A\"> 0</span><span style=\"color:#999999\">;</span><span style=\"color:#B07D48\"> i</span><span style=\"color:#999999\"> &#x3C;</span><span style=\"color:#2F798A\"> 1e6</span><span style=\"color:#999999\">;</span><span style=\"color:#B07D48\"> i</span><span style=\"color:#AB5959\">++</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#999999\"> ...</span><span style=\"color:#999999\"> }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// TurboFan 优化后生成机器码，循环速度接近原生代码</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>总结</strong>：V8 通过 JIT 编译、隐藏类、分代 GC 等设计，将 JavaScript 从解释型语言提升到接近编译型语言的性能，支撑了现代 Web 应用和高性能 Node.js 服务。</p>\n"},{"title":"浏览器一帧都会干些什么？","description":"","answer":"<ul>\n<li>接受输入事件</li>\n<li>执行事件回调</li>\n<li>开始一帧</li>\n<li>执行 RAF (RequestAnimationFrame)</li>\n<li>页面布局，样式计算</li>\n<li>绘制渲染</li>\n<li>执行 RIC (RequestIdelCallback)</li>\n</ul>\n<p>第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。</p>\n"},{"title":"浏览器并发请求数限制是多少？如何绕过？","description":"","answer":""}]