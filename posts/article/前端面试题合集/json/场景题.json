[{"title":"如何实现轮播图？","answer":"**轮播图实现的核心方案**：\r\n\r\n1. **纯CSS实现（简单轮播）**\r\n   - 使用 `CSS动画` + `@keyframes` 控制自动轮播，通过 `:hover` 暂停动画，适合静态展示。\r\n2. **原生JS + CSS过渡**\r\n   - **布局**：Flex/Grid横向排列图片，外层容器 `overflow: hidden`。\r\n   - **滑动逻辑**：监听点击事件，通过 `transform: translateX` 切换位置，结合 `transition` 实现平滑动画。\r\n   - **无限循环**：首尾添加克隆元素，切换时瞬间重置位置。\r\n3. **第三方库（快速开发）**\r\n   - 使用 **Swiper.js** 或 **Slick**，提供丰富API（分页器、懒加载、触摸滑动），适用于复杂交互需求。\r\n4. **关键细节优化**\r\n   - **自动播放**：`setInterval` 定时触发切换，离开页面时用 `visibilitychange` 暂停。\r\n   - **响应式**：监听 `resize` 事件动态调整容器尺寸。\r\n   - **指示器与导航**：动态生成分页点，绑定点击跳转逻辑。"},{"title":"如何实现前端水印功能？如何禁止别人移除？","answer":"**1. 水印实现方式**\r\n\r\n- **Canvas 绘制**\r\n  动态生成带水印的 Base64 图片，设为页面背景：\r\n\r\n  ```javascript\r\n  const createWatermark = (text) => {\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.font = '16px Arial';\r\n    ctx.fillStyle = 'rgba(0,0,0,0.1)';\r\n    ctx.rotate(-20 * Math.PI / 180);\r\n    ctx.fillText(text, 10, 70);\r\n    return canvas.toDataURL('image/png');\r\n  };\r\n  document.body.style.backgroundImage = `url(${createWatermark('Confidential')})`;\r\n  ```\r\n\r\n- **CSS 伪元素覆盖**\r\n  通过绝对定位覆盖全屏，防止遮挡交互：\r\n\r\n  ```\r\n  .watermark {\r\n    position: fixed;\r\n    pointer-events: none; /* 禁止交互 */\r\n    z-index: 9999;\r\n    opacity: 0.1;\r\n    background: repeating-linear-gradient(-45deg, #000 0 20px, transparent 20px 40px);\r\n  }\r\n  ```\r\n\r\n**2. 防移除关键策略**\r\n\r\n- **DOM 监控**\r\n  使用 `MutationObserver` 监听水印节点变化，被删时重新插入：\r\n\r\n  ```javascript\r\n  const observer = new MutationObserver((mutations) => {\r\n    mutations.forEach((mutation) => {\r\n      if (!document.getElementById('watermark')) {\r\n        document.body.appendChild(createWatermarkElement());\r\n      }\r\n    });\r\n  });\r\n  observer.observe(document.body, { childList: true });\r\n  ```\r\n\r\n- **加密混淆**\r\n  动态生成水印元素，避免固定 ID 或 Class 被针对性删除：\r\n\r\n  ```javascript\r\n  const randomAttr = `data-${Math.random().toString(36).slice(2)}`;\r\n  watermarkElement.setAttribute(randomAttr, '');\r\n  ```\r\n\r\n- **服务端配合**\r\n  关键内容（如图片/PDF）由服务端预加水印，避免纯前端依赖。"},{"title":"站点一键换肤的实现方式有哪些？","answer":"**前端一键换肤的核心实现方案**：\r\n\r\n1. **CSS变量（推荐）**\r\n   定义主题色变量，通过切换 `data-theme` 属性动态修改：\r\n\r\n   ```css\r\n   :root {\r\n     --primary-color: #2196f3;\r\n   }\r\n   [data-theme=\"dark\"] {\r\n     --primary-color: #333;\r\n   }\r\n   ```\r\n\r\n   ```javascript\r\n   document.documentElement.setAttribute('data-theme', 'dark');\r\n   ```\r\n\r\n2. **Sass/Less预处理变量**\r\n   编译多套主题CSS文件，动态切换 `<link>` 的 `href`（需提前加载）。\r\n\r\n3. **类名切换**\r\n   为不同主题定义独立类名，通过 JS 切换根元素的类：\r\n\r\n   ```css\r\n   .theme-dark { background: #000; color: #fff; }\r\n   ```\r\n\r\n4. **CSS-in-JS动态注入**\r\n   使用 styled-components 等库，结合状态管理动态生成样式。\r\n\r\n5. **CSS滤镜（简单场景）**\r\n   通过 `filter: invert(1)` 快速反色，但色彩控制粗糙。\r\n\r\n**优化细节**：\r\n\r\n- **持久化**：用 `localStorage` 存储用户选择，初始化时读取。\r\n- **平滑过渡**：为颜色属性添加 `transition` 动画。\r\n- **按需加载**：异步加载非核心主题样式，减少首屏体积。"},{"title":"实现一个图片懒加载组件","answer":"**实现图片懒加载组件的核心步骤**：\r\n\r\n1. **HTML 结构准备**\r\n   将真实图片地址存入 `data-src`，初始 `src` 使用占位图或留空：\r\n\r\n   ```html\r\n   <img class=\"lazyload\" data-src=\"real-image.jpg\" src=\"placeholder.png\">\r\n   ```\r\n\r\n2. **Intersection Observer 检测可视区域**\r\n   监听图片是否进入视口，触发加载\r\n\r\n   ```javascript\r\n   const observer = new IntersectionObserver((entries) => {\r\n     entries.forEach(entry => {\r\n       if (entry.isIntersecting) {\r\n         const img = entry.target;\r\n         img.src = img.dataset.src;\r\n         img.classList.add('loaded');\r\n         observer.unobserve(img); // 加载后停止观察\r\n       }\r\n     });\r\n   }, { rootMargin: '0px 0px 200px 0px' }); // 提前200px加载\r\n   \r\n   document.querySelectorAll('.lazyload').forEach(img => observer.observe(img));\r\n   ```\r\n\r\n3. **滚动兼容方案（备用）**\r\n   不支持 `IntersectionObserver` 时降级为滚动监听 + 节流：\r\n\r\n   ```javascript\r\n   const throttleCheck = () => {\r\n     document.querySelectorAll('.lazyload').forEach(img => {\r\n       const rect = img.getBoundingClientRect();\r\n       if (rect.top < window.innerHeight + 200) {\r\n         img.src = img.dataset.src;\r\n       }\r\n     });\r\n   };\r\n   window.addEventListener('scroll', throttle(throttleCheck, 200));\r\n   ```\r\n\r\n4. **加载效果优化**\r\n   CSS 添加过渡动画：\r\n\r\n   ```css\r\n   .lazyload {\r\n     opacity: 0;\r\n     transition: opacity 0.3s;\r\n   }\r\n   .lazyload.loaded {\r\n     opacity: 1;\r\n   }\r\n   ```\r\n\r\n5. **封装为可复用组件（Vue 示例）**\r\n\r\n   ```vue\r\n   <template>\r\n     <img :data-src=\"src\" class=\"lazyload\" :src=\"placeholder\">\r\n   </template>\r\n   \r\n   <script>\r\n   export default {\r\n     props: ['src', 'placeholder'],\r\n     mounted() {\r\n       this.initLazyLoad();\r\n     },\r\n     methods: {\r\n       initLazyLoad() {\r\n         const observer = new IntersectionObserver((entries) => {\r\n           entries.forEach(entry => {\r\n             if (entry.isIntersecting) {\r\n               entry.target.src = entry.target.dataset.src;\r\n               observer.unobserve(entry.target);\r\n             }\r\n           });\r\n         });\r\n         observer.observe(this.$el);\r\n       }\r\n     }\r\n   }\r\n   </script>\r\n   ```\r\n\r\n**优化要点**：\r\n\r\n- **性能**：优先使用 `IntersectionObserver`，滚动监听需加节流\r\n- **兼容性**：引入 `polyfill` 或降级方案\r\n- **体验**：提前加载、加载动画、错误处理（`onerror` 事件）"},{"title":"如何实现元素的拖拽功能？","answer":"1. **事件监听**\r\n   - **`mousedown`**：在目标元素上监听，记录初始鼠标位置和元素当前位置。\r\n   - **`mousemove`**：在文档（`document`）上监听，计算偏移量并实时更新元素位置（如修改 `left/top` 或 `transform`）。\r\n   - **`mouseup`**：在文档上监听，移除 `mousemove` 和 `mouseup` 事件，结束拖拽。\r\n2. **位置计算**\r\n   - 通过 `clientX/clientY` 获取鼠标坐标，结合元素初始位置计算偏移量。\r\n   - 更新元素样式时优先使用 `transform: translate()` 以提升性能。\r\n3. **交互优化**\r\n   - **防止文本选中**：在 `mousedown` 事件中设置 `user-select: none` 或调用 `event.preventDefault()`。\r\n   - **光标反馈**：动态切换 `cursor` 样式（如 `grab` 和 `grabbing`）。"},{"title":"如何实现一个拖拽排序列表","answer":"**实现拖拽排序列表的核心步骤**：\r\n\r\n1. **HTML 结构**\r\n   为列表项添加 `draggable=\"true\"` 属性，禁用默认拖拽图像：\r\n\r\n   ```html\r\n   <ul class=\"sortable-list\">\r\n     <li draggable=\"true\" data-id=\"1\">Item 1</li>\r\n     <li draggable=\"true\" data-id=\"2\">Item 2</li>\r\n   </ul>\r\n   ```\r\n\r\n2. **事件监听**\r\n   绑定关键事件：\r\n\r\n   ```javascript\r\n   let draggedItem = null;\r\n   \r\n   items.forEach(item => {\r\n     item.addEventListener('dragstart', handleDragStart);\r\n     item.addEventListener('dragover', handleDragOver);\r\n     item.addEventListener('dragend', handleDragEnd);\r\n   });\r\n   ```\r\n\r\n3. **拖拽逻辑**\r\n\r\n   - **记录拖拽元素**：\r\n\r\n     ```javascript\r\n     function handleDragStart(e) {\r\n       draggedItem = e.target;\r\n       e.dataTransfer.effectAllowed = 'move';\r\n       e.target.classList.add('dragging');\r\n     }\r\n     ```\r\n\r\n   - **计算插入位置**：\r\n\r\n     ```javascript\r\n     function handleDragOver(e) {\r\n       e.preventDefault();\r\n       const afterElement = getDragAfterElement(e.clientY); // 根据坐标计算插入点\r\n       const list = document.querySelector('.sortable-list');\r\n       if (afterElement) {\r\n         list.insertBefore(draggedItem, afterElement);\r\n       } else {\r\n         list.appendChild(draggedItem);\r\n       }\r\n     }\r\n     ```\r\n\r\n4. **视觉优化**\r\n\r\n   - 添加拖拽占位符和过渡动画：\r\n\r\n     ```javascript\r\n     .dragging {\r\n       opacity: 0.5;\r\n       background: #f0f0f0;\r\n     }\r\n     ```\r\n\r\n5. **框架优化（如 Vue/React）**\r\n   结合状态管理更新数据源：\r\n\r\n   ```VUE\r\n   <template>\r\n     <ul @dragover.prevent=\"handleDragOver\">\r\n       <li v-for=\"item in list\" \r\n           draggable \r\n           @dragstart=\"handleDragStart(item.id)\"\r\n           @dragend=\"handleDragEnd\">\r\n         {{ item.text }}\r\n       </li>\r\n     </ul>\r\n   </template>\r\n   \r\n   <script>\r\n   export default {\r\n     methods: {\r\n       handleDragStart(id) {\r\n         this.draggedId = id;\r\n       },\r\n       handleDragOver(e) {\r\n         const newList = [...this.list];\r\n         const from = this.list.findIndex(item => item.id === this.draggedId);\r\n         const to = this.calculateNewPosition(e); // 计算新位置\r\n         newList.splice(to, 0, newList.splice(from, 1)[0]);\r\n         this.list = newList;\r\n       }\r\n     }\r\n   }\r\n   </script>\r\n   ```\r\n\r\n**备选方案**：\r\n\r\n- **第三方库**：直接使用 Sortable.js 或 react-beautiful-dnd（React 生态）快速实现。\r\n- **移动端适配**：结合 `touchstart`/`touchmove` 事件实现触摸拖拽。"},{"title":"如何实现前端文件分片上传与断点续传","answer":"**1. 分片上传实现**\r\n\r\n- **文件分片**\r\n  使用 `Blob.slice()` 切割文件为固定大小（如 5MB/片）：\r\n\r\n  ```javascript\r\n  const chunkSize = 5 * 1024 * 1024; // 5MB\r\n  const chunks = [];\r\n  let start = 0;\r\n  while (start < file.size) {\r\n    chunks.push(file.slice(start, start + chunkSize));\r\n    start += chunkSize;\r\n  }\r\n  ```\r\n\r\n- **唯一标识**\r\n  计算文件哈希值（如 `SparkMD5`），作为分片标识：\r\n\r\n  ```javascript\r\n  const fileHash = await calculateHash(file); // Web Worker中计算\r\n  ```\r\n\r\n- **并发上传**\r\n  通过 `Promise.all` 控制并发请求数（如并发3片）：\r\n\r\n  ```javascript\r\n  const uploadChunk = (chunk, index) => {\r\n    const formData = new FormData();\r\n    formData.append('chunk', chunk);\r\n    formData.append('hash', `${fileHash}-${index}`);\r\n    return axios.post('/upload', formData);\r\n  };\r\n  \r\n  // 控制并发\r\n  const maxConcurrent = 3;\r\n  for (let i = 0; i < chunks.length; i += maxConcurrent) {\r\n    await Promise.all(chunks.slice(i, i + maxConcurrent).map(uploadChunk));\r\n  }\r\n  ```\r\n\r\n**2. 断点续传实现**\r\n\r\n- **服务端记录已传分片**\r\n  上传前调用接口检查已上传的分片索引：\r\n\r\n  ```javascript\r\n  const { uploadedIndexes } = await axios.get(`/check?hash=${fileHash}`);\r\n  ```\r\n\r\n- **跳过已传分片**\r\n  前端过滤已上传的分片，仅传剩余部分：\r\n\r\n  ```javascript\r\n  chunks.filter((_, index) => !uploadedIndexes.includes(index));\r\n  ```\r\n\r\n- **合并分片**\r\n  所有分片上传完成后，通知服务端合并：\r\n\r\n  ```javascript\r\n  await axios.post(`/merge`, { hash: fileHash, fileName: file.name });\r\n  ```\r\n\r\n**3. 关键优化点**\r\n\r\n- **进度反馈**\r\n  监听 `axios` 的 `onUploadProgress` 事件更新进度条。\r\n- **错误重试**\r\n  为每个分片添加重试机制（如最多重试3次）。\r\n- **暂停恢复**\r\n  通过 `AbortController` 中断请求，记录已传分片。\r\n\r\n**4. 完整流程示例**\r\n\r\n```javascript\r\n// 1. 计算文件哈希（Web Worker避免阻塞）\r\nconst fileHash = await computeHash(file);\r\n\r\n// 2. 检查已上传分片\r\nconst { uploaded } = await checkExist(fileHash);\r\n\r\n// 3. 过滤未上传分片\r\nconst chunks = splitFile(file);\r\nconst unuploaded = chunks.filter((_, i) => !uploaded.includes(i));\r\n\r\n// 4. 分片上传（控制并发）\r\nuploadChunks(unuploaded, fileHash);\r\n\r\n// 5. 合并请求\r\nawait mergeChunks(fileHash, file.name);\r\n```\r\n\r\n**技术选型建议**：\r\n\r\n- 原生实现用 `Blob.slice` + `Axios`\r\n- 快速开发用 `Uppy.js` 或 `tus-js-client`\r\n- 大文件必配 **Web Worker** 计算哈希，避免主线程卡顿"},{"title":"设计一个撤消/重做（Undo/Redo）功能","answer":"在Vue中实现撤销/重做功能，可以通过维护状态快照栈来实现。以下是具体步骤：\r\n\r\n1. **数据设计**：在组件或Vuex中定义`history`数组和`currentIndex`指针\r\n\r\n```javascript\r\ndata() {\r\n  return {\r\n    history: [deepCopy(initialState)], // 初始状态深拷贝\r\n    currentIndex: 0,\r\n    isUndoRedo: false // 防止撤销/重做触发记录\r\n  }\r\n}\r\n```\r\n\r\n1. **操作记录**：在每次状态变更后保存快照\r\n\r\n```javascript\r\nmethods: {\r\n  saveSnapshot() {\r\n    if (this.isUndoRedo) return\r\n    // 覆盖重做栈\r\n    this.history = this.history.slice(0, this.currentIndex + 1)\r\n    this.history.push(deepCopy(this.$data)) // 保存当前状态\r\n    this.currentIndex++\r\n  }\r\n}\r\n```\r\n\r\n1. **撤销/重做实现**：\r\n\r\n```javascript\r\nundo() {\r\n  if (this.currentIndex > 0) {\r\n    this.isUndoRedo = true\r\n    this.currentIndex--\r\n    this.applySnapshot()\r\n  }\r\n},\r\nredo() {\r\n  if (this.currentIndex < this.history.length - 1) {\r\n    this.isUndoRedo = true\r\n    this.currentIndex++\r\n    this.applySnapshot()\r\n  }\r\n},\r\napplySnapshot() {\r\n  Object.assign(this.$data, this.history[this.currentIndex])\r\n  this.$nextTick(() => this.isUndoRedo = false)\r\n}\r\n```\r\n\r\n1. **触发监听**：通过watch自动记录状态变化\r\n\r\n```javascript\r\nwatch: {\r\n  $data: {\r\n    handler: 'saveSnapshot',\r\n    deep: true,\r\n    immediate: false\r\n  }\r\n}\r\n```\r\n\r\n**注意**：使用`JSON.parse(JSON.stringify())`进行简单深拷贝，复杂场景建议使用lodash的`_.cloneDeep`。按钮状态可通过计算属性判断`currentIndex`边界值。"},{"title":"JS 执行 100 万个任务， 如何保证浏览器不卡顿？","answer":"核心思路：将任务拆分为多个可中断的块\r\n\r\n浏览器的渲染和事件响应依赖主线程，单次长时间占用主线程会导致卡顿。我们需要将任务分解为多个小块，每执行完一小块后让主线程有机会处理其他任务（如渲染、用户交互）。\r\n\r\n方法 1：使用 `requestIdleCallback` 或 `setTimeout` 分片\r\n\r\n```javascript\r\nfunction processTasks(tasks, chunkSize = 1000) {\r\n  let index = 0;\r\n\r\n  function processNextChunk(deadline) {\r\n    while (index < tasks.length && (deadline.timeRemaining() > 0 || deadline.didTimeout)) {\r\n      // 每次处理一小块任务\r\n      for (let i = 0; i < chunkSize && index < tasks.length; i++, index++) {\r\n        executeTask(tasks[index]); // 执行单个任务\r\n      }\r\n    }\r\n\r\n    if (index < tasks.length) {\r\n      // 继续调度下一块任务\r\n      requestIdleCallback(processNextChunk, { timeout: 1000 });\r\n    }\r\n  }\r\n\r\n  requestIdleCallback(processNextChunk, { timeout: 1000 });\r\n}\r\n\r\n// 启动任务处理\r\nprocessTasks(Array(1e6).fill(null));\r\n```\r\n\r\n**优化点：**\r\n\r\n- **动态调整分片大小**：根据 `deadline.timeRemaining()` 动态调整每块任务量。\r\n- **超时控制**：设置 `timeout` 确保即使浏览器不空闲时任务仍能推进。\r\n\r\n\r\n\r\n方法 2：使用 Web Workers 多线程处理（纯计算任务）\r\n\r\n如果任务不涉及 DOM，可将计算逻辑转移到 Web Worker：\r\n\r\n```javascript\r\n// 主线程代码\r\nconst worker = new Worker('task-worker.js');\r\nworker.postMessage({ tasks: Array(1e6).fill(null) });\r\nworker.onmessage = (e) => {\r\n  console.log('任务完成', e.data);\r\n};\r\n\r\n// task-worker.js\r\nself.onmessage = function(e) {\r\n  const results = e.data.tasks.map(executeTask); // 执行任务\r\n  self.postMessage(results);\r\n};\r\n```\r\n\r\n**优点**：彻底避免主线程阻塞。\r\n\r\n\r\n\r\n方法 3：Generator + `setTimeout`/`requestAnimationFrame`\r\n\r\n利用 Generator 函数的暂停特性分步执行：\r\n\r\n```javascript\r\nfunction* taskGenerator(tasks) {\r\n  for (const task of tasks) {\r\n    yield executeTask(task); // 每次 yield 一个任务\r\n  }\r\n}\r\n\r\nfunction runTasks(tasks) {\r\n  const generator = taskGenerator(tasks);\r\n  \r\n  function next() {\r\n    let start = performance.now();\r\n    let res;\r\n    do {\r\n      res = generator.next();\r\n    } while (!res.done && performance.now() - start < 5); // 每帧最多执行 5ms\r\n    \r\n    if (!res.done) {\r\n      requestAnimationFrame(next); // 下一帧继续\r\n    }\r\n  }\r\n\r\n  requestAnimationFrame(next);\r\n}\r\n\r\nrunTasks(Array(1e6).fill(null));\r\n```\r\n\r\n**优点**：与浏览器渲染周期对齐，减少卡顿。\r\n\r\n\r\n\r\n方法 4：使用 `Promise` 微任务调度\r\n\r\n通过微任务队列逐步处理任务：\r\n\r\n```javascript\r\nasync function processTasks(tasks) {\r\n  let index = 0;\r\n  const chunkSize = 1000;\r\n\r\n  async function processChunk() {\r\n    for (let i = 0; i < chunkSize && index < tasks.length; i++, index++) {\r\n      executeTask(tasks[index]);\r\n    }\r\n    if (index < tasks.length) {\r\n      await Promise.resolve(); // 让出主线程\r\n      processChunk();\r\n    }\r\n  }\r\n\r\n  await processChunk();\r\n}\r\n\r\nprocessTasks(Array(1e6).fill(null));\r\n```\r\n\r\n**注意**：微任务会连续执行直到队列清空，需合理控制分片大小。"},{"title":"如何实现瀑布流布局？","answer":"实现瀑布流布局的关键是动态计算每项的位置，使元素依次填充到高度最小的列。步骤如下：\r\n\r\n1. **确定列数**：根据容器宽度和列宽计算\r\n2. **跟踪列高**：用数组记录每列当前高度\r\n3. **定位元素**：遍历元素时，总是插入到高度最小的列\r\n4. **更新布局**：元素插入后更新列高，最后设置容器高度\r\n\r\n简单Vue实现：\r\n\r\n```vue\r\n<<template>\r\n  <!-- 容器绑定ref用于获取DOM -->\r\n  <div class=\"waterfall\" ref=\"container\">\r\n    <!-- 动态生成子元素 -->\r\n    <div v-for=\"(item, index) in items\" :key=\"index\" class=\"item\">\r\n      <!-- 实际内容 -->\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      colHeights: [], // 存储每列高度\r\n    }\r\n  },\r\n  mounted() {\r\n    this.layout()\r\n    window.addEventListener('resize', this.handleResize)\r\n  },\r\n  methods: {\r\n    layout() {\r\n      // 1. 获取容器和子元素\r\n      const container = this.$refs.container\r\n      const items = container.children\r\n      \r\n      // 2. 计算列数和列宽\r\n      const colCount = 3 // 可改为响应式计算\r\n      const gap = 10\r\n      const itemWidth = (container.offsetWidth - gap*(colCount-1))/colCount\r\n      \r\n      // 3. 初始化列高度数组\r\n      this.colHeights = new Array(colCount).fill(0)\r\n\r\n      // 4. 遍历元素定位\r\n      Array.from(items).forEach(item => {\r\n        item.style.position = 'absolute'\r\n        item.style.width = `${itemWidth}px`\r\n        \r\n        // 5. 找到当前最短列\r\n        const minHeight = Math.min(...this.colHeights)\r\n        const colIndex = this.colHeights.indexOf(minHeight)\r\n        \r\n        // 6. 设置元素位置\r\n        item.style.left = `${colIndex * (itemWidth + gap)}px`\r\n        item.style.top = `${minHeight}px`\r\n        \r\n        // 7. 更新列高度\r\n        this.colHeights[colIndex] += item.offsetHeight + gap\r\n      })\r\n\r\n      // 8. 设置容器总高度\r\n      container.style.height = `${Math.max(...this.colHeights)}px`\r\n    },\r\n    handleResize() {\r\n      // 防抖处理更佳\r\n      this.layout()\r\n    }\r\n  },\r\n  beforeDestroy() {\r\n    window.removeEventListener('resize', this.handleResize)\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n.waterfall {\r\n  position: relative;\r\n  margin: 0 auto;\r\n}\r\n.item {\r\n  transition: all 0.3s; /* 可选动画效果 */\r\n}\r\n</style>\r\n```\r\n\r\n注意：实际使用需处理图片异步加载（用imagesLoaded库）、性能优化（防抖）和响应式列数调整。CSS方案（columns或grid）可能有限制，JS方案更灵活。"},{"title":"如何判断一个元素是否在可视区域中？","answer":"[如何判断一个元素是否在可视区域中？](#Intersection)"},{"title":"移动端如何实现上拉加载，下拉刷新？","answer":"```vue\r\n<template>\r\n  <div class=\"container\"\r\n       @touchstart=\"touchStart\"\r\n       @touchmove=\"touchMove\"\r\n       @touchend=\"touchEnd\"\r\n       ref=\"scrollContainer\">\r\n    <!-- 下拉刷新提示 -->\r\n    <div class=\"refresh-tip\" :style=\"{ transform: `translateY(${pullDownY}px)` }\">\r\n      {{ refreshStatus }}\r\n    </div>\r\n\r\n    <!-- 内容区域 -->\r\n    <div class=\"content\">\r\n      <slot></slot>\r\n    </div>\r\n\r\n    <!-- 上拉加载提示 -->\r\n    <div class=\"load-tip\">\r\n      {{ loadStatus }}\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      startY: 0,          // 触摸起始Y坐标\r\n      pullDownY: 0,       // 下拉距离\r\n      isRefreshing: false, // 刷新状态\r\n      isLoading: false    // 加载状态\r\n    }\r\n  },\r\n  methods: {\r\n    touchStart(e) {\r\n      // 1. 记录起始位置\r\n      this.startY = e.touches[0].pageY\r\n    },\r\n    touchMove(e) {\r\n      // 2. 计算下拉距离（仅限顶部下拉）\r\n      if (this.$refs.scrollContainer.scrollTop > 0) return\r\n      \r\n      const currentY = e.touches[0].pageY\r\n      this.pullDownY = currentY - this.startY\r\n      \r\n      // 3. 阻止原生滚动\r\n      if (this.pullDownY > 0) {\r\n        e.preventDefault()\r\n      }\r\n    },\r\n    touchEnd() {\r\n      // 4. 触发刷新判断（下拉距离>60）\r\n      if (this.pullDownY > 60 && !this.isRefreshing) {\r\n        this.isRefreshing = true\r\n        this.$emit('refresh')\r\n      }\r\n      this.pullDownY = 0\r\n    },\r\n\r\n    checkScroll() {\r\n      // 5. 上拉加载判断\r\n      const container = this.$refs.scrollContainer\r\n      const { scrollTop, scrollHeight, clientHeight } = container\r\n      \r\n      // 6. 触底判断（距离底部<50 且未在加载）\r\n      if (scrollHeight - scrollTop - clientHeight < 50 && !this.isLoading) {\r\n        this.isLoading = true\r\n        this.$emit('load')\r\n      }\r\n    }\r\n  },\r\n  mounted() {\r\n    // 7. 监听滚动事件\r\n    this.$refs.scrollContainer.addEventListener('scroll', this.checkScroll)\r\n  },\r\n  beforeDestroy() {\r\n    this.$refs.scrollContainer.removeEventListener('scroll', this.checkScroll)\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n.container {\r\n  height: 100vh;\r\n  overflow: auto;\r\n  -webkit-overflow-scrolling: touch; /* 启用弹性滚动 */\r\n}\r\n\r\n.refresh-tip {\r\n  position: fixed;\r\n  top: -50px;\r\n  width: 100%;\r\n  text-align: center;\r\n  transition: transform 0.3s;\r\n}\r\n</style>\r\n```\r\n\r\n**核心流程：**\r\n\r\n1. **下拉刷新**：通过`touchstart/touchmove/touchend`计算下拉距离\r\n2. **上拉加载**：监听容器滚动事件，计算触底距离\r\n3. **状态管理**：通过标志位防止重复触发\r\n4. **事件通信**：通过`$emit`触发父组件数据更新\r\n\r\n**使用示例：**\r\n\r\n```vue\r\n<ScrollWrapper @refresh=\"fetchData\" @load=\"loadMore\">\r\n  <!-- 内容列表 -->\r\n</ScrollWrapper>\r\n```\r\n\r\n**优化方向：**\r\n\r\n- 添加加载动画/状态提示\r\n- 增加防抖节流\r\n- 支持自定义阈值\r\n- 使用IntersectionObserver优化触底检测"},{"title":"高并发场景下前端如何优化？","answer":"高并发是指在极短单位时间内，有很多用户同时的访问同一 API 接口或者 Url 地址，造成极多个请求同时发起到服务器。它经常会发生在有大活跃用户量，用户高聚集的业务场景中。大部分的高并发处理基本都是在后端处理，但是在部分特殊情况下，后端无法阻止用户行为，需要前端做配合。例如在抢购、秒杀等场景。\r\n\r\n前端可以做些什么？\r\n\r\n1. 合并请求\r\n2. 节流防抖\r\n3. 数据分页+虚拟滚动，避免全量加载\r\n4. 代码压缩\r\n5. 压缩图片\r\n6. 图片懒加载\r\n7. 图片使用Base64编码，雪碧图\r\n8. CDN加速 + 文件名哈希强缓存"},{"title":"做一个 Dialog 组件，说说你设计的思路?它应该有什么功能?","answer":"我设计的Dialog组件核心功能包括：遮罩层、可关闭机制、自定义内容插槽、动画过渡。支持v-model控制显隐，提供标题/内容/底部按钮区插槽，并暴露确认/取消事件。\r\n\r\n**简易实现（Vue3）：**\r\n\r\n```vue\r\n<template>\r\n  <Teleport to=\"body\">\r\n    <Transition name=\"fade\">\r\n      <div v-if=\"modelValue\" class=\"mask\">\r\n        <div class=\"dialog\">\r\n          <div class=\"header\">\r\n            <slot name=\"title\">{{ title }}</slot>\r\n            <span @click=\"$emit('update:modelValue', false)\">×</span>\r\n          </div>\r\n          <div class=\"content\">\r\n            <slot></slot>\r\n          </div>\r\n          <div class=\"footer\">\r\n            <slot name=\"footer\">\r\n              <button @click=\"$emit('cancel')\">取消</button>\r\n              <button @click=\"$emit('confirm')\">确定</button>\r\n            </slot>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </Transition>\r\n  </Teleport>\r\n</template>\r\n\r\n<script setup>\r\ndefineProps({\r\n  modelValue: Boolean,\r\n  title: String\r\n})\r\ndefineEmits(['update:modelValue', 'confirm', 'cancel'])\r\n</script>\r\n\r\n<style scoped>\r\n.mask {\r\n  position: fixed;\r\n  top:0; left:0; \r\n  width:100%; height:100%;\r\n  background: rgba(0,0,0,0.5);\r\n  display: grid;\r\n  place-items: center;\r\n}\r\n\r\n.dialog {\r\n  background: white;\r\n  padding: 20px;\r\n  border-radius: 4px;\r\n  min-width: 300px;\r\n}\r\n\r\n.fade-enter-active,\r\n.fade-leave-active {\r\n  transition: opacity 0.3s;\r\n}\r\n\r\n.fade-enter-from,\r\n.fade-leave-to {\r\n  opacity: 0;\r\n}\r\n</style>\r\n```\r\n\r\n**如果考虑全局服务式调用：**\r\n\r\n```javascript\r\n// 全局服务封装\r\nlet dialogInstance = null\r\n\r\nexport const useDialog = () => {\r\n  const createDialog = (options) => {\r\n    if (!dialogInstance) {\r\n      const container = document.createElement('div')\r\n      dialogInstance = createApp(DialogComponent, options)\r\n      document.body.appendChild(container)\r\n      dialogInstance.mount(container)\r\n    }\r\n    return dialogInstance\r\n  }\r\n\r\n  return {\r\n    open: (options) => createDialog().open(options),\r\n    close: () => dialogInstance?.unmount()\r\n  }\r\n}\r\n\r\n// 组件增强\r\ndefineProps({\r\n  teleportTo: {\r\n    type: [String, HTMLElement],\r\n    default: 'body'\r\n  }\r\n})\r\n```\r\n\r\n**使用方式：**\r\n\r\n```vue\r\n<!-- 组件式 -->\r\n<MyDialog v-model=\"show\" teleport-to=\"#custom-root\" />\r\n\r\n<!-- 服务式 -->\r\n<script setup>\r\nconst { open } = useDialog()\r\n\r\nconst showDialog = () => {\r\n  open({\r\n    title: '提示',\r\n    content: '确定删除？',\r\n    onConfirm: () => {/* ... */}\r\n  })\r\n}\r\n</script>\r\n```"},{"title":"如何实现浏览器内多个标签页之间的通信？","answer":"实现多标签页通信的常用方案：\r\n\r\n1. **LocalStorage + storage事件**（同源）\r\n\r\n   ```javascript\r\n   // A页修改数据\r\n   localStorage.setItem('key', JSON.stringify(data));\r\n   \r\n   // B页监听\r\n   window.addEventListener('storage', (e) => {\r\n     console.log(e.key, e.newValue);\r\n   });\r\n   ```\r\n\r\n2. **BroadcastChannel API**（现代浏览器）\r\n\r\n   ```javascript\r\n   // 各页创建同名字频道\r\n   const channel = new BroadcastChannel('chat');\r\n   channel.postMessage(data);\r\n   channel.onmessage = (e) => { /* 处理消息 */ };\r\n   ```\r\n\r\n3. **SharedWorker**（复杂场景）\r\n\r\n   ```javascript\r\n   // Worker中维护消息中转站\r\n   onconnect = (e) => {\r\n     const port = e.ports[0];\r\n     port.onmessage = (e) => {\r\n       // 广播给所有连接的页面\r\n     };\r\n   };\r\n   ```\r\n\r\n4. **window.postMessage**（跨域场景）\r\n\r\n   ```javascript\r\n   // 通过 opener 引用传递\r\n   window.open('pageB').postMessage(data, origin);\r\n   ```\r\n\r\n**对比建议**：简单数据用LocalStorage，实时通信用BroadcastChannel，持久化复杂数据用SharedWorker，注意同源策略限制。"},{"title":"如何实现图片的懒加载和预加载","answer":"**懒加载实现思路**：\r\n\r\n1. 监听滚动+判断视口位置（或用IntersectionObserver）\r\n2. 替换data-src为真实src\r\n\r\n**预加载实现思路**：\r\n\r\n1. 提前创建Image对象加载图片\r\n2. 缓存到浏览器\r\n\r\n**Vue实现示例**：\r\n\r\n```vue\r\n<script setup>\r\n// 图片懒加载指令\r\nconst vLazyload = {\r\n  mounted(el) {\r\n    const observer = new IntersectionObserver((entries) => {\r\n      entries.forEach(entry => {\r\n        if (entry.isIntersecting) {\r\n          // 进入视口时加载图片\r\n          el.src = el.dataset.src\r\n          observer.unobserve(el) // 停止监听\r\n        }\r\n      })\r\n    })\r\n    observer.observe(el)\r\n  }\r\n}\r\n\r\n// 图片预加载方法\r\nconst preloadImages = (urls) => {\r\n  urls.forEach(url => {\r\n    const img = new Image()\r\n    img.src = url // 触发浏览器缓存\r\n  })\r\n}\r\n</script>\r\n\r\n<template>\r\n  <!-- 懒加载使用 -->\r\n  <img v-lazyload data-src=\"real-image.jpg\" alt=\"\">\r\n  \r\n  <!-- 预加载触发 -->\r\n  <button @click=\"preloadImages(['next-page-img.jpg'])\">预加载图片</button>\r\n</template>\r\n```\r\n\r\n**关键点**：懒加载用观察者优化性能，预加载利用浏览器缓存机制。实际生产需加加载状态和错误处理。"},{"title":"一个列表，假设有 100000 个数据，这个该怎么办？","answer":"**核心解决方案**：虚拟滚动 + 数据分片\r\n（避免同时渲染全部DOM）\r\n\r\n**实现步骤**：\r\n\r\n1. **计算可视区域高度**\r\n2. **动态渲染可视区数据**（startIndex-endIndex）\r\n3. **监听滚动动态更新**\r\n\r\n**Vue3示例**：\r\n\r\n```vue\r\n<script setup>\r\nimport { ref, computed } from 'vue';\r\n\r\nconst itemHeight = 40; // 每项高度\r\nconst total = 100000;\r\nconst visibleCount = Math.ceil(window.innerHeight / itemHeight); // 可视区条数\r\nconst startIndex = ref(0);\r\n\r\n// 生成模拟数据\r\nconst list = Array.from({length: total}, (_,i) => `Item ${i+1}`);\r\n\r\n// 可视区数据切片\r\nconst visibleData = computed(() => \r\n  list.slice(startIndex.value, startIndex.value + visibleCount)\r\n);\r\n\r\nconst handleScroll = (e) => {\r\n  startIndex.value = Math.floor(e.target.scrollTop / itemHeight);\r\n};\r\n</script>\r\n\r\n<template>\r\n  <div \r\n    class=\"virtual-list\" \r\n    @scroll=\"handleScroll\"\r\n    :style=\"{ height: `${visibleCount * itemHeight}px` }\"\r\n  >\r\n    <div class=\"scroll-holder\" \r\n         :style=\"{ height: `${total * itemHeight}px` }\">\r\n      <div \r\n        class=\"item\" \r\n        v-for=\"(item, index) in visibleData\"\r\n        :key=\"index\"\r\n        :style=\"{ transform: `translateY(${startIndex * itemHeight}px)` }\"\r\n      >\r\n        {{ item }}\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style>\r\n.virtual-list {\r\n  overflow-y: auto;\r\n}\r\n.scroll-holder {\r\n  position: relative;\r\n}\r\n.item {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 40px;\r\n  line-height: 40px;\r\n}\r\n</style>\r\n```\r\n\r\n**优化点**：\r\n\r\n1. 只维护`visibleCount+2`个DOM节点\r\n2. 滚动时通过transform位移代替重新渲染\r\n3. 实际项目建议用`vue-virtual-scroller`等成熟库"},{"title":"如何实现一键Copy功能","answer":"**核心步骤**：\r\n\r\n1. 创建隐藏的`textarea`临时元素\r\n2. 使用`Clipboard API`或`execCommand`写入剪贴板\r\n3. 移除临时元素并反馈结果\r\n\r\n**Vue3实现**：\r\n\r\n```vue\r\n<script setup>\r\nconst copyText = async (text) => {\r\n  try {\r\n    // 现代API方案\r\n    await navigator.clipboard.writeText(text)\r\n    alert('复制成功')\r\n  } catch {\r\n    // 兼容方案\r\n    const textarea = document.createElement('textarea')\r\n    textarea.value = text\r\n    document.body.appendChild(textarea)\r\n    textarea.select()\r\n    document.execCommand('copy')\r\n    document.body.removeChild(textarea)\r\n    alert('复制成功')\r\n  }\r\n}\r\n</script>\r\n\r\n<template>\r\n  <button @click=\"copyText('要复制的内容')\">一键复制</button>\r\n</template>\r\n```\r\n\r\n**优化点**：\r\n\r\n- 优先使用`Clipboard API`（更安全）\r\n- 旧浏览器自动降级兼容\r\n- 生产环境建议封装成指令+Toast提示"},{"title":"前端如何实现即时通讯？","answer":"**核心方案**：WebSocket 长连接 + 消息队列\r\n（替代方案：短轮询/SSE，但实时性较差）\r\n\r\n**实现流程**：\r\n\r\n1. 建立 WebSocket 连接\r\n2. 双向通信：监听消息/发送消息\r\n3. 心跳检测保持连接\r\n4. 异常重连机制\r\n\r\n**Vue3 简易实现**：\r\n\r\n```vue\r\n<script setup>\r\nimport { ref, onMounted, onBeforeUnmount } from 'vue'\r\n\r\nconst ws = ref(null)\r\nconst messages = ref([])\r\n\r\n// 1. 初始化连接\r\nconst initWebSocket = () => {\r\n  ws.value = new WebSocket('wss://your-websocket-endpoint')\r\n\r\n  // 2. 监听消息\r\n  ws.value.onmessage = (e) => {\r\n    messages.value.push(JSON.parse(e.data))\r\n  }\r\n\r\n  // 3. 心跳检测\r\n  let heartTimer = setInterval(() => {\r\n    ws.value.send('ping')\r\n  }, 30000)\r\n\r\n  // 4. 异常处理\r\n  ws.value.onclose = () => {\r\n    clearInterval(heartTimer)\r\n    setTimeout(initWebSocket, 2000) // 断线重连\r\n  }\r\n}\r\n\r\n// 发送消息\r\nconst sendMessage = (text) => {\r\n  ws.value.send(JSON.stringify({\r\n    type: 'text',\r\n    content: text,\r\n    timestamp: Date.now()\r\n  }))\r\n}\r\n\r\nonMounted(initWebSocket)\r\nonBeforeUnmount(() => {\r\n  ws.value?.close() // 清理连接\r\n})\r\n</script>\r\n\r\n<template>\r\n  <div class=\"chat-box\">\r\n    <div v-for=\"msg in messages\" :key=\"msg.timestamp\">\r\n      {{ msg.content }}\r\n    </div>\r\n    <input @keyup.enter=\"sendMessage\" />\r\n  </div>\r\n</template>\r\n```\r\n\r\n**关键优化**：\r\n\r\n- 消息数据格式化（JSON编解码）\r\n- 心跳防止连接断开（Nginx默认60s超时）\r\n- 生产环境需增加消息状态反馈/消息重发机制"},{"title":"前端如何实现截图？","answer":"**核心方案**：使用 `html2canvas` 库实现 DOM 转 Canvas\r\n**流程**：\r\n\r\n1. 捕获目标 DOM 元素\r\n2. 生成 Canvas 并转图片\r\n3. 触发下载或预览\r\n\r\n**Vue3 实现**（需先安装 `html2canvas`）：\r\n\r\n```vue\r\n<script setup>\r\nimport { ref } from 'vue';\r\nimport html2canvas from 'html2canvas';\r\n\r\nconst targetRef = ref(null); // 1. 获取截图目标元素\r\n\r\nconst capture = async () => {\r\n  // 2. 生成 Canvas\r\n  const canvas = await html2canvas(targetRef.value, {\r\n    useCORS: true // 处理跨域图片\r\n  });\r\n  \r\n  // 3. 转图片并下载\r\n  const link = document.createElement('a');\r\n  link.download = 'screenshot.png';\r\n  link.href = canvas.toDataURL();\r\n  link.click();\r\n};\r\n</script>\r\n\r\n<template>\r\n  <!-- 截图区域 -->\r\n  <div ref=\"targetRef\" class=\"screenshot-area\">\r\n    <h1>截我！</h1>\r\n    <p>动态内容{{ new Date().toLocaleString() }}</p>\r\n  </div>\r\n\r\n  <!-- 触发按钮 -->\r\n  <button @click=\"capture\">截图保存</button>\r\n</template>\r\n```\r\n\r\n**关键点**：\r\n\r\n- 处理跨域资源需配置 `useCORS: true`\r\n- 复杂样式需注意 `foreignObjectRendering` 配置\r\n- 实际项目建议结合裁剪工具（如 `cropperjs`）"},{"title":"如何实现图片裁剪上传？","answer":"**原生 Canvas 实现思路**：\r\n\r\n1. 文件读取 → 绘制到 Canvas\r\n2. 通过鼠标事件实现选区交互\r\n3. 裁剪选区 → 生成新图片\r\n\r\n\r\n\r\n**Vue3 实现**（无第三方库）：\r\n\r\n```vue\r\n<script setup>\r\nimport { ref } from 'vue'\r\n\r\nconst canvasRef = ref(null)\r\nconst startX = ref(0)\r\nconst startY = ref(0)\r\nconst isDrawing = ref(false)\r\nlet img = null\r\nlet scale = 1\r\n\r\n// 1. 文件读取\r\nconst handleUpload = (e) => {\r\n  const file = e.target.files[0]\r\n  const reader = new FileReader()\r\n  \r\n  reader.onload = (e) => {\r\n    img = new Image()\r\n    img.onload = drawImageToCanvas\r\n    img.src = e.target.result\r\n  }\r\n  reader.readAsDataURL(file)\r\n}\r\n\r\n// 绘制到Canvas\r\nconst drawImageToCanvas = () => {\r\n  const canvas = canvasRef.value\r\n  const ctx = canvas.getContext('2d')\r\n  \r\n  // 计算缩放比例（限制最大宽度800px）\r\n  scale = Math.min(800 / img.width, 1)\r\n  canvas.width = img.width * scale\r\n  canvas.height = img.height * scale\r\n  \r\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\r\n}\r\n\r\n// 2. 选区交互逻辑\r\nconst startDraw = (e) => {\r\n  isDrawing.value = true\r\n  const rect = canvasRef.value.getBoundingClientRect()\r\n  startX.value = e.clientX - rect.left\r\n  startY.value = e.clientY - rect.top\r\n}\r\n\r\nconst drawing = (e) => {\r\n  if (!isDrawing.value) return\r\n  const rect = canvasRef.value.getBoundingClientRect()\r\n  const currentX = e.clientX - rect.left\r\n  const currentY = e.clientY - rect.top\r\n  \r\n  // 实时绘制选区框\r\n  const ctx = canvasRef.value.getContext('2d')\r\n  ctx.clearRect(0, 0, canvasRef.value.width, canvasRef.value.height)\r\n  ctx.drawImage(img, 0, 0, canvasRef.value.width, canvasRef.value.height)\r\n  ctx.strokeStyle = '#f00'\r\n  ctx.strokeRect(\r\n    startX.value, \r\n    startY.value, \r\n    currentX - startX.value, \r\n    currentY - startY.value\r\n  )\r\n}\r\n\r\n// 3. 裁剪并上传\r\nconst cropImage = () => {\r\n  const canvas = document.createElement('canvas')\r\n  const rect = canvasRef.value.getBoundingClientRect()\r\n  \r\n  // 计算实际裁剪尺寸（考虑缩放比例）\r\n  const cropWidth = (endX - startX.value) / scale\r\n  const cropHeight = (endY - startY.value) / scale\r\n  \r\n  canvas.width = cropWidth\r\n  canvas.height = cropHeight\r\n  canvas.getContext('2d').drawImage(\r\n    img,\r\n    startX.value / scale,  // 原始图片X位置\r\n    startY.value / scale,  // 原始图片Y位置\r\n    cropWidth,            // 原始图片裁剪宽度\r\n    cropHeight,           // 原始图片裁剪高度\r\n    0, 0,                // 新canvas起始位置\r\n    cropWidth, cropHeight // 新canvas尺寸\r\n  )\r\n  \r\n  // 转换为Blob上传\r\n  canvas.toBlob(blob => {\r\n    const formData = new FormData()\r\n    formData.append('file', blob)\r\n    // 执行上传逻辑...\r\n  })\r\n}\r\n</script>\r\n\r\n<template>\r\n  <input type=\"file\" @change=\"handleUpload\" accept=\"image/*\">\r\n  <canvas \r\n    ref=\"canvasRef\"\r\n    @mousedown=\"startDraw\"\r\n    @mousemove=\"drawing\"\r\n    @mouseup=\"cropImage\"\r\n    @mouseleave=\"isDrawing = false\"\r\n  ></canvas>\r\n</template>\r\n```"},{"title":"如何解决页面请求接口大规模并发问题？","answer":"**核心方案**：请求队列 + 并发控制 + 服务端优化\r\n**关键实现**：\r\n\r\n1. **Promise 并发池控制**（示例）：\r\n\r\n```javascript\r\nasync function parallelRequests(urls, maxConcurrent = 5) {\r\n  const results = new Array(urls.length); // 固定长度数组保留顺序\r\n  const pool = []; // 当前执行池\r\n  \r\n  for (let i = 0; i < urls.length; i++) {\r\n    const url = urls[i];\r\n    const originalIndex = i; // 保存原始索引\r\n    \r\n    // 创建请求Promise（带错误处理）\r\n    const request = fetch(url)\r\n      .then(res => {\r\n        results[originalIndex] = res; // 按原始顺序存储\r\n        return res;\r\n      })\r\n      .catch(err => {\r\n        results[originalIndex] = err; // 错误也保留位置\r\n        return null;\r\n      });\r\n\r\n    // 第三步关键解释：创建清理函数\r\n    // 无论成功/失败都要从池中移除已完成请求\r\n    const cleanup = () => {\r\n      const index = pool.indexOf(cleanupPromise);\r\n      if (index > -1) pool.splice(index, 1);\r\n    };\r\n    \r\n    // 创建带清理的Promise\r\n    const cleanupPromise = request.finally(cleanup);\r\n    pool.push(cleanupPromise);\r\n\r\n    // 当池满时等待任意一个完成\r\n    if (pool.length >= maxConcurrent) {\r\n      await Promise.race(pool);\r\n    }\r\n  }\r\n\r\n  // 等待所有剩余请求完成\r\n  await Promise.all(pool);\r\n  return results; // 结果顺序与urls数组完全一致\r\n}\r\n```\r\n\r\n2. **请求优先级策略**：关键接口优先处理\r\n3. **缓存复用**：相同请求去重（Map缓存）\r\n4. **服务端配合**：批量接口设计（如 `/api/batch?ids=1,2,3`）"},{"title":"使用同一个链接， 如何实现 PC 打开是 web 应用、手机打开是一个 H5 应用？","answer":"**核心方案**：设备检测 + 动态渲染\r\n**实现步骤**：\r\n\r\n1. 通过 `navigator.userAgent` 检测设备类型\r\n2. 同一路由下根据设备渲染不同组件\r\n\r\n**Vue3 示例代码**：\r\n\r\n```vue\r\n<script setup>\r\nimport { ref, onMounted } from 'vue'\r\nimport PcView from './PcView.vue'\r\nimport MobileView from './MobileView.vue'\r\n\r\nconst isMobile = ref(false)\r\n\r\n// 设备检测函数\r\nconst checkDevice = () => {\r\n  const ua = navigator.userAgent.toLowerCase()\r\n  isMobile.value = /iphone|android|mobile/.test(ua)\r\n}\r\n\r\nonMounted(checkDevice)\r\n</script>\r\n\r\n<template>\r\n  <!-- 动态切换组件 -->\r\n  <component :is=\"isMobile ? MobileView : PcView\" />\r\n  \r\n  <!-- 可选：提供手动切换按钮 -->\r\n  <button @click=\"isMobile = !isMobile\">\r\n    {{ isMobile ? '切换PC版' : '切换移动版' }}\r\n  </button>\r\n</template>\r\n```\r\n\r\n\r\n\r\n**优化方案**：\r\n\r\n1. **服务端识别**（SSR）：\r\n\r\n   ```javascript\r\n   // Node.js 中间件示例\r\n   app.get('/', (req, res) => {\r\n     const isMobile = /mobile/i.test(req.headers['user-agent'])\r\n     res.render(isMobile ? 'mobile' : 'pc')\r\n   })\r\n   ```\r\n\r\n2. **响应式媒体查询兜底**：\r\n\r\n   ```css\r\n   /* 共用基础样式 + 设备差异样式 */\r\n   .main-content {\r\n     padding: 20px;\r\n     @media (max-width: 768px) {\r\n       padding: 10px;\r\n     }\r\n   }\r\n   ```"},{"title":"Vue3用 ref 和 watch 实现一个防抖搜索 Hook","answer":"**Vue3 防抖搜索 Hook 实现**：\r\n\r\n```typescript\r\nimport { ref, watch, type WatchStopHandle } from 'vue';\r\n\r\nexport function useDebounceSearch(callback: (val: string) => void, delay = 300) {\r\n  const keyword = ref('');\r\n\r\n  // 防抖逻辑封装\r\n  let timer: number;\r\n  const stopWatch = watch(keyword, (newVal) => {\r\n    clearTimeout(timer);\r\n    timer = window.setTimeout(() => {\r\n      callback(newVal);\r\n    }, delay);\r\n  });\r\n\r\n  // 自动清理\r\n  const stop = () => {\r\n    clearTimeout(timer);\r\n    stopWatch();\r\n  };\r\n\r\n  return { keyword, stop };\r\n}\r\n```\r\n\r\n\r\n\r\n**使用示例**：\r\n\r\n```vue\r\n<script setup>\r\nimport { useDebounceSearch } from './hooks';\r\n\r\nconst { keyword } = useDebounceSearch((val) => {\r\n  console.log('搜索:', val);\r\n  // 调用API...\r\n}, 500);\r\n</script>\r\n\r\n<template>\r\n  <input v-model=\"keyword\" placeholder=\"输入搜索内容\" />\r\n</template>\r\n```"},{"title":"如何实现请求进度监控？","answer":"**请求进度监控实现方案**：\r\n\r\n1. **XMLHttpRequest 原生方案**\r\n\r\n```javascript\r\nconst xhr = new XMLHttpRequest();\r\nxhr.upload.onprogress = (e) => { // 上传进度\r\n  const percent = (e.loaded / e.total * 100).toFixed(2)\r\n};\r\nxhr.onprogress = (e) => { // 下载进度\r\n  console.log(`下载进度：${percent}%`)\r\n};\r\n```\r\n\r\n1. **Axios 封装方案**\r\n\r\n```javascript\r\naxios.post('/upload', file, {\r\n  onUploadProgress: progressEvent => {\r\n    const percent = Math.round(\r\n      (progressEvent.loaded * 100) / progressEvent.total\r\n    )\r\n  },\r\n  onDownloadProgress: progressEvent => {\r\n    // 处理下载进度\r\n  }\r\n})\r\n```\r\n\r\n1. **Fetch API 分块读取方案**\r\n\r\n```javascript\r\nconst response = await fetch(url);\r\nconst reader = response.body.getReader();\r\nlet received = 0;\r\n\r\nwhile(true) {\r\n  const { done, value } = await reader.read();\r\n  if(done) break;\r\n  received += value.length;\r\n  const total = +response.headers.get('Content-Length');\r\n  console.log(`下载进度：${(received/total*100).toFixed(1)}%`);\r\n}\r\n```"},{"title":"如何实现网页加载进度条？","answer":"**核心方案**：路由守卫 + 虚拟进度模拟\r\n**实现步骤**（Vue3 + NProgress 示例）：\r\n\r\n1. 安装进度条库：\r\n\r\n```bash\r\nnpm install nprogress\r\n```\r\n\r\n2. 封装进度条逻辑：\r\n\r\n```javascript\r\n// utils/progress.js\r\nimport NProgress from 'nprogress'\r\nimport 'nprogress/nprogress.css'\r\n\r\nNProgress.configure({ showSpinner: false })\r\n\r\nexport const start = () => NProgress.start()\r\nexport const done = () => NProgress.done()\r\n```\r\n\r\n3. 结合路由守卫：\r\n\r\n```javascript\r\n// router.js\r\nimport { start, done } from './utils/progress'\r\n\r\nrouter.beforeEach(() => {\r\n  start() // 路由切换时启动\r\n})\r\n\r\nrouter.afterEach(() => {\r\n  setTimeout(done, 300) // 微延迟保证过渡效果\r\n})\r\n```\r\n\r\n**优化点**：\r\n\r\n- 请求拦截器集成真实加载进度\r\n- 智能最小加载时间（至少保持200ms避免闪烁）\r\n- 错误处理自动关闭进度条\r\n- 自定义样式匹配品牌视觉\r\n\r\n**原生JS实现要点**：\r\n\r\n```javascript\r\n// 创建进度条DOM\r\nconst progressBar = document.createElement('div')\r\nprogressBar.style.cssText = `\r\n  position: fixed; \r\n  top:0; left:0; \r\n  height:3px; \r\n  background: #00a3ff;\r\n  transition: width 0.3s ease;\r\n`\r\n\r\n// 更新进度函数\r\nlet progress = 0\r\nconst update = (value) => {\r\n  progress = Math.min(Math.max(value, 0), 1)\r\n  progressBar.style.width = `${progress * 100}%`\r\n}\r\n\r\n// 挂载到页面\r\ndocument.body.prepend(progressBar)\r\n\r\n// 使用示例\r\nupdate(0.3) // 更新到30%\r\n```"},{"title":"如果用户说 web 应用感觉很反应慢或者卡顿，该如何排查？","answer":"**一、确认现象和范围**\r\n\r\n1. **具体场景**：询问用户卡顿发生的具体操作（如点击按钮、加载页面、提交表单等）。\r\n2. **复现条件**：\r\n   - 是否所有用户都会遇到？还是特定用户/设备？\r\n   - 是否在特定时间段（如高峰时段）出现？\r\n   - 是否仅限特定功能或页面？\r\n\r\n**二、前端性能排查**\r\n\r\n1. **浏览器开发者工具**（Chrome DevTools）：\r\n   - **Network 面板**：检查资源加载时间、体积、是否阻塞（如大图、未压缩JS/CSS）。\r\n     - 关注`Waterfall`瀑布流中的耗时请求。\r\n     - 检查HTTP状态码（如304重定向、5xx错误）。\r\n   - **Performance 面板**：录制操作过程，分析长任务（Long Tasks）、渲染卡顿（FPS下降）、内存泄漏。\r\n   - **Lighthouse/Audits**：生成性能报告，获取优化建议（如代码分割、图片懒加载）。\r\n   - **Console 面板**：检查JavaScript报错或警告。\r\n2. **代码问题**：\r\n   - 检查频繁的DOM操作或重绘（如大量`appendChild`、未节流的`resize`事件）。\r\n   - 分析第三方库（如大型图表库、未按需加载的组件）是否影响性能。\r\n   - 使用`Webpack Bundle Analyzer`检查打包体积，优化冗余依赖。\r\n\r\n**三、网络问题排查**\r\n\r\n1. **网络延迟**：\r\n   - 使用`ping`、`traceroute`测试用户到服务器的延迟和路由。\r\n   - 通过CDN服务商控制台检查缓存命中率、回源延迟。\r\n2. **接口性能**：\r\n   - 用`curl`或Postman测试API响应时间，对比Header中的`Server-Timing`。\r\n   - 检查是否接口返回数据过大（如未分页的列表查询）。\r\n3. **WebSocket/长连接**：检查连接稳定性或消息堆积。\r\n\r\n**四、服务端排查**\r\n\r\n1. **服务器资源**：\r\n   - 使用`top`、`htop`监控CPU/内存使用率。\r\n   - 使用`iostat`、`iotop`检查磁盘I/O瓶颈。\r\n   - `dstat`综合监控系统资源。\r\n2. **应用性能**：\r\n   - 使用Profiling工具（如Java的Arthas、Python的cProfile）分析代码热点。\r\n   - 检查线程池配置、数据库连接池是否耗尽。\r\n3. **数据库**：\r\n   - 分析慢查询日志（如MySQL的`slow_query_log`）。\r\n   - 使用`EXPLAIN`优化SQL执行计划，检查索引缺失。\r\n   - 监控数据库锁竞争（`SHOW ENGINE INNODB STATUS`）。\r\n4. **缓存**：\r\n   - 检查Redis/Memcached的命中率、响应时间。\r\n   - 确认缓存击穿/雪崩问题（如大量请求直接穿透到DB）。\r\n\r\n**五、基础设施与配置**\r\n\r\n1. **Web服务器配置**：\r\n   - Nginx/Apache的`worker_connections`、`keepalive_timeout`是否合理。\r\n   - 检查SSL握手时间（如证书链是否完整）。\r\n2. **负载均衡**：检查后端服务器健康状态、会话保持配置。\r\n3. **日志分析**：\r\n   - 检查应用日志中的错误堆栈（如超时、OOM）。\r\n   - 分析访问日志中的慢请求（如通过`awk`统计耗时最高的URL）。\r\n\r\n**六、其他可能原因**\r\n\r\n1. **第三方服务依赖**：如支付网关、地图API响应慢。\r\n2. **安全扫描/爬虫**：大量恶意请求占用资源。\r\n3. **版本回滚**：确认问题是否由近期代码更新引起。\r\n\r\n**七、优化建议**\r\n\r\n- **前端**：压缩资源、启用HTTP/2、代码分割、虚拟滚动。\r\n- **后端**：异步处理耗时任务（如队列）、数据库读写分离。\r\n- **监控**：部署APM工具（如New Relic、SkyWalking）实时追踪性能。"},{"title":"请你实现一个大文件上传和断点续传","answer":"**大文件上传 & 断点续传流程简述：**\r\n\r\n1. **分片切割**：前端将大文件按固定大小（如2MB）切片。\r\n2. **唯一标识**：根据文件内容生成hash（如使用SparkMD5），作为文件唯一标识。\r\n3. **验证分片**：上传前调用接口，检查哪些分片已上传。\r\n4. **并发上传**：并行上传未传分片，每个分片携带hash、索引、总片数。\r\n5. **合并请求**：全部分片上传后，通知服务端合并。\r\n6. **断点续传**：上传中断后，重新上传时跳过已传分片。\r\n\r\n\r\n\r\n**Vue 简易实现（核心代码）：**\r\n\r\n```vue\r\n<template>\r\n  <input type=\"file\" @change=\"handleFileChange\" />\r\n  <button @click=\"upload\">上传</button>\r\n  \r\n  <!-- 进度条 -->\r\n  <div class=\"progress\">\r\n    <div :style=\"{ width: progress + '%' }\">{{ progress.toFixed(1) }}%</div>\r\n  </div>\r\n  \r\n  <!-- 错误提示 -->\r\n  <div v-if=\"errorMsg\" class=\"error\">{{ errorMsg }}</div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      // ...原有数据...\r\n      progress: 0,        // 总进度\r\n      chunkProgress: {},  // 记录每个分片进度 { 0: 80, 1: 100... }\r\n      retryCount: 3,      // 最大重试次数\r\n      errorMsg: ''        // 错误信息\r\n    };\r\n  },\r\n  computed: {\r\n    // 计算总进度（根据所有分片进度）\r\n    totalProgress() {\r\n      const chunks = Object.values(this.chunkProgress);\r\n      return chunks.reduce((sum, v) => sum + v, 0) / chunks.length || 0;\r\n    }\r\n  },\r\n  methods: {\r\n    async upload() {\r\n      try {\r\n        // ...检查已上传分片逻辑...\r\n        \r\n        // 并行上传（带进度和重试）\r\n        const requests = [];\r\n        for (let i = 0; i < chunks; i++) {\r\n          if (uploaded.includes(i)) {\r\n            this.chunkProgress[i] = 100; // 已传分片直接100%\r\n            continue;\r\n          }\r\n          requests.push(this.uploadChunkWithRetry(i));\r\n        }\r\n        \r\n        await Promise.all(requests);\r\n        // ...合并请求...\r\n        \r\n      } catch (err) {\r\n        this.errorMsg = `上传失败: ${err.message}`;\r\n      }\r\n    },\r\n\r\n    // 带重试的分片上传\r\n    async uploadChunkWithRetry(index, retry = 0) {\r\n      try {\r\n        const formData = new FormData();\r\n        formData.append('chunk', await this.getChunk(index));\r\n        // ...其他字段...\r\n        \r\n        await axios.post('/upload', formData, {\r\n          // 进度监听\r\n          onUploadProgress: e => {\r\n            this.chunkProgress[index] = Math.floor((e.loaded / e.total) * 100);\r\n          }\r\n        });\r\n        \r\n      } catch (err) {\r\n        if (retry < this.retryCount) {\r\n          return this.uploadChunkWithRetry(index, retry + 1); // 重试\r\n        }\r\n        throw new Error(`分片${index}上传失败`);\r\n      }\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style>\r\n.progress { /* 简单进度条样式 */ }\r\n.error { color: red; }\r\n</style>\r\n```"},{"title":"扫码登录实现方式","answer":"**扫码登录流程简述：**\r\n\r\n1. **生成临时令牌**：服务端生成唯一临时`token`并设置有效期（如5分钟）\r\n2. **生成二维码**：前端将`token`编码为二维码（格式：`https://xxx.com/login?token=xxx`）\r\n3. **轮询检查状态**：前端定时轮询接口，检查该`token`是否被扫码确认\r\n4. **移动端操作**：用户扫码后，移动端请求服务端绑定`token`与用户身份\r\n5. **登录完成**：网页端检测到`token`状态变化后，完成登录并跳转\r\n\r\n\r\n\r\n**Vue 简易实现（核心代码）：**\r\n\r\n```vue\r\n<template>\r\n  <div ref=\"qrcode\"></div>\r\n  <div>{{ statusText }}</div>\r\n</template>\r\n\r\n<script>\r\nimport QRCode from 'qrcodejs2';\r\nimport axios from 'axios';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      token: '',\r\n      timer: null,\r\n      statusText: '请扫码登录'\r\n    };\r\n  },\r\n  mounted() {\r\n    this.initQrcode();\r\n  },\r\n  beforeUnmount() {\r\n    clearInterval(this.timer); // 清除轮询\r\n  },\r\n  methods: {\r\n    // 1. 初始化生成二维码\r\n    async initQrcode() {\r\n      // 获取临时token\r\n      const { token } = await axios.get('/api/login/qrcode');\r\n      this.token = token;\r\n      \r\n      // 生成二维码\r\n      new QRCode(this.$refs.qrcode, {\r\n        text: `https://app.com/confirm?token=${token}`,\r\n        width: 200,\r\n        height: 200\r\n      });\r\n      \r\n      // 2. 开始轮询检查状态\r\n      this.startPolling();\r\n    },\r\n\r\n    // 3. 轮询检查登录状态\r\n    startPolling() {\r\n      this.timer = setInterval(async () => {\r\n        try {\r\n          const { status, user } = await axios.get(`/api/login/check?token=${this.token}`);\r\n          \r\n          if (status === 'confirmed') {\r\n            clearInterval(this.timer);\r\n            this.statusText = `登录成功：${user.name}`;\r\n            // 存储登录凭证 & 跳转\r\n            localStorage.setItem('token', user.token);\r\n            this.$router.push('/');\r\n          } else if (status === 'expired') {\r\n            clearInterval(this.timer);\r\n            this.statusText = '二维码已过期，请刷新';\r\n          }\r\n        } catch (err) {\r\n          console.error('轮询异常', err);\r\n        }\r\n      }, 2000); // 每2秒轮询一次\r\n    }\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\n**关键注释：**\r\n\r\n- **临时Token**：服务端需维护`token`与用户身份的映射关系及状态（未扫描/已确认/已过期）\r\n- **二维码内容**：通常为包含`token`的URL，移动端扫码后解析出`token`并请求绑定接口\r\n- **轮询优化**：实际项目建议用WebSocket替代定时轮询\r\n- **安全措施**：\r\n  - Token需设置有效期（防止盗用）\r\n  - 限制同一IP的频繁请求\r\n  - 移动端扫码后需二次确认（防误扫）\r\n\r\n**移动端处理示例流程：**\r\n\r\n1. 扫码获取`token`\r\n2. 调用接口`POST /api/login/confirm`发送用户凭证+`token`\r\n3. 服务端验证后绑定`token`与用户身份"},{"title":"单点登录是什么?具体流程是什么?","answer":"**单点登录（SSO）** 是一种身份验证机制，允许用户通过一次登录访问多个相互信任的系统，无需重复输入凭证。\r\n\r\n\r\n\r\n**核心流程（以典型Token方案为例）：**\r\n\r\n1. **首次登录**：\r\n   - 用户访问系统A，未登录时重定向至**统一认证中心**。\r\n   - 用户输入账号密码完成认证，认证中心生成全局Token（如JWT）并存储关联会话。\r\n2. **系统A登录**：\r\n   - 认证中心将用户重定向回系统A并携带Token。\r\n   - 系统A验证Token有效性后创建本地会话（如设置Cookie），允许访问。\r\n3. **访问其他系统**：\r\n   - 用户访问系统B时，系统B检测未登录，重定向至认证中心。\r\n   - 认证中心发现用户已登录，直接返回Token给系统B。\r\n   - 系统B验证Token后建立本地会话，用户无感登录。\r\n\r\n\r\n\r\n**关键点**：\r\n\r\n- **Token共享**：认证中心通过加密签名确保Token不可伪造。\r\n- **会话同步**：各系统信任认证中心的Token，但维护独立的本地会话。\r\n- **单点登出**：任一系统登出时，通知认证中心销毁全局会话，触发所有系统本地会话失效。\r\n\r\n\r\n\r\n**常见实现协议**：\r\n\r\n- **OAuth 2.0**（如Google登录）\r\n- **SAML**（企业级应用）\r\n- **CAS**（开源单点登录框架）\r\n\r\nhttps://v.douyin.com/Wz1D4jUoOfs/"},{"title":"如何做无感token刷新？","answer":"**无感 Token 刷新实现核心步骤：**\r\n\r\n1. **双 Token 机制**：\r\n   - Access Token（短期有效，如2小时）\r\n   - Refresh Token（长期有效，存储于安全位置如 HttpOnly Cookie）\r\n2. **请求拦截**：\r\n   - 发起请求时携带 Access Token\r\n   - 若接口返回 `401`（Token过期），触发刷新流程\r\n3. **刷新控制**：\r\n   - **防并发刷新**：首个过期请求发起刷新，后续请求挂起队列\r\n   - **刷新请求**：用 Refresh Token 请求新 Access Token\r\n   - **更新存储**：新 Token 更新到内存及本地存储\r\n4. **失败处理**：\r\n   - 刷新失败则清除 Token，跳转登录页\r\n\r\n\r\n\r\n**代码关键逻辑（Axios 拦截器示例）**：\r\n\r\n```javascript\r\nlet isRefreshing = false; // 刷新锁\r\nlet requestsQueue = []; // 等待队列\r\n\r\n// 响应拦截器\r\naxios.interceptors.response.use(\r\n  response => response,\r\n  async error => {\r\n    if (error.status !== 401) return Promise.reject(error);\r\n    \r\n    // 非重复的刷新请求\r\n    if (!isRefreshing) {\r\n      isRefreshing = true;\r\n      try {\r\n        const { newToken } = await refreshToken();\r\n        localStorage.setItem('token', newToken);\r\n        // 重放队列中所有请求\r\n        requestsQueue.forEach(cb => cb(newToken));\r\n        return axios(error.config); // 重试原请求\r\n      } catch (e) {\r\n        logout(); // 清除Token并跳转登录\r\n      } finally {\r\n        isRefreshing = false;\r\n        requestsQueue = [];\r\n      }\r\n    }\r\n    \r\n    // 已有刷新任务时，将请求加入队列\r\n    return new Promise(resolve => {\r\n      requestsQueue.push(token => {\r\n        error.config.headers.Authorization = token;\r\n        resolve(axios(error.config));\r\n      });\r\n    });\r\n  }\r\n);\r\n```\r\n\r\n**关键设计点**：\r\n\r\n- **安全存储**：Refresh Token 建议通过 HttpOnly Cookie 传输\r\n- **滑动过期**：每次刷新重置 Refresh Token 有效期\r\n- **心跳检测**：页面活跃时预刷新 Token 避免突然中断\r\n- **服务端协同**：维护 Token 黑名单/白名单机制\r\n\r\nhttps://v.douyin.com/XDvlASKVr94/"},{"title":"前端如何用 canvas 来做电影院选票功能，请简要说明","answer":"```vue\r\n<template>\r\n  <canvas ref=\"canvas\" @click=\"handleClick\"></canvas>\r\n  <div>已选座位：{{ selectedSeats.join(', ') }}</div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      seats: [],        // 二维数组存储座位状态 0:可售 1:已选 2:已售\r\n      seatSize: 30,     // 座位直径\r\n      gap: 15,          // 座位间距\r\n      selectedSeats: [] // 记录选中座位\r\n    }\r\n  },\r\n  mounted() {\r\n    this.initCanvas();\r\n    this.generateSeats(10, 8); // 生成10排8列\r\n    this.draw();\r\n  },\r\n  methods: {\r\n    // 1. 初始化画布\r\n    initCanvas() {\r\n      const canvas = this.$refs.canvas;\r\n      const dpr = window.devicePixelRatio;\r\n      const rect = canvas.getBoundingClientRect();\r\n      \r\n      canvas.width = rect.width * dpr;\r\n      canvas.height = rect.height * dpr;\r\n      this.ctx = canvas.getContext('2d');\r\n      this.ctx.scale(dpr, dpr);\r\n    },\r\n\r\n    // 2. 生成座位数据（示例）\r\n    generateSeats(rows, cols) {\r\n      this.seats = Array.from({ length: rows }, (_, i) => \r\n        Array.from({ length: cols }, (_, j) => {\r\n          if (j === 3 || j === 4) return 2; // 模拟中间走道\r\n          return Math.random() > 0.8 ? 2 : 0; // 随机生成已售座位\r\n        })\r\n      );\r\n    },\r\n\r\n    // 3. 绘制座位图\r\n    draw() {\r\n      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\r\n      \r\n      this.seats.forEach((row, i) => {\r\n        row.forEach((state, j) => {\r\n          if (state === 2) return; // 已售不绘制\r\n          \r\n          const x = j * (this.seatSize + this.gap) + this.gap;\r\n          const y = i * (this.seatSize + this.gap) + this.gap;\r\n          \r\n          // 绘制座位\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(x, y, this.seatSize/2, 0, Math.PI*2);\r\n          this.ctx.fillStyle = state === 1 ? '#f00' : '#4CAF50';\r\n          this.ctx.fill();\r\n          this.ctx.stroke();\r\n        });\r\n      });\r\n    },\r\n\r\n    // 4. 处理点击事件\r\n    handleClick(e) {\r\n      const rect = this.$refs.canvas.getBoundingClientRect();\r\n      const x = e.clientX - rect.left;\r\n      const y = e.clientY - rect.top;\r\n      \r\n      // 坐标转行列号\r\n      const col = Math.floor(x / (this.seatSize + this.gap));\r\n      const row = Math.floor(y / (this.seatSize + this.gap));\r\n      \r\n      if (this.seats[row]?.[col] === 0) {\r\n        this.seats[row][col] = 1; // 标记选中\r\n        this.selectedSeats.push(`${row+1}排${col+1}座`);\r\n      } else if (this.seats[row]?.[col] === 1) {\r\n        this.seats[row][col] = 0; // 取消选中\r\n        this.selectedSeats = this.selectedSeats.filter(\r\n          s => s !== `${row+1}排${col+1}座`\r\n        );\r\n      }\r\n      \r\n      this.draw(); // 重绘画布\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style scoped>\r\ncanvas {\r\n  width: 600px;\r\n  height: 400px;\r\n  border: 1px solid #ccc;\r\n}\r\n</style>\r\n```\r\n\r\n**关键实现步骤说明：**\r\n\r\n1. **数据结构**：\r\n   - 二维数组记录座位状态（可售/已选/已售）\r\n   - 独立数组记录选中座位信息\r\n2. **坐标转换**：\r\n   - 将点击坐标转换为行列索引\r\n   - 通过`(seatSize + gap)`计算每个座位区域\r\n3. **绘制优化**：\r\n   - 使用`devicePixelRatio`适配高清屏\r\n   - 仅重新绘制变化部分（示例简化使用全量重绘）\r\n4. **交互逻辑**：\r\n   - 点击时切换状态并更新数据\r\n   - 过滤不可选座位（走道/已售）\r\n\r\n**扩展建议方向**：\r\n\r\n- 双人座/情侣座特殊样式\r\n- 座位分区价格差异化\r\n- 使用离屏Canvas优化绘制性能\r\n- 添加座位编号标注"},{"title":"一般项目里面对请求 request 都会做哪些统一封装？","answer":"**1. 基础配置**\r\n\r\n```javascript\r\n// axios 实例化（baseURL、超时时间、跨域凭证）\r\nconst request = axios.create({\r\n  baseURL: import.meta.env.VITE_API_URL,\r\n  timeout: 15000,\r\n  withCredentials: true\r\n});\r\n```\r\n\r\n**2. 请求拦截器**\r\n\r\n```javascript\r\nrequest.interceptors.request.use(config => {\r\n  // 自动携带Token\r\n  if (store.getters.token) {\r\n    config.headers.Authorization = `Bearer ${store.getters.token}`;\r\n  }\r\n  \r\n  // 全局Loading控制（可选）\r\n  if (!config.silent) showLoading();\r\n  \r\n  // 序列化GET请求数组参数（将 [1,2] 转成 1,2）\r\n  if (config.params) {\r\n    config.paramsSerializer = params => qs.stringify(params, { arrayFormat: 'comma' });\r\n  }\r\n  \r\n  return config;\r\n});\r\n```\r\n\r\n**3. 响应拦截器**\r\n\r\n```javascript\r\nrequest.interceptors.response.use(\r\n  response => {\r\n    // 关闭Loading（与请求拦截器配对）\r\n    if (!response.config.silent) hideLoading();\r\n    \r\n    // 处理二进制流（如文件下载）\r\n    if (response.data instanceof Blob) {\r\n      return response;\r\n    }\r\n    \r\n    // 按后端约定结构处理（示例：{ code, data, msg }）\r\n    const { code, data, msg } = response.data;\r\n    if (code === 200) {\r\n      return data; // 核心数据剥离\r\n    } else {\r\n      return Promise.reject(new Error(msg || '请求异常'));\r\n    }\r\n  },\r\n  error => {\r\n    hideLoading();\r\n    const { response, code } = error;\r\n    \r\n    // 统一错误处理\r\n    if (code === 'ECONNABORTED') {\r\n      error.message = '请求超时，请检查网络';\r\n    } else if (response?.status) {\r\n      switch(response.status) {\r\n        case 401: \r\n          router.push('/login');\r\n          break;\r\n        case 403:\r\n          error.message = '无权访问';\r\n          break;\r\n        case 500:\r\n          error.message = '服务器异常';\r\n          break;\r\n      }\r\n    }\r\n    \r\n    // 非静默模式显示错误提示\r\n    if (!error.config?.silent) {\r\n      Message.error(error.message);\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n```\r\n\r\n**4. 核心功能扩展**\r\n\r\n\r\n\r\n```javascript\r\n// 请求取消（防重复提交）\r\nconst cancelTokenMap = new Map();\r\nconst addCancelToken = (config) => {\r\n  const key = `${config.method}-${config.url}`;\r\n  config.cancelToken = new axios.CancelToken(c => {\r\n    cancelTokenMap.set(key, c);\r\n  });\r\n};\r\n```\r\n\r\n**5. 业务层封装**\r\n\r\n```javascript\r\n// 统一请求方法（支持自动错误捕获）\r\nexport function http(opt) {\r\n  return request(opt).catch(err => {\r\n    // 主动取消的请求不报错（如路由跳转时取消pending请求）\r\n    if (!axios.isCancel(err)) {\r\n      throw err; // 继续抛出给业务层处理\r\n    }\r\n  });\r\n}\r\n\r\n// 示例：GET请求简化版\r\nexport function get(url, params, opt = {}) {\r\n  return http({ method: 'get', url, params, ...opt });\r\n}\r\n\r\n// 示例：POST请求简化版（支持FormData自动转换）\r\nexport function post(url, data, opt = {}) {\r\n  const isFormData = data instanceof FormData;\r\n  return http({\r\n    method: 'post',\r\n    url,\r\n    data,\r\n    headers: isFormData ? { 'Content-Type': 'multipart/form-data' } : {},\r\n    ...opt\r\n  });\r\n}\r\n```\r\n\r\n**6. 高级功能（按需实现）**\r\n\r\n- **请求重试**：对特定状态码（如502）自动重试\r\n\r\n- **缓存策略**：对GET请求添加内存缓存（`new Map()`）\r\n\r\n- **并发控制**：限制同一接口的并行请求数量\r\n\r\n- **Mock适配**：开发环境拦截请求返回模拟数据\r\n\r\n- **TypeScript支持**：封装泛型请求类型\r\n\r\n  ```typescript\r\n  export interface Response<T = any> {\r\n    code: number;\r\n    data: T;\r\n    message: string;\r\n  }\r\n  \r\n  export function get<T>(url: string, params?: any): Promise<Response<T>> {\r\n    return request.get(url, { params });\r\n  }\r\n  ```\r\n\r\n**封装价值**：\r\n\r\n1. **降低重复代码**：统一处理鉴权、错误、Loading等通用逻辑\r\n2. **规范团队协作**：强制约定请求格式和响应处理\r\n3. **增强可维护性**：核心逻辑集中管理，修改影响可控\r\n4. **安全增强**：统一处理XSS防范、CSRF Token等安全策略\r\n5. **扩展性提升**：可快速集成监控上报、性能采集等能力\r\n\r\n[一般项目里面对请求 request 都会做哪些统一封装？](https://github.com/pro-collection/interview-question/issues/498)"},{"title":"XHR 和 Fetch 是否支持取消请求?","answer":"```javascript\r\nconst xhr = new XMLHttpRequest();\r\nxhr.open('GET', '/api/data');\r\nxhr.send();\r\n\r\n// 取消请求\r\nxhr.abort(); \r\n\r\n// 监听取消事件\r\nxhr.onabort = () => {\r\n  console.log('请求已取消');\r\n};\r\n\r\n\r\nconst controller = new AbortController();\r\nconst signal = controller.signal;\r\n\r\n// 发起请求时传入 signal\r\nfetch('/api/data', { signal })\r\n  .then(response => response.json())\r\n  .catch(err => {\r\n    if (err.name === 'AbortError') {\r\n      console.log('请求已取消');\r\n    }\r\n  });\r\n\r\n// 取消请求\r\ncontroller.abort(); \r\n```\r\n\r\n\r\n\r\n[XHR 和 Fetch 是否支持取消请求](https://github.com/pro-collection/interview-question/issues/575)"},{"title":"应用上线后，怎么通知用户刷新当前页面？","answer":"1. WebSocket 实时推送\r\n\r\n2. 轮询版本号接口\r\n3. 页面可见性检查优化:监听visibilitychange → 页面从隐藏切回时触发版本检查"},{"title":"设计一个前端权限控制系统?","answer":"**前端权限控制核心流程：**\r\n\r\n**1. 权限控制维度**\r\n\r\n- **路由权限**：控制页面访问权限\r\n- **操作权限**：控制按钮/功能是否展示\r\n- **数据权限**：控制接口请求参数（通常后端处理）\r\n\r\n**2. 实现流程**\r\n\r\n```javascript\r\n<template>\r\n  <!-- 按钮级权限控制 -->\r\n  <button v-if=\"hasPermission('add')\">新增</button>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      // 模拟从接口获取的权限列表\r\n      permissionList: ['view', 'edit'] \r\n    }\r\n  },\r\n  methods: {\r\n    // 权限校验方法\r\n    hasPermission(code) {\r\n      return this.permissionList.includes(code);\r\n    }\r\n  },\r\n  beforeCreate() {\r\n    // 动态路由处理（需在路由配置前完成）\r\n    const routes = asyncRoutes.filter(route => \r\n      this.hasPermission(route.meta?.permission)\r\n    );\r\n    this.$router.addRoutes(routes);\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\n**3. 完整实现步骤**\r\n\r\n**步骤1：定义路由权限元信息**\r\n\r\n```javascript\r\n// router.js\r\nconst routes = [\r\n  {\r\n    path: '/dashboard',\r\n    component: Dashboard,\r\n    meta: { permission: 'view_dashboard' } // 权限标识\r\n  },\r\n  // ...其他路由\r\n];\r\n\r\n// 异步路由（需动态加载）\r\nexport const asyncRoutes = [\r\n  {\r\n    path: '/admin',\r\n    component: Admin,\r\n    meta: { permission: 'admin_access' }\r\n  }\r\n];\r\n```\r\n\r\n**步骤2：路由守卫全局拦截**\r\n\r\n```javascript\r\nrouter.beforeEach((to, from, next) => {\r\n  // 已登录且需要权限的路由\r\n  if (isLogin && to.meta.permission) {\r\n    // 从Vuex获取权限列表\r\n    const hasPermission = store.getters.permissions.includes(to.meta.permission);\r\n    hasPermission ? next() : next('/403');\r\n  } else {\r\n    next();\r\n  }\r\n});\r\n```\r\n\r\n**步骤3：Vuex存储权限数据**\r\n\r\n```javascript\r\n// store/modules/user.js\r\nconst state = {\r\n  permissions: []\r\n};\r\n\r\nconst mutations = {\r\n  SET_PERMISSIONS(state, perms) {\r\n    state.permissions = perms;\r\n  }\r\n};\r\n\r\n// 登录成功后存储权限\r\nactions.login = async ({ commit }, creds) => {\r\n  const { permissions } = await api.login(creds);\r\n  commit('SET_PERMISSIONS', permissions);\r\n};\r\n```\r\n\r\n**步骤4：全局权限指令**\r\n\r\n```javascript\r\nvue// main.js\r\nVue.directive('permission', {\r\n  inserted(el, binding, vnode) {\r\n    const { value } = binding;\r\n    const hasPerm = store.getters.permissions.includes(value);\r\n    \r\n    if (!hasPerm) {\r\n      el.parentNode?.removeChild(el); // 直接移除DOM\r\n    }\r\n  }\r\n});\r\n\r\n// 使用方式\r\n<button v-permission=\"'delete'\">删除</button>\r\n```\r\n\r\n**4. 高级优化方案**\r\n\r\n- **权限变更监听**：WebSocket实时同步权限变化\r\n\r\n- **按钮级组件封装**\r\n\r\n  ```vue\r\n  <Permission :code=\"'export'\">\r\n    <button>导出数据</button>\r\n  </Permission>\r\n  ```\r\n\r\n- **路由自动注册**：根据权限树自动生成前端路由\r\n\r\n- **接口权限映射**：拦截请求验证是否有权限标识\r\n\r\n**注意事项**\r\n\r\n1. **前端防篡改**：后端必须做二次权限验证\r\n2. **默认拒绝原则**：未明确授权的路由默认不可访问\r\n3. **权限粒度控制**：建议使用RBAC（角色-权限-资源）模型\r\n4. **敏感操作日志**：关键操作记录审计日志\r\n\r\n通过这套方案，可以实现从路由到按钮的全链路权限控制，且通过Vue指令和组件封装保持代码简洁性。"},{"title":"设计一个无限滚动加载的列表 ","answer":"1. 监听滚动事件，计算触底条件\r\n2. 触底时异步加载数据\r\n3. 拼接新数据并更新状态\r\n4. 处理加载状态和边界条件\r\n\r\n```vue\r\n<template>\r\n  <div class=\"scroll-container\" @scroll=\"handleScroll\">\r\n    <!-- 数据列表 -->\r\n    <div v-for=\"item in list\" :key=\"item.id\" class=\"item\">{{ item.content }}</div>\r\n    \r\n    <!-- 加载状态提示 -->\r\n    <div v-if=\"isLoading\">加载中...</div>\r\n    <div v-if=\"isEnd\">没有更多数据了</div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      list: [],       // 已加载数据\r\n      page: 1,        // 当前页码\r\n      limit: 20,      // 每页条数\r\n      isLoading: false,  // 加载锁\r\n      isEnd: false    // 数据是否全部加载完毕\r\n    };\r\n  },\r\n  mounted() {\r\n    this.loadData();  // 初始化加载\r\n  },\r\n  methods: {\r\n    // 滚动事件处理\r\n    handleScroll(e) {\r\n      const { scrollTop, clientHeight, scrollHeight } = e.target;\r\n      // 距离底部 50px 触发加载（防抖已内置）\r\n      if (scrollHeight - (scrollTop + clientHeight) < 50 && !this.isLoading && !this.isEnd) {\r\n        this.loadData();\r\n      }\r\n    },\r\n    \r\n    // 数据加载方法\r\n    async loadData() {\r\n      this.isLoading = true;\r\n      try {\r\n        // 模拟API请求\r\n        const { data, total } = await api.getList({\r\n          page: this.page,\r\n          limit: this.limit\r\n        });\r\n        \r\n        this.list = [...this.list, ...data];\r\n        // 判断是否还有更多数据\r\n        if (this.list.length >= total) this.isEnd = true;\r\n        this.page++;\r\n      } catch (err) {\r\n        console.error('加载失败', err);\r\n      } finally {\r\n        this.isLoading = false;\r\n      }\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style>\r\n.scroll-container {\r\n  height: 500px; \r\n  overflow-y: auto;\r\n  border: 1px solid #eee;\r\n}\r\n.item { padding: 12px; border-bottom: 1px solid #ccc; }\r\n</style>\r\n```"},{"title":"解释JWT（JSON Web Token）的验证流程","answer":"**1. 生成阶段（用户登录）**\r\n\r\n- 用户提交账号密码，服务端验证通过后生成 JWT，包含：\r\n\r\n  ```javascript\r\n  {\r\n    // Header（算法类型）\r\n    \"alg\": \"HS256\",  \r\n    \"typ\": \"JWT\"\r\n  }\r\n  {\r\n    // Payload（业务数据）\r\n    \"sub\": \"user123\",  \r\n    \"exp\": 1735689600  // 过期时间\r\n  }\r\n  ```\r\n\r\n- **签名生成**：使用密钥（如 `HMAC-SHA256`）对 `Header + Payload` 加密，生成签名（Signature）\r\n\r\n- 最终组合成 `Header.Base64Url + Payload.Base64Url + Signature` 格式的 Token 返回给客户端\r\n\r\n**2. 传输阶段**\r\n\r\n- 客户端存储 Token（通常存于 `localStorage` 或 `Cookie`）\r\n- 后续请求通过 `Authorization: Bearer <token>` 携带 Token\r\n\r\n**3. 验证阶段（服务端校验）**\r\n\r\n1. **解码验证**：\r\n   - 分割 Token 的三部分（Header/Payload/Signature）\r\n   - Base64Url 解码 Header 和 Payload\r\n2. **签名校验**：\r\n   - 用相同算法和密钥重新计算签名，比对是否与传入的 Signature 一致\r\n   - **防篡改关键**：签名不匹配则直接拒绝请求\r\n3. **业务校验**：\r\n   - 检查 Payload 中的 `exp`（过期时间）是否有效\r\n   - 验证 `sub`（用户标识）等业务字段是否合法\r\n\r\n**4. 安全扩展**\r\n\r\n- **密钥保护**：使用非对称加密（如 RSA）时，私钥仅服务端持有\r\n- **黑名单机制**：如需实现主动失效，需额外维护 Token 黑名单（违背 JWT 无状态设计，慎用）\r\n- **刷新 Token**：通过独立的 Refresh Token 延长会话，降低主 Token 泄露风险\r\n\r\n**流程示意图**\r\n\r\n```\r\n客户端 → 登录 → 服务端生成JWT → 客户端存储  \r\n客户端 → 携带JWT请求 → 服务端验签 → 返回数据  \r\n```\r\n\r\n**注意事项**：\r\n\r\n- JWT **默认无加密**，敏感数据需配合 HTTPS\r\n- Token 存储需防 XSS（推荐 `HttpOnly Cookie`）\r\n- Payload 不宜过大（影响性能）"},{"title":"如何优化首屏加载时间到1秒以内？","answer":"**一、关键渲染路径优化（Critical Rendering Path）**\r\n\r\n1. **内联关键CSS/JS**\r\n   - 将首屏渲染必需的CSS（如布局、字体、关键组件样式）直接内联到HTML中，避免阻塞渲染的HTTP请求。\r\n   - 关键JS（如初始化逻辑）可内联或通过`<script defer>`加载，避免阻塞DOM解析。\r\n   - **工具推荐**：`critters`（提取关键CSS）、`webpack-inline-critical`。\r\n2. **异步/延迟非关键资源**\r\n   - 非关键JS使用`async`或`defer`，非关键CSS通过`<link rel=\"preload\" as=\"style\" onload=\"this.rel='stylesheet'\">`异步加载。\r\n   - 使用`Intersection Observer`实现图片/组件的懒加载（Lazy Load）。\r\n3. **服务端渲染（SSR）或静态生成（SSG）**\r\n   - 通过Next.js、Nuxt.js等框架实现SSR，或使用Gatsby、Astro生成静态HTML，减少客户端渲染耗时。\r\n\r\n**二、资源加载优化**\r\n\r\n1. **资源压缩与格式优化**\r\n   - **图片**：使用WebP/AVIF格式，通过`<picture>`标签兼容旧浏览器；对图标使用SVG；设置`srcset`按屏幕分辨率加载。\r\n   - **文本资源**：启用Gzip/Brotli压缩（Nginx配置示例：`gzip on; brotli on;`）。\r\n   - **字体**：使用`woff2`格式，通过`font-display: swap`避免阻塞渲染，子集化字体（工具：`pyftsubset`）。\r\n2. **CDN与缓存策略**\r\n   - 静态资源托管到CDN，启用HTTP/2或HTTP/3（QUIC协议）。\r\n   - 设置强缓存（`Cache-Control: max-age=31536000`）和协商缓存（`ETag`）。\r\n3. **预加载关键资源**\r\n   - 使用`<link rel=\"preload\">`提前加载关键字体、图片或JS模块。\r\n   - 预连接第三方域名：`<link rel=\"preconnect\" href=\"https://cdn.example.com\">`.\r\n\r\n**三、代码与构建优化**\r\n\r\n1. **代码分割（Code Splitting）**\r\n   - 按路由分割代码（React的`React.lazy` + `Suspense`，Vue的异步组件）。\r\n   - 使用Webpack的`SplitChunksPlugin`提取公共依赖。\r\n2. **Tree Shaking与Dead Code Elimination**\r\n   - 确保ES6模块语法（`import/export`），通过Webpack/Rollup删除未使用代码。\r\n   - 使用`babel-plugin-lodash`按需加载工具库。\r\n3. **减少第三方依赖**\r\n   - 替换臃肿库（如用`date-fns`代替`moment.js`）。\r\n   - 延迟加载非核心第三方脚本（如分析工具、广告）。\r\n\r\n**四、浏览器渲染优化**\r\n\r\n1. **避免布局抖动（Layout Thrashing）**\r\n   - 批量DOM操作，使用`requestAnimationFrame`调度渲染任务。\r\n   - 用CSS `transform`和`opacity`触发GPU加速（减少重排/重绘）。\r\n2. **优化首屏内容可见性**\r\n   - 使用骨架屏（Skeleton Screen）占位，优先渲染文本内容。\r\n   - 对非首屏组件使用`<div hidden>`或CSS `content-visibility: auto`。\r\n\r\n**五、基础设施优化**\r\n\r\n1. **边缘渲染（Edge SSR）**\r\n   - 使用Cloudflare Workers、Vercel Edge Functions等边缘计算平台，将SSR部署到离用户最近的节点。\r\n2. **HTTP/3与QUIC协议**\r\n   - 启用HTTP/3（需服务器和CDN支持），通过多路复用和0-RTT加速连接。\r\n3. **Service Worker缓存**\r\n   - 对核心资源实现离线缓存（Workbox工具链），支持秒开二次访问。\r\n\r\n**六、性能监控与测试**\r\n\r\n1. **性能指标分析**\r\n   - 使用Lighthouse、WebPageTest测量FCP（First Contentful Paint）、LCP（Largest Contentful Paint）。\r\n   - 通过Chrome DevTools的Performance面板分析长任务（Long Tasks）。\r\n2. **真实用户监控（RUM）**\r\n   - 部署Sentry、New Relic等工具监控真实用户的性能数据。\r\n\r\n**极端优化案例（参考）**\r\n\r\n- **Vue/Nuxt项目**：SSR + 预渲染静态页面 + 内联关键CSS + Brotli压缩 + CDN，首屏时间可压缩至400-600ms。\r\n- **React/Next.js项目**：使用`next/dynamic`动态加载非首屏组件 + 图片懒加载 + 边缘渲染，首屏时间可达800ms以内。\r\n\r\n**总结**\r\n\r\n优化到1秒内的核心思路：\r\n\r\n1. **减少关键资源体积**（HTML/CSS/JS控制在100KB以内）。\r\n2. **最小化网络往返次数**（通过内联、预加载、HTTP/2多路复用）。\r\n3. **优先渲染可见内容**（SSR/骨架屏 + 懒加载）。\r\n4. **利用现代浏览器特性**（如HTTP/3、Service Worker）。\r\n\r\n需根据实际项目通过性能分析工具定位瓶颈，针对性优化。"},{"title":"vue如何封装一个支持响应式更新的富文本编辑器?","answer":"[封装 Quill 编辑器用于 Vue 3](https://juejin.cn/post/7429514987645435915)"},{"title":"请求会弹出一个toast,如何保证批量请求失败，只弹出一个toast?","answer":"要保证批量请求失败只弹出一个toast,但又不能不同消息类型都弹出一个toast,所以需要用缓存池保证当前弹出的toast类型唯一\r\n\r\n```javascript\r\n// utils/request.js  \r\nconst errorMap = new Map()  // 错误缓存池  \r\nconst ERROR_TTL = 5000      // 相同错误5秒内不重复提示  \r\n\r\naxios.interceptors.response.use(null, (error) => {  \r\n  // 1. 生成错误标识（示例逻辑）  \r\n  const errorKey = error.response?.status || error.code || error.message  \r\n\r\n  // 2. 判断是否需要展示  \r\n  if (!errorMap.has(errorKey) {  \r\n    showToast(error.message)  \r\n    errorMap.set(errorKey, Date.now())  \r\n\r\n    // 3. 设置过期时间  \r\n    setTimeout(() => {  \r\n      errorMap.delete(errorKey)  \r\n    }, ERROR_TTL)  \r\n  }  \r\n\r\n  return Promise.reject(error)  \r\n})  \r\n```"},{"title":"如何做好前端的监控方案？","answer":"前端监控需覆盖 **错误追踪**、**性能指标**、**用户行为** 三大维度，核心方案如下：\r\n\r\n1. **错误监控**\r\n   - 全局捕获：`window.onerror` + `unhandledrejection`\r\n   - 框架集成：Vue/React错误边界（Error Boundary）\r\n   - 资源异常：监听`<img><script>`的`onerror`事件\r\n2. **性能监控**\r\n   - 关键指标：通过`Performance API`采集`FP/FCP/LCP/FID/CLS`\r\n   - 接口耗时：拦截AJAX/Fetch记录响应时间与成功率\r\n3. **用户行为**\r\n   - PV/UV：路由切换监听（Hash/History API）\r\n   - 点击热图：记录点击坐标与DOM路径\r\n   - 自定义事件：关键操作埋点（如按钮点击）\r\n4. **数据上报**\r\n   - 节流合并：使用`sendBeacon`或`requestIdleCallback`\r\n   - 失败重试：本地存储失败日志，定时重发"},{"title":"px如何转rem?","answer":"**核心原理**\r\n\r\n- **`rem` 单位**：相对于根元素（`<html>`）的 `font-size`。例如，若根字体为 `16px`，则 `1rem = 16px`。\r\n- **转换公式**：rem值=px值基准字体大小rem值=基准字体大小px值\r\n\r\n转换主要分三步：\r\n\r\n1. **设置基准**：在HTML根元素定义 `font-size: 62.5%`（浏览器默认16px → 1rem=10px）\r\n2. **换算规则**：设计稿px值 ÷ 基准值（如10）→ 例：24px = 2.4rem\r\n3. **自动转换**：用PostCSS插件`postcss-pxtorem`自动编译（配置示例）：\r\n\r\n```javascript\r\n// postcss.config.js  \r\nmodule.exports = {  \r\n  plugins: {  \r\n    'postcss-pxtorem': {  \r\n      rootValue: 10,    // 基准值  \r\n      propList: ['*'],  // 转换所有属性  \r\n      selectorBlackList: ['.norem'] // 黑名单类不转换  \r\n    }  \r\n  }  \r\n}  \r\n```"},{"title":"如何实现面板折叠功能？","answer":"[使css高度auto支持过渡动画](https://lsj97.com/posts/article/%E4%BD%BFcss%E9%AB%98%E5%BA%A6auto%E6%94%AF%E6%8C%81%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/)"},{"title":"前端应用如何做国际化？","answer":"**回答：**\r\n前端国际化（i18n）的核心步骤：\r\n\r\n1. **多语言资源管理**：用 JSON 文件按语言（如 `en.json`、`zh-CN.json`）组织文案，通过工具（如 `i18next`、`vue-i18n`）动态加载。\r\n2. **语言切换**：通过 URL 参数、本地存储或全局状态（如 Redux、Vuex）传递语言标识（如 `en-US`），触发页面渲染更新。\r\n3. **动态内容处理**：\r\n   - 文本：使用键值替换（如 `t('key')`），支持插值、复数形式。\r\n   - 日期/数字：用 `Intl` API（如 `Intl.DateTimeFormat`）或库（如 `date-fns`）按语言格式化。\r\n4. **优化实践**：提取未翻译文本（如 `i18n-extract`），按需加载语言包，兼容 RTL 语言（如阿拉伯语）。\r\n\r\n**工具推荐**：`i18next`、`react-intl`、`vue-i18n`，结合构建工具（如 Webpack）拆分语言包。"},{"title":"用户访问页面白屏，如何排查？","answer":"用户访问页面白屏可能由多种原因引起，以下是一些可能的原因和排查步骤:\r\n\r\n1. **网络问题**:用户的网络连接可能存在问题，无法正确加载页面内容。可以要求用户检查网络连接，或者自己尝试在不同网络环境下测试页面的加载情况。\r\n\r\n2. **服务端问题**:服务器未正确响应用户请求，导致页面无法加载。可以检查服务器的状态、日志和错2误信息，查看是否有任何异常。同时，可以确认服务器上的相关服务是否正常运行。\r\n\r\n3. **前端代码问题**:页面的前端代码可能存在错误或异常，导致页面无法正常渲染。可以检查浏览器的开发者工具，查看是否有任何错误信息或警告。同时，可以尝试将页面的JavaScript、CSs和HTML代码分离出来进行单独测试，以确定具体的问题所在。\r\n\r\n4. **浏览器兼容性问题**:不同浏览器对于某些代码的支持可能不一致，导致页面在某些浏览器中无法正.常加载。可以尝试在不同浏览器中测试页面的加载情况，同时使用浏览器的开发者工具检查是否有任何错误或警告。\r\n\r\n5. **第三方资源加载问题**:页面可能依赖于某些第三方资源(如外部脚本、样式表等)，如果这些资源\r\n   无法加载，可能导致页面白屏。可以检查网络请求是否正常，是否有任何资源加载失败的情况。\r\n\r\n6. **缓存问题**:浏览器可能在缓存中保存了旧版本的页面或资源，导致新版本无法加载。可以尝试清除6.\r\n   浏览器缓存，或者通过添加随机参数或修改文件名的方式强制浏览器重新加载页面和资源。\r\n\r\n7. **其他可能原因**:页面白屏问题还可能由于安全策略(如CSP、CORS等)限制、跨域问题、DNS解析问题等引起。可以使用浏览器的开发者工具检查网络请求和错误信息，查找可能的问题。\r\n\r\n在排查问题时，可以根据具体情况逐步进行排查，并结合浏览器的开发者工具、服务器日志等工具来辅助定位问题所在，并且可以与用户进行进一步沟通以获取更多信息。如果问题无法解决，可以寻求专业的技术支持或咨询。"},{"title":"站点如何防止爬虫？","answer":"1. **基础防护**：设置 `robots.txt` 限制合规爬虫，后端校验请求头（如 `User-Agent`、`Referer`）。\r\n2. **动态干扰**：页面注入随机噪声数据（如隐藏假链接），频繁操作触发验证码。\r\n3. **反自动化**：关键接口添加加密参数（如签名 `Token`），前端点击行为校验（如轨迹监测）。\r\n4. **深度防御**：IP 限流/黑名单，使用反爬服务（如 Cloudflare Bot Management）。"},{"title":"你是如何从零到一搭建一个项目的？","answer":"**一、需求分析与技术选型**\r\n\r\n1. **明确需求**\r\n   - 项目类型：SPA、SSR、静态网站、移动端H5？\r\n   - 功能模块：是否需要路由、状态管理、数据可视化等？\r\n   - 目标用户：兼容性要求（浏览器、分辨率、移动端适配）？\r\n2. **技术选型**\r\n   - **框架**：React（生态丰富）、Vue（轻量易上手）、Svelte（高性能）或纯原生。\r\n   - **构建工具**：Vite（极速热更新）、Webpack（高度定制化）、Rollup（库开发）。\r\n   - **状态管理**：Redux（复杂场景）、Zustand（轻量）、Pinia（Vue专属）。\r\n   - **CSS方案**：CSS-in-JS（Styled-components）、Utility-First（Tailwind CSS）、预处理器（Sass/Less）。\r\n   - **其他**：TypeScript（类型安全）、测试框架（Jest + Testing Library）、E2E工具（Cypress）。\r\n\r\n**二、初始化项目**\r\n\r\n1. **脚手架创建**\r\n2. **安装核心依赖**\r\n\r\n**三、项目结构设计**\r\n\r\n**四、工程化配置**\r\n\r\n1. **别名配置（vite.config.ts）**\r\n\r\n2. **代码规范**\r\n\r\n- ESLint + Airbnb规范：检查语法错误。\r\n- Prettier：统一代码风格。\r\n- Husky + lint-staged：提交前自动格式化。\r\n\r\n3. **环境变量**\r\n\r\n- 区分开发、测试、生产环境（`.env.development`, `.env.production`）。\r\n- 敏感数据通过VITE_前缀暴露给客户端（Vite专用）。\r\n\r\n**五、开发与联调**\r\n\r\n1. **Mock数据**\r\n   - 使用 Mock.js 或 json-server 快速模拟接口。\r\n   - 示例（json-server）：\r\n2. **代理配置（解决跨域）**\r\n\r\n**六、性能优化**\r\n\r\n1. **构建优化**\r\n   - 代码分割（动态import()、路由懒加载）。\r\n   - 压缩资源：Terser压缩JS、CSSNano压缩CSS。\r\n   - 静态资源CDN托管。\r\n2. **运行时优化**\r\n   - 虚拟列表（react-window）优化长列表渲染。\r\n   - 图片懒加载（Intersection Observer API）。\r\n   - Web Worker处理复杂计算。\r\n\r\n**七、部署与监控**\r\n\r\n1. **部署流程**\r\n   - CI/CD工具：GitHub Actions、Jenkins。\r\n   - 容器化：Docker + Nginx（配置Gzip、缓存策略）\r\n2. **监控与统计**\r\n   - 错误收集：Sentry、Fundebug。\r\n   - 性能分析：Google Lighthouse、Web Vitals。\r\n   - 用户行为：Google Analytics、Hotjar。\r\n\r\n**八、维护与迭代**\r\n\r\n1. **文档管理**\r\n   - 使用 Storybook 或 Docusaurus 编写组件文档。\r\n2. **依赖更新**\r\n   - 定期运行 `npm outdated` 升级依赖版本。\r\n3. **错误处理**\r\n   - 全局异常捕获（React Error Boundary）。\r\n\r\n**关键注意事项**\r\n\r\n- **版本控制**：合理设计 Git 分支策略（Git Flow/GitHub Flow）。\r\n- **SEO优化**：SPA项目需结合预渲染（prerender-spa-plugin）或SSR。\r\n- **安全防护**：XSS过滤、CSP配置、敏感信息加密。"},{"title":"实现视差滚动效果","answer":"实现视差滚动核心思路是**多层元素以不同速率滚动**，常用方法：\r\n\r\n1. **纯CSS实现**（简单场景）：\r\n\r\n   ```CSS\r\n   .parallax-container {  \r\n     perspective: 1px; /* 透视效果 */  \r\n     overflow-x: hidden;  \r\n     height: 100vh;  \r\n   }  \r\n   .layer {  \r\n     transform-style: preserve-3d;  \r\n   }  \r\n   .layer-slow {  \r\n     transform: translateZ(-2px) scale(3); /* 滚动更慢 */  \r\n   }  \r\n   .layer-fast {  \r\n     transform: translateZ(1px) scale(0.5); /* 滚动更快 */  \r\n   }  \r\n   ```\r\n\r\n2. **JavaScript动态控制**（灵活性强）：\r\n\r\n   ```javascript\r\n   window.addEventListener('scroll', () => {  \r\n     const scrolled = window.pageYOffset;  \r\n     document.querySelector('.bg-layer').style.transform =   \r\n       `translateY(${scrolled * 0.5}px)`; // 背景层慢速移动  \r\n     document.querySelector('.text-layer').style.transform =   \r\n       `translateY(${scrolled * 1.2}px)`; // 文字层快速移动  \r\n   });  \r\n   ```\r\n\r\n3. **使用库（如Parallax.js）**（快速集成）：\r\n\r\n   ```HTML\r\n   <div data-parallax=\"scroll\" data-image-src=\"bg.jpg\"></div>  \r\n   <script src=\"parallax.min.js\"></script>  \r\n   ```"},{"title":"说说Vue封装组件的流程，需要注意些什么？你会有些什么样的原则？","answer":"- 封装Vue组件一般分为以下步骤和注意事项：\r\n\r\n  流程：\r\n\r\n  1. 明确职责边界，拆分可复用功能\r\n  2. 定义props/emit接口，做好参数校验\r\n  3. 使用插槽机制保持扩展性\r\n  4. 添加必要的样式隔离（scoped）\r\n  5. 编写组件文档和使用示例\r\n\r\n  注意事项：\r\n\r\n  - 保持单一职责原则\r\n  - 避免直接操作父组件DOM\r\n  - 合理处理边界情况（空状态、加载态等）\r\n  - 提供清晰的接口文档\r\n\r\n  设计原则：\r\n\r\n  1. 高内聚低耦合\r\n  2. 受控组件优先\r\n  3. 合理的默认值配置\r\n  4. 良好的TS类型支持\r\n  5. 兼容性考虑（如v-model双向绑定）"},{"title":"如何判断当前脚本运行在浏览器还是 node 环境中？","answer":"```javascript\r\n// 判断浏览器环境\r\nconst isBrowser = typeof window !== 'undefined' \r\n  && typeof window.document !== 'undefined'\r\n\r\n// 判断Node环境\r\nconst isNode = typeof process !== 'undefined' \r\n  && process.versions \r\n  && process.versions.node\r\n```"},{"title":"你在项目中遇到过哪些性能瓶颈？是如何解决的？","answer":"在项目中遇到的典型性能瓶颈及解决方案：\r\n\r\n1. **首屏加载慢**：\r\n   - **问题**：资源过大（如图片/JS未压缩），接口串行请求。\r\n   - **解决**：\r\n     - 代码分割（`Vue Router懒加载`）\r\n     - 图片懒加载 + WebP格式\r\n     - 接口请求合并 + HTTP2多路复用\r\n2. **长列表渲染卡顿**：\r\n   - **问题**：DOM节点过多导致重绘耗时。\r\n   - **解决**：\r\n     - 虚拟滚动（`vue-virtual-scroller`）\r\n     - 分页加载 + 骨架屏占位\r\n3. **内存泄漏**：\r\n   - **问题**：全局事件监听、定时器未销毁（如弹窗组件多次挂载）。\r\n   - **解决**：\r\n     - 使用`beforeUnmount`移除事件/定时器\r\n     - Chrome DevTools Memory面板定位泄漏源\r\n4. **高频交互卡顿**：\r\n   - **问题**：频繁触发`resize`/`scroll`导致函数重复执行。\r\n   - **解决**：\r\n     - 防抖/节流（`lodash.throttle`）\r\n     - 使用`requestAnimationFrame`优化动画\r\n5. **接口重复请求**：\r\n   - **问题**：按钮快速点击导致重复提交。\r\n   - **解决**：\r\n     - 请求锁（`isLoading`状态拦截）\r\n     - 客户端缓存（如`localStorage`短期缓存）\r\n\r\n**优化工具**：\r\n\r\n- Lighthouse分析性能指标\r\n- Webpack Bundle Analyzer分析包体积\r\n- Vue DevTools追踪组件渲染耗时"},{"title":"如何监控页面卡顿？","answer":"监控页面卡顿的核心方法：\r\n\r\n1. **FPS检测**：通过`requestAnimationFrame`计算帧率，持续低于50FPS视为卡顿。\r\n2. **长任务监听**：用`PerformanceObserver`捕获超过50ms的Long Tasks（主线程阻塞）。\r\n3. **用户交互延迟**：监听点击/输入事件，统计响应时间（如从`pointerdown`到`next paint`）。\r\n4. **框架工具**：Vue/React DevTools定位渲染耗时组件，Chrome Performance分析调用栈。\r\n\r\n**示例代码（长任务上报）**：\r\n\r\n```javascript\r\nconst observer = new PerformanceObserver(list => {  \r\n  list.getEntries().forEach(entry => {  \r\n    if (entry.duration > 50) {  \r\n      console.log('卡顿：', entry);  \r\n      // 上报至监控系统  \r\n    }  \r\n  });  \r\n});  \r\nobserver.observe({ entryTypes: ['longtask'] });  \r\n```"},{"title":"如何自定义鼠标右键菜单？","answer":""},{"title":"如果要设计一个转盘组件，你会考虑哪些方面？有哪些是需要和业务方确认的技术细节？另外，如何从前端的角度进行防刷？","answer":"**一、核心设计考虑因素**\r\n\r\n1. **UI 与交互设计**\r\n\r\n   - **视觉呈现**：转盘扇形区域布局（等分/不等分）、动态光影效果、指针/中心点设计\r\n   - **动画效果**：旋转惯性模拟（缓动函数）、停止位置精准对齐、多段式动画（加速 → 匀速 → 减速）\r\n   - **响应式适配**：不同屏幕尺寸下的比例缩放、横竖屏切换时的重绘策略\r\n   - **音效反馈**：启动音效、旋转背景音、停止提示音\r\n\r\n2. **技术实现方案**\r\n\r\n   - **动画引擎选择**：\r\n\r\n     - CSS3 Transform + Transition（轻量级简单场景）\r\n     - GSAP（复杂缓动控制）\r\n     - Canvas（高性能复杂动画）\r\n\r\n   - **停止位置计算**：\r\n\r\n     ```javascript\r\n     // 示例：根据后端返回的奖品索引计算停止角度\r\n     const stopAngle = initialAngle + (targetIndex * sectorAngle) + 360 * 5; // 多转5圈\r\n     ```\r\n\r\n   - **数据驱动**：动态奖品列表渲染（Vue/React 数据绑定）\r\n\r\n3. **异常处理**\r\n\r\n   - 网络中断时的降级提示\r\n   - 奖品加载失败后的占位图处理\r\n   - 抽奖接口限流后的友好提示\r\n\r\n**二、需与业务方确认的技术细节**\r\n\r\n| **分类**     | **需确认内容**                                               |\r\n| :----------- | :----------------------------------------------------------- |\r\n| **抽奖规则** | 1. 中奖概率计算方式（前端静态配置/后端动态下发） 2. 用户资格判断条件（登录态、积分、每日次数限制） |\r\n| **奖品逻辑** | 1. 奖品类型（实物/虚拟） 2. 多级奖品嵌套逻辑（如先抽奖池再抽具体奖品） |\r\n| **交互流程** | 1. 抽奖结果展示方式（即时弹窗/独立页面） 2. 重复抽奖冷却时间 |\r\n| **数据对接** | 1. 奖品列表接口格式 2. 抽奖动作的API触发时机（动画前预请求/动画后请求） |\r\n| **安全要求** | 1. 是否需要前端加密参数 2. 防刷策略的严格程度                |\r\n\r\n**三、前端防刷方案**\r\n\r\n1. **基础防护层**\r\n\r\n   - **频率限制**：\r\n\r\n     ```javascript\r\n     let isClickable = true;\r\n     startButton.addEventListener('click', () => {\r\n       if (!isClickable) return;\r\n       isClickable = false;\r\n       setTimeout(() => { isClickable = true; }, 3000); // 3秒冷却\r\n     });\r\n     ```\r\n\r\n   - **操作验证**：\r\n\r\n     - 添加图形验证码（如旋转拼图）\r\n     - 行为验证（检测连续点击间隔是否异常）\r\n\r\n2. **请求安全层**\r\n\r\n   - **参数混淆**：\r\n\r\n     - 使用动态 token（由后端生成临时令牌）\r\n     - 时间戳 + 随机数签名（防止重放攻击）\r\n\r\n   - **加密传输**：\r\n\r\n     ```javascript\r\n     // 示例：使用 AES 加密抽奖请求参数\r\n     const encryptedData = CryptoJS.AES.encrypt(JSON.stringify(data), secretKey).toString();\r\n     ```\r\n\r\n3. **环境检测层**\r\n\r\n   - **设备指纹**：\r\n\r\n     - 通过 `navigator.userAgent` + Canvas 指纹生成唯一标识\r\n\r\n   - **脚本检测**：\r\n\r\n     - 检测常见自动化工具特征（如 Puppeteer 的 Headless 模式）\r\n\r\n     ```javascript\r\n     const isHeadless = !('onshow' in window) || navigator.webdriver; \r\n     if (isHeadless) blockRequest();\r\n     ```\r\n\r\n4. **日志监控层**\r\n\r\n   - 上报用户点击坐标轨迹（检测机械式点击模式）\r\n   - 记录抽奖时间间隔分布（识别高频异常行为）\r\n\r\n**四、推荐技术组合**\r\n\r\n| **模块**   | **推荐方案**                                                 |\r\n| :--------- | :----------------------------------------------------------- |\r\n| 动画引擎   | GSAP + CSS Custom Properties（精准控制贝塞尔曲线）           |\r\n| 数据通信   | Axios 拦截器 + JWT 动态令牌                                  |\r\n| 防刷基础库 | @fingerprintjs/fingerprintjs（设备指纹） + crypto-js（参数加密） |\r\n| 异常监控   | Sentry（错误日志） + 自定义行为分析埋点                      |\r\n\r\n**五、注意事项**\r\n\r\n1. **动画性能**：\r\n   - 避免频繁重绘，使用 `will-change: transform` 开启 GPU 加速\r\n   - 采用 `requestAnimationFrame` 替代 setTimeout 实现平滑动画\r\n2. **安全兜底**：\r\n   - 前端防刷仅为辅助手段，核心防护需依赖后端（如IP限流、用户行为分析模型）\r\n3. **法律合规**：\r\n   - 明确公示中奖概率（需符合当地法律法规要求）"},{"title":"写出一个函数trans，将数字转换成汉语的输出","answer":"```javascript\r\n function toChineseNumber(num) {\r\n      //  四位四位的进行分割\r\n      const parts = num\r\n        .toString()\r\n        .replace(/(?=(\\d{4})+$)/g, ',')\r\n        .split(',')\r\n        .filter(Boolean)\r\n \r\n      const map = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九']\r\n      const units = ['', '十', '百', '千']\r\n      // 把连续的零给去掉 合并为1个零  当零在末尾的时候去掉\r\n      function _handleZero(str) {\r\n        return str.replace(/零+/g, '零').replace(/零$/, '')\r\n      }\r\n      function _transform(n) {\r\n        let result = ''\r\n        for (let i = 0; i < n.length; i++) {\r\n          const c = map[n[i]]\r\n          let u = units[n.length - i - 1]\r\n          if (c === '零') {\r\n            u = ''\r\n          }\r\n          result += c + u\r\n        }\r\n        result = _handleZero(result)\r\n        return result\r\n      }\r\n      const bigUnits = ['', '万', '亿']\r\n      let result = ''\r\n      for (let i = 0; i < parts.length; i++) {\r\n        const p = parts[i]\r\n        const c = _transform(p)\r\n        const u = bigUnits[parts.length - i - 1]\r\n        if (c === '') {\r\n          result += '零'\r\n          continue\r\n        }\r\n        result += c + u\r\n      }\r\n      result = _handleZero(result)\r\n      return result\r\n    }\r\n\r\n```"},{"title":"怎么预防用户快速连续点击，造成数据多次提交？","answer":"- css设置 `pointer-events` 为 `none`\r\n- 增加变量控制，当变量满足条件时才执行点击事件的后续代码（比如给按钮的点击事件增加防抖）\r\n- 如果按钮使用 button 标签实现，可以使用 `disabled` 属性\r\n- 加遮罩层，比如一个全屏的loading，避免触发按钮的点击事件"},{"title":"怎么让页面上的某块区域全屏展示？","answer":""},{"title":"怎么在页面上获取用户的定位信息？","answer":""},{"title":"如何控制 input 输入框只能输入数字？","answer":""},{"title":"ChatGPT 的对话功能实现，为什么选择 SSE 协议而非 Websocket ？","answer":""},{"title":"有一个新的前端项目需要部署到线上，你有什么思路？","answer":"1. **项目准备阶段**：\r\n\r\n- **检查项目构建配置**：确保项目的构建配置文件（如 `webpack.config.js` 或 `vite.config.js`）已准备好并针对生产环境进行了优化（如代码压缩、Tree Shaking 等）。\r\n- **环境变量**：配置环境变量，确保生产环境下的 API 地址和其他配置项正确。\r\n- **依赖检查**：确保所有依赖项在 `package.json` 中已定义并通过 `npm install` 正确安装。\r\n\r\n2. **构建项目**：\r\n\r\n- **打包构建**：使用构建命令（如 `npm run build`）生成生产环境的静态文件。\r\n- **打包产物检查**：检查打包后的文件，确保体积、性能、加载顺序等方面都正常。检查生成的 `index.html`、CSS 和 JS 文件等是否按预期生成。\r\n- 也可使用流水线进行构建\r\n\r\n3. **选择部署平台**：\r\n\r\n- **静态服务器（Nginx/Apache）**：如需要自托管，选择 Nginx 或 Apache 来托管静态文件。为单页面应用（SPA）做好路由回退配置。\r\n- **云服务平台**：如 AWS S3、阿里云 OSS 等静态托管服务。\r\n- **部署平台**：如 Vercel、Netlify，这类平台支持自动化部署，并提供 CI/CD 集成。\r\n\r\n4. **上传构建文件**：\r\n\r\n- 自托管服务器：\r\n  - 通过 FTP、SCP 或 Rsync 上传打包后的静态文件到服务器上的指定目录。\r\n  - 如果使用 Docker，可以通过 Docker 容器化前端应用，并将其部署到云服务器上。\r\n- 云服务平台：\r\n  - 使用对应的 SDK 或 CLI 工具（如 AWS CLI、OSS CLI）上传文件到云存储。\r\n- 平台自动化部署：\r\n  - 如使用 Vercel 或 Netlify，可连接 Git 仓库，设置自动化构建和部署。\r\n\r\n5. **配置服务器**：\r\n\r\n- **Nginx 配置**：配置 Nginx 或其他服务器，指向项目的根目录，并处理 SPA 的路由问题。\r\n- **缓存优化**：配置 HTTP 缓存策略（如 `Cache-Control` 和 `ETag`），优化文件的缓存和加载速度。\r\n- **CDN 配置**：如果有全球用户，考虑使用 CDN 分发静态文件，提升加载速度。\r\n\r\n6. **设置域名和 HTTPS**：\r\n\r\n- **绑定域名**：确保域名已解析到服务器的 IP 地址或绑定到云平台。\r\n- **HTTPS 支持**：通过 Let’s Encrypt 或购买 SSL 证书，确保项目可以通过 HTTPS 访问。\r\n\r\n7. **自动化部署（可选）**：\r\n\r\n- **CI/CD 集成**：集成 CI/CD 工具（如 GitHub Actions、Jenkins），自动完成构建、测试和部署流程。\r\n- **钩子配置**：如使用 Vercel/Netlify 等平台，配置 Webhooks，确保每次代码变更后自动部署。\r\n\r\n8. **测试和监控**：\r\n\r\n- **测试部署环境**：在生产环境下进行全面的功能测试，确保所有 API 调用、页面加载和用户交互正常。\r\n- **性能监控**：引入监控工具（如 Google Analytics、Sentry）监控性能和错误日志。\r\n- **定期更新和维护**：定期检查项目性能、修复潜在问题，并根据业务需求进行定期更新。"},{"title":"如何做一个前端项目工程的自动化部署，有哪些规范和流程设计？","answer":""},{"title":"Vue实现下拉菜单,要求点击区域外能关闭组件","answer":""},{"title":"如何封装一个请求，让其多次调用的时候，实际只发起一个请求的时候，返回同一份结果？","answer":""},{"title":"如何在浏览器中实现 PDF 文件的预览？","answer":""}]