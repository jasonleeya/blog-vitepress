[{"title":"说说你对vue的理解?","answer":"<p>Vue 是一个<strong>渐进式前端框架</strong>，核心在于 <strong>数据驱动</strong> 和 <strong>组件化</strong>，通过响应式系统自动更新视图，减少 DOM 操作。其特点包括：</p>\n<ol>\n<li><strong>响应式数据</strong>：Vue 2 用 <code>Object.defineProperty</code>，Vue 3 升级为 <code>Proxy</code>，实现数据变动自动渲染。</li>\n<li><strong>组件化开发</strong>：单文件组件（.vue）整合模板、逻辑与样式，支持组合式 API（Vue 3）提升逻辑复用性。</li>\n<li><strong>虚拟 DOM</strong>：高效 Diff 算法优化渲染性能，平衡速度与内存消耗。</li>\n<li><strong>指令系统</strong>：<code>v-model</code> 等模板语法简化双向绑定，<code>v-if</code>/<code>v-for</code> 等指令声明式操作 DOM。</li>\n<li><strong>渐进式生态</strong>：可逐步集成路由（Vue Router）、状态管理（Pinia）、SSR（Nuxt.js）等，适配不同项目规模。</li>\n<li><strong>开发体验</strong>：文档友好、学习曲线平缓，搭配 Vite 工具链实现快速热更新。</li>\n</ol>\n"},{"title":"什么是 mvvm？","answer":"<p>MVVM 是 <strong>Model-View-ViewModel</strong> 的架构模式，核心是通过 <strong>数据绑定</strong> 实现视图与数据的自动同步。</p>\n<p><strong>核心分层</strong>：</p>\n<ol>\n<li><strong>Model</strong>：数据层（如接口返回的原始数据）；</li>\n<li><strong>View</strong>：UI 界面（DOM 结构）；</li>\n<li><strong>ViewModel</strong>：连接层，监听 Model 变化并更新 View，处理 View 的交互更新 Model（如 Vue 的响应式系统）。</li>\n</ol>\n<p><strong>优势</strong>：</p>\n<ul>\n<li><strong>双向绑定</strong>：数据变动自动更新视图（如 Vue 的 <code>v-model</code>）；</li>\n<li><strong>解耦</strong>：业务逻辑集中在 ViewModel，View 更纯粹；</li>\n<li><strong>开发效率</strong>：减少手动操作 DOM 的代码。</li>\n</ul>\n<p><strong>对比 MVC</strong>：</p>\n<ul>\n<li>MVC 需手动更新视图（如操作 DOM），MVVM 通过数据驱动自动更新。</li>\n</ul>\n"},{"title":"说说你对双向绑定的理解?","answer":"<p>Vue的双向绑定核心是通过数据劫持（比如<code>Object.defineProperty</code>或Vue3的<code>Proxy</code>）结合发布-订阅模式实现的。简单说，数据变化时自动更新视图（数据驱动），视图变化（比如输入框输入）时通过事件监听同步更新数据。<code>v-model</code>就是语法糖，内部自动处理了<code>value</code>属性和<code>input</code>事件的绑定。底层还依赖依赖收集和虚拟DOM的比对更新。</p>\n"},{"title":"谈谈你对Vue数据响应式的理解 ","answer":"<p>Vue的数据响应式核心是让数据变动自动触发视图更新。实现原理主要是通过：</p>\n<ol>\n<li><strong>数据劫持</strong>：Vue2用<code>Object.defineProperty</code>拦截对象属性的读写，Vue3改用<code>Proxy</code>直接代理整个对象，能监听新增属性和数组变化。</li>\n<li><strong>依赖收集</strong>：每个组件实例对应一个<code>Watcher</code>，在渲染过程中访问数据时触发<code>getter</code>，把当前<code>Watcher</code>收集为依赖。</li>\n<li><strong>派发更新</strong>：数据变化时触发<code>setter</code>或<code>Proxy</code>的拦截，通知所有关联的<code>Watcher</code>重新渲染组件。\n需要注意，直接通过索引改数组或给对象新增属性无法触发响应（Vue2中需用<code>Vue.set</code>或数组变异方法），而Vue3的<code>Proxy</code>天然支持这些操作。</li>\n</ol>\n"},{"title":"Vue实例挂载的过程中发生了什么??","answer":"<ol>\n<li><strong>合并配置</strong>：把用户传的<code>options</code>（比如data、methods）和全局配置（如Vue.mixin的内容）合并。</li>\n<li><strong>初始化生命周期/事件/渲染函数</strong>：创建组件实例关联的<code>$parent</code>、<code>$children</code>，初始化事件监听等。</li>\n<li><strong>处理响应式数据</strong>：把<code>data</code>、<code>props</code>等用<code>Object.defineProperty</code>（Vue2）或<code>Proxy</code>（Vue3）转成响应式，建立依赖关系。</li>\n<li><strong>解析模板/生成渲染函数</strong>：如果是选项式写法，会把<code>template</code>编译成<code>render</code>函数（运行时编译需要带编译器版本的Vue）。</li>\n<li><strong>挂载DOM</strong>：执行<code>render</code>生成虚拟DOM，通过<code>patch</code>方法转成真实DOM插入页面，同时触发<code>mounted</code>钩子。\n整个过程穿插调用<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>等生命周期钩子。</li>\n</ol>\n"},{"title":"计算属性和watch的区别及使用场景","answer":"<p><strong>选择原则</strong>：</p>\n<ul>\n<li>需要<strong>动态计算新值</strong>且依赖其他数据 → <code>computed</code>；</li>\n<li>需要<strong>监听变化执行副作用</strong>（如异步操作） → <code>watch</code>。</li>\n</ul>\n<p><strong>区别</strong>：</p>\n<ol>\n<li><strong>核心用途</strong>\n<ul>\n<li><strong><code>computed</code></strong>：<strong>基于依赖计算新值</strong>（如合并 <code>firstName</code> 和 <code>lastName</code> 为全名），适合需要<strong>动态计算且依赖其他数据</strong>的场景。</li>\n<li><strong><code>watch</code></strong>：<strong>监听数据变化并执行回调</strong>（如接口请求、DOM 操作），适合需要<strong>响应变化执行异步或复杂逻辑</strong>的场景。</li>\n</ul>\n</li>\n<li><strong>缓存机制</strong>\n<ul>\n<li><strong><code>computed</code></strong>：<strong>有缓存</strong>，依赖值未变化时直接返回缓存结果，避免重复计算。</li>\n<li><strong><code>watch</code></strong>：<strong>无缓存</strong>，每次监听的值变化都会触发回调。</li>\n</ul>\n</li>\n<li><strong>返回值</strong>\n<ul>\n<li><strong><code>computed</code></strong>：必须返回一个值（通过 <code>getter</code>），可被模板直接使用。</li>\n<li><strong><code>watch</code></strong>：无需返回值，通常在回调中执行操作（如请求接口）。</li>\n</ul>\n</li>\n<li><strong>异步支持</strong>\n<ul>\n<li><strong><code>computed</code></strong>：<strong>不支持异步</strong>，必须是同步计算。</li>\n<li><strong><code>watch</code></strong>：<strong>支持异步</strong>（如 <code>setTimeout</code>、接口调用）。</li>\n</ul>\n</li>\n<li><strong>配置选项</strong>\n<ul>\n<li><strong><code>watch</code></strong>：可配置 <code>deep</code>（深度监听对象属性）、<code>immediate</code>（立即执行回调）等选项。</li>\n<li><strong><code>computed</code></strong>：无法配置这些选项。</li>\n</ul>\n</li>\n</ol>\n<p><strong>使用场景</strong></p>\n<ul>\n<li><strong>用 <code>computed</code></strong>：\n需要基于依赖数据<strong>动态计算新值</strong>，且希望利用缓存优化性能时（如模板中频繁使用的计算值）。</li>\n<li><strong>用 <code>watch</code></strong>：\n需要<strong>响应数据变化执行副作用</strong>（如异步请求、操作 DOM、调用方法），或需要监听非响应式数据（如路由参数）。</li>\n</ul>\n"},{"title":"Vue中的v-show和v-if怎么理解？","answer":"<ul>\n<li><strong>v-if</strong> 是“条件渲染”，根据表达式真假决定是否渲染元素到DOM。为<code>false</code>时元素直接不存在于DOM中，切换时会触发组件的销毁/重建，适合条件变动少的场景。</li>\n<li><strong>v-show</strong> 是“显示切换”，无论条件如何，元素始终被渲染到DOM，只是通过<code>display: none</code>控制显隐。切换开销小，适合频繁切换的场景。\n简单说：<code>v-if</code>操作DOM增删，<code>v-show</code>只改CSS显隐。</li>\n</ul>\n"},{"title":"说说你对Vue生命周期的理解?","answer":"<p>Vue生命周期是组件从创建到销毁的各个阶段，每个阶段会触发对应的钩子函数，方便我们在特定时机执行逻辑。主要分这几个阶段：</p>\n<ol>\n<li><strong>创建阶段</strong>：\n<ul>\n<li><code>beforeCreate</code>：实例刚创建，数据、方法还未初始化。</li>\n<li><code>created</code>：数据、计算属性、方法已初始化，但DOM未生成（适合发起异步请求）。</li>\n</ul>\n</li>\n<li><strong>挂载阶段</strong>：\n<ul>\n<li><code>beforeMount</code>：模板编译完成，但尚未挂载到DOM。</li>\n<li><code>mounted</code>：DOM已挂载，可操作DOM或访问<code>$refs</code>（但子组件不一定全部挂载）。</li>\n</ul>\n</li>\n<li><strong>更新阶段</strong>：\n<ul>\n<li><code>beforeUpdate</code>：数据变化后，DOM更新前。</li>\n<li><code>updated</code>：DOM更新完成（避免在此处直接改数据，可能导致循环更新）。</li>\n</ul>\n</li>\n<li><strong>销毁阶段</strong>：\n<ul>\n<li><code>beforeDestroy</code>/<code>beforeUnmount</code>（Vue3）：实例销毁前，清理定时器、解绑事件。</li>\n<li><code>destroyed</code>/<code>unmounted</code>（Vue3）：实例已销毁，所有绑定和监听被移除。</li>\n</ul>\n</li>\n</ol>\n<p><strong>注意</strong>：Vue3用<code>setup</code>替代了部分选项式API的钩子，但逻辑类似（如<code>onMounted</code>替代<code>mounted</code>）。父子组件的生命周期顺序也要注意（父beforeCreate→子created→子mounted→父mounted）。</p>\n"},{"title":"为什么Vue中的v-if和v-for不建议一起用?","answer":"<ol>\n<li><strong>优先级问题</strong>：\n<ul>\n<li><strong>Vue2</strong>中<code>v-for</code>优先级高于<code>v-if</code>，会导致先循环所有数据再逐个判断条件，即使大部分数据无需渲染，造成性能浪费。</li>\n<li><strong>Vue3</strong>中<code>v-if</code>优先级更高，但此时<code>v-if</code>无法访问到<code>v-for</code>的循环变量，可能导致逻辑错误。</li>\n</ul>\n</li>\n<li><strong>性能损耗</strong>：\n两者一起使用时，每次渲染都会先执行循环再过滤（或条件无法正确过滤），导致不必要的计算和DOM操作。</li>\n</ol>\n<p><strong>正确做法</strong>：将<code>v-if</code>移到外层容器（如用<code>&lt;template&gt;</code>包裹），或通过<strong>计算属性</strong>提前过滤数据，再用<code>v-for</code>遍历。</p>\n"},{"title":"为什么data属性是一个函数而不是一个对象？","answer":"<p>Vue的<code>data</code>必须是一个函数，主要目的是<strong>保证组件复用时数据的独立性</strong>。</p>\n<ul>\n<li><strong>对象的问题</strong>：如果直接传对象，所有组件实例会共享同一个数据引用。修改其中一个实例的数据，会影响其他实例，导致状态污染。</li>\n<li><strong>函数的作用</strong>：函数每次返回一个全新的数据对象，确保每个实例维护自己的独立状态（类似工厂模式）。</li>\n</ul>\n"},{"title":"父子组件的生命周期执行顺序是什么？","answer":""},{"title":"Vue2与Vue3有些什么区别？","answer":"<ol>\n<li><strong>响应式系统</strong>\n<ul>\n<li><strong>Vue 2</strong>：基于 <code>Object.defineProperty</code>，无法监听对象新增属性或数组索引变化（需 <code>Vue.set</code>）。</li>\n<li><strong>Vue 3</strong>：改用 <code>Proxy</code>，支持动态属性/数组索引监听，性能更高，覆盖更全。</li>\n</ul>\n</li>\n<li><strong>API 设计</strong>\n<ul>\n<li><strong>Vue 2</strong>：<code>Options API</code>（按 <code>data</code>、<code>methods</code> 等选项组织代码），逻辑分散。</li>\n<li><strong>Vue 3</strong>：引入 <code>Composition API</code>（<code>setup</code> + <code>ref</code>/<code>reactive</code>），逻辑复用更灵活（类似 React Hooks）。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>\n<ul>\n<li><strong>编译优化</strong>：Vue 3 支持静态提升、Patch Flag 标记动态节点，虚拟 DOM Diff 效率更高。</li>\n<li><strong>Tree-Shaking</strong>：模块化架构，未使用代码不打包，体积更小（核心库约 10KB）。</li>\n</ul>\n</li>\n<li><strong>新特性</strong>\n<ul>\n<li><strong>Fragment</strong>：支持多根节点模板。</li>\n<li><strong>Teleport</strong>：跨 DOM 层级渲染组件（如全局弹窗）。</li>\n<li><strong>Suspense</strong>：异步组件加载状态管理。</li>\n</ul>\n</li>\n<li><strong>TypeScript 支持</strong>\n<ul>\n<li><strong>Vue 2</strong>：需通过装饰器或插件支持 TS，类型推断较弱。</li>\n<li><strong>Vue 3</strong>：源码用 TS 重写，提供完整类型定义。</li>\n</ul>\n</li>\n<li><strong>生命周期与 API 变更</strong>\n<ul>\n<li>钩子更名：如 <code>beforeDestroy</code> → <code>beforeUnmount</code>。</li>\n<li>移除过滤器（<code>filter</code>），推荐计算属性或方法替代。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"谈谈 Object.defineProperty 与 Proxy 的区别","answer":"<p>Object.defineProperty 和 Proxy 是 JavaScript 中用于对象操作的两种不同机制，它们在功能和使用场景上有显著差异。以下是两者的对比，以及 Vue 3 选择 Proxy 的原因：</p>\n<p><strong>1. 核心区别</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>特性</strong></th>\n<th style=\"text-align:left\"><strong>Object.defineProperty</strong></th>\n<th style=\"text-align:left\"><strong>Proxy</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>拦截能力</strong></td>\n<td style=\"text-align:left\">仅能拦截属性的 <code>get</code> 和 <code>set</code></td>\n<td style=\"text-align:left\">支持 13 种拦截操作（如 <code>has</code>, <code>deleteProperty</code>, <code>ownKeys</code> 等）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>操作范围</strong></td>\n<td style=\"text-align:left\">需针对对象的每个属性单独定义</td>\n<td style=\"text-align:left\">代理整个对象，自动处理所有属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数组处理</strong></td>\n<td style=\"text-align:left\">需重写数组方法（如 <code>push</code>, <code>pop</code>）</td>\n<td style=\"text-align:left\">直接监听索引变化和方法调用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>动态属性</strong></td>\n<td style=\"text-align:left\">新增属性需手动调用 <code>Vue.set</code></td>\n<td style=\"text-align:left\">自动捕获属性添加/删除</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>嵌套对象</strong></td>\n<td style=\"text-align:left\">需递归初始化所有属性</td>\n<td style=\"text-align:left\">按需代理（惰性初始化）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>兼容性</strong></td>\n<td style=\"text-align:left\">支持 IE9+</td>\n<td style=\"text-align:left\">不支持 IE，需现代浏览器</td>\n</tr>\n</tbody>\n</table>\n<p><strong>2. 实现响应式的差异</strong></p>\n<p><strong>Vue 2（Object.defineProperty）</strong></p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 对每个属性递归设置 getter/setter</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> defineReactive</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">obj</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  let</span><span style=\"color:#B07D48\"> value</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> obj</span><span style=\"color:#999999\">[</span><span style=\"color:#B07D48\">key</span><span style=\"color:#999999\">];</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">  Object</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">defineProperty</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">obj</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    get</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">      track</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">key</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 依赖收集</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">      return</span><span style=\"color:#B07D48\"> value</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#999999\">    },</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    set</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">newVal</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">      value</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> newVal</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">      trigger</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">key</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 触发更新</span></span>\n<span class=\"line\"><span style=\"color:#999999\">    }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  });</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li><strong>缺点</strong>：\n<ol>\n<li>初始化时需深度遍历对象，性能消耗大</li>\n<li>无法检测通过索引修改数组（<code>arr[0] = 1</code>）或修改数组长度</li>\n<li>新增属性需手动处理响应式<strong>Vue 3（Proxy）</strong></li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> proxy</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> new</span><span style=\"color:#59873A\"> Proxy</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">obj</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  get</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> receiver</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    track</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">key</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 依赖收集</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    return</span><span style=\"color:#B07D48\"> Reflect</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">get</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> receiver</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  },</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  set</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> value</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> receiver</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    Reflect</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">set</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> value</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> receiver</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    trigger</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">key</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 触发更新</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    return</span><span style=\"color:#1E754F\"> true</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  },</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  deleteProperty</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    trigger</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">key</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 支持删除操作</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    return</span><span style=\"color:#B07D48\"> Reflect</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">deleteProperty</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<ul>\n<li><strong>优势</strong>：\n<ol>\n<li>代理整个对象，无需初始化递归</li>\n<li>自动捕获动态属性变化</li>\n<li>直接支持数组索引操作</li>\n</ol>\n</li>\n</ul>\n<p><strong>3. Vue 3 使用 Proxy 的核心原因</strong></p>\n<p><strong>(1) 更全面的拦截能力</strong></p>\n<ul>\n<li>\n<p><strong>支持更多操作类型</strong>：如 <code>in</code> 操作符、<code>Object.keys()</code>、<code>delete</code> 等，覆盖所有可能的对象操作。</p>\n</li>\n<li>\n<p><strong>示例</strong>：直接监听属性删除：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> obj</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> a</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 1</span><span style=\"color:#999999\"> };</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> proxy</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> new</span><span style=\"color:#59873A\"> Proxy</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">obj</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  deleteProperty</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">log</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">`</span><span style=\"color:#B56959\">属性 </span><span style=\"color:#1E754F\">${</span><span style=\"color:#B56959\">key</span><span style=\"color:#1E754F\">}</span><span style=\"color:#B56959\"> 被删除</span><span style=\"color:#B5695977\">`</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    return</span><span style=\"color:#B07D48\"> Reflect</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">deleteProperty</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> key</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">delete</span><span style=\"color:#B07D48\"> proxy</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">a</span><span style=\"color:#999999\">;</span><span style=\"color:#A0ADA0\"> // 输出 \"属性 a 被删除\"</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>(2) 更高效的数组处理</strong></p>\n<ul>\n<li>\n<p><strong>直接监听数组索引变化</strong>：无需重写数组方法，天然支持以下操作：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> arr</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> [</span><span style=\"color:#2F798A\">1</span><span style=\"color:#999999\">,</span><span style=\"color:#2F798A\"> 2</span><span style=\"color:#999999\">];</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> proxyArr</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> reactive</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">arr</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">proxyArr</span><span style=\"color:#999999\">[</span><span style=\"color:#2F798A\">0</span><span style=\"color:#999999\">]</span><span style=\"color:#999999\"> =</span><span style=\"color:#2F798A\"> 3</span><span style=\"color:#999999\">;</span><span style=\"color:#A0ADA0\">       // 触发更新</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">proxyArr</span><span style=\"color:#999999\">.</span><span style=\"color:#998418\">length</span><span style=\"color:#999999\"> =</span><span style=\"color:#2F798A\"> 1</span><span style=\"color:#999999\">;</span><span style=\"color:#A0ADA0\">   // 触发更新**(3) 惰性初始化提升性能**</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>按需代理嵌套对象</strong>：仅在访问子属性时触发代理，减少初始化开销：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> data</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> nested</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> a</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 1</span><span style=\"color:#999999\"> }</span><span style=\"color:#999999\"> };</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> proxy</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> reactive</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">data</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 初始仅代理 data，不处理 nested</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">log</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">proxy</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">nested</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">a</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\">  // 访问时才对 nested 生成代理**(4) 更好的动态属性支持**</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>自动响应新增属性</strong>：无需手动调用 <code>Vue.set</code>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> obj</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> reactive</span><span style=\"color:#999999\">({});</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">obj</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">newKey</span><span style=\"color:#999999\"> =</span><span style=\"color:#2F798A\"> 123</span><span style=\"color:#999999\">;</span><span style=\"color:#A0ADA0\"> // 自动触发响应式更新</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n<p><strong>4. 性能对比</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>场景</strong></th>\n<th style=\"text-align:left\"><strong>Object.defineProperty</strong></th>\n<th style=\"text-align:left\"><strong>Proxy</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">初始化 1000 属性对象</td>\n<td style=\"text-align:left\">约 15ms（递归遍历）</td>\n<td style=\"text-align:left\">约 1ms（直接代理）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">动态添加 100 属性</td>\n<td style=\"text-align:left\">需手动触发响应式（性能差）</td>\n<td style=\"text-align:left\">自动处理（性能优）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">大型数组操作</td>\n<td style=\"text-align:left\">需重写方法（性能损耗）</td>\n<td style=\"text-align:left\">原生拦截（性能更优）</td>\n</tr>\n</tbody>\n</table>\n<p><strong>5. 兼容性与取舍</strong></p>\n<ul>\n<li><strong>Proxy 的兼容性限制</strong>：不支持 IE11 及以下浏览器，但 Vue 3 放弃对旧浏览器的支持，专注现代浏览器生态。</li>\n<li><strong>Polyfill 不可行</strong>：Proxy 无法被完全模拟，Vue 3 的响应式系统完全依赖 Proxy。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>Vue 3 选择 Proxy 的核心动机在于其<strong>更强大的拦截能力</strong>、<strong>更高效的初始化性能</strong>和<strong>更自然的动态属性支持</strong>，这些改进使得响应式系统更加灵活和高效，同时减少了开发者的心智负担。尽管 Proxy 在兼容性上存在限制，但现代前端工程化的趋势（如自动降级和浏览器淘汰策略）使其成为更合理的选择。</p>\n"},{"title":"Vue3 composition api相比于option api有哪些优势?","answer":"<ol>\n<li>为了更好的逻辑复用和代码组织</li>\n<li>更好的类型推导</li>\n</ol>\n<p>有了composition api，配合reactivity api，可以在组件内部进行更加细粒度的控制，使得组件中不同的功能高度聚合，提升了代码的可维护性。对于不同组件的相同功能，也能够更好的复用。相比于option api,composition api中没有了指向奇怪的this，所有的api变得更加函数式，这有利于和类型推断系统比如TS深度配合。</p>\n"},{"title":"Vue组件间通信方式都有哪些?","answer":"<ol>\n<li><strong>Props / $emit</strong>\n<ul>\n<li><strong>父子通信</strong>：父组件通过 <code>props</code> 传数据给子组件，子组件通过 <code>$emit</code> 触发事件通知父组件。</li>\n</ul>\n</li>\n<li><strong>自定义事件（Event Bus）</strong>\n<ul>\n<li><strong>跨组件通信</strong>：通过空的 Vue 实例（<code>const bus = new Vue()</code>）作为事件中心，用 <code>$on</code> 监听、<code>$emit</code> 触发（Vue 3 推荐使用第三方库如 <code>mitt</code>）。</li>\n</ul>\n</li>\n<li><strong>v-model / .sync（双向绑定）</strong>\n<ul>\n<li><strong>父子双向同步</strong>：Vue 2 用 <code>.sync</code>，Vue 3 支持多个 <code>v-model</code>，简化父子数据双向绑定。</li>\n</ul>\n</li>\n<li><strong>refs / $parent / $children</strong>\n<ul>\n<li><strong>直接访问组件实例</strong>：通过 <code>this.$refs.xxx</code> 获取子组件实例，直接调用其方法或修改数据（不推荐，破坏封装性）。</li>\n</ul>\n</li>\n<li><strong>provide / inject</strong>\n<ul>\n<li><strong>跨层级传递数据</strong>：祖先组件通过 <code>provide</code> 提供数据，后代组件通过 <code>inject</code> 注入（适用于深层嵌套组件）。</li>\n</ul>\n</li>\n<li><strong>Vuex / Pinia（状态管理库）</strong>\n<ul>\n<li><strong>全局状态共享</strong>：集中式存储管理数据，通过 <code>state</code>、<code>actions</code>、<code>mutations</code>（Vuex）或 <code>store</code>（Pinia）实现跨组件通信。</li>\n</ul>\n</li>\n<li><strong>LocalStorage / SessionStorage</strong>\n<ul>\n<li><strong>浏览器存储通信</strong>：通过本地存储共享数据，需手动监听 <code>storage</code> 事件实现响应式（非 Vue 原生方案，慎用）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结</strong>：</p>\n<ul>\n<li>父子组件优先用 <strong>Props + $emit</strong>；</li>\n<li>跨层级用 <strong>provide/inject</strong> 或 <strong>Vuex/Pinia</strong>；</li>\n<li>简单场景可用 <strong>Event Bus</strong>，复杂场景推荐状态管理库。</li>\n</ul>\n"},{"title":"谈谈什么是单向数据流？","answer":"<p>单向数据流指数据在应用中<strong>单向传递</strong>的设计模式，核心规则为：</p>\n<ol>\n<li><strong>自上而下流动</strong>：父组件通过 props 向子组件传递数据；</li>\n<li><strong>禁止逆向修改</strong>：子组件不能直接修改 props，子组件通过<strong>自定义事件</strong>（<code>$emit</code>）通知父组件修改数据。</li>\n</ol>\n"},{"title":"说说你对nexttick的理解?","answer":"<p>Vue 的 <code>nextTick</code> 用于在 <strong>下次 DOM 更新周期后执行回调</strong>，<strong>解决数据变化后 DOM 未及时更新的问题</strong>，确保代码逻辑在正确时机执行。核心作用与原理如下：</p>\n<p><strong>1. 核心作用</strong></p>\n<ul>\n<li><strong>确保操作基于最新 DOM</strong>：在数据变化后，若需立即访问更新后的 DOM（如获取元素尺寸、焦点等），需将逻辑放入 <code>nextTick</code> 回调。</li>\n<li><strong>解决异步更新导致的视图不一致</strong>：Vue 的响应式更新是异步的，连续修改数据时，<code>nextTick</code> 可保证逻辑在 DOM 渲染完成后执行。</li>\n</ul>\n<p><strong>2. 使用场景</strong></p>\n<ul>\n<li>\n<p><strong>数据变化后操作 DOM</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A65E2B\">this</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">showModal</span><span style=\"color:#999999\"> =</span><span style=\"color:#1E754F\"> true</span><span style=\"color:#999999\">;</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A65E2B\">this</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">$nextTick</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A65E2B\">  this</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">$refs</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">modal</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">focus</span><span style=\"color:#999999\">();</span><span style=\"color:#A0ADA0\"> // DOM 已渲染  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>生命周期钩子中的 DOM 操作</strong>：如 <code>created</code> 钩子中访问 DOM。</p>\n</li>\n</ul>\n<p><strong>3. 实现原理</strong></p>\n<ul>\n<li><strong>异步队列</strong>：Vue 将数据变更后的 DOM 更新任务推入队列，同一事件循环内的多次更新合并为一次。</li>\n<li><strong>优先级策略</strong>：\n<ul>\n<li>优先使用 <code>Promise.then</code>（微任务）。</li>\n<li>不支持则降级到 <code>MutationObserver</code> → <code>setImmediate</code> → <code>setTimeout</code>（宏任务）。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"说说你对vue的mixin的理解，有什么应用场景？","answer":"<p>Vue 的 <code>mixin</code> 是一种 <strong>逻辑复用机制</strong>，允许将组件的选项（如 <code>data</code>、<code>methods</code>、生命周期钩子）抽离为独立模块，供多个组件混入使用。</p>\n<p><strong>核心特点</strong></p>\n<ol>\n<li><strong>选项合并</strong>：\n<ul>\n<li><code>data</code>、<code>methods</code> 等同名属性以组件优先。</li>\n<li>生命周期钩子会合并成数组，混入的钩子先于组件自身执行。</li>\n</ul>\n</li>\n<li><strong>应用场景</strong>：\n<ul>\n<li><strong>复用公共逻辑</strong>：如日志埋点、权限校验、表单验证方法。</li>\n<li><strong>统一生命周期处理</strong>：如多个组件需要在 <code>created</code> 时初始化数据。</li>\n<li><strong>跨组件共享工具方法</strong>：如格式化时间、请求封装。</li>\n</ul>\n</li>\n</ol>\n<p><strong>局限性</strong></p>\n<ul>\n<li><strong>命名冲突</strong>：混入越多，属性和方法命名越易冲突。</li>\n<li><strong>数据来源不透明</strong>：混入逻辑分散，维护时难以追踪来源。</li>\n</ul>\n<p><strong>替代方案</strong></p>\n<ul>\n<li>Vue 3 的 <strong>Composition API</strong>（<code>setup</code> + 自定义 Hook）更灵活，规避了 mixin 的缺点。</li>\n</ul>\n<p><strong>总结</strong>：mixin 适合简单逻辑复用，但复杂场景推荐 Composition API。</p>\n"},{"title":"说说你对slot的理解？slot使用场景有哪些？","answer":"<p>Vue 的 <code>slot</code>（插槽）是 <strong>组件内容分发的核心机制</strong>，允许父组件向子组件传递模板片段，实现动态内容定制。以下是核心理解与使用场景：</p>\n<p><strong>一、核心理解</strong></p>\n<ol>\n<li><strong>基本插槽</strong>：\n<ul>\n<li>子组件内定义 <code>&lt;slot&gt;</code> 占位符，父组件传递的内容将替换该位置。</li>\n<li>默认内容：<code>&lt;slot&gt;默认内容&lt;/slot&gt;</code> 可设置后备值。</li>\n</ul>\n</li>\n<li><strong>具名插槽</strong>：\n<ul>\n<li>子组件定义多个 <code>&lt;slot name=&quot;xxx&quot;&gt;</code>，父组件通过 <code>&lt;template v-slot:xxx&gt;</code> 指定内容。</li>\n<li>简写：<code>v-slot:header</code> → <code>#header</code>（Vue 2.6+）。</li>\n</ul>\n</li>\n<li><strong>作用域插槽</strong>：\n<ul>\n<li>子组件通过 <code>&lt;slot :data=&quot;data&quot;&gt;</code> 向父组件传递数据。</li>\n<li>父组件通过 <code>&lt;template #default=&quot;scope&quot;&gt;</code> 接收并使用子组件数据。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、使用场景</strong></p>\n<ol>\n<li><strong>动态内容容器</strong>\n<ul>\n<li>如模态框（Modal）、卡片（Card）等组件，允许父组件自定义内部内容。</li>\n</ul>\n</li>\n<li><strong>布局组件</strong>\n<ul>\n<li>定义可复用的布局框架（如页头、页脚、侧边栏），通过具名插槽填充各区域。</li>\n</ul>\n</li>\n<li><strong>数据驱动型组件</strong>\n<ul>\n<li>表格（Table）、列表（List）等组件，通过作用域插槽暴露行数据，父组件自定义渲染逻辑。</li>\n</ul>\n</li>\n<li><strong>高阶组件（HOC）</strong>\n<ul>\n<li>封装通用逻辑（如加载状态、错误处理），通过插槽插入业务相关 UI。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Vue 的 key 值的作用是？","answer":"<ol>\n<li><strong>精准追踪节点身份</strong>\n<ul>\n<li>在列表渲染（<code>v-for</code>）或动态组件中，通过唯一 <code>key</code> 标识元素，帮助 Vue 区分新旧节点，避免<strong>就地复用</strong>导致的渲染错误（如表单元素状态错乱）。</li>\n</ul>\n</li>\n<li><strong>优化 Diff 性能</strong>\n<ul>\n<li><strong>有 <code>key</code></strong>：基于 <code>key</code> 建立映射关系，高效复用或移动节点，减少不必要的 DOM 销毁与重建。</li>\n<li><strong>无 <code>key</code></strong>：按顺序对比节点，可能导致大量 DOM 操作（如列表中间插入元素时后续节点全部重建）。</li>\n</ul>\n</li>\n<li><strong>强制更新组件/元素</strong>\n<ul>\n<li>改变 <code>key</code> 会触发组件销毁与重新渲染，常用于强制重置组件状态（如切换路由时刷新组件）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结</strong>：<code>key</code> 是 Vue 高效更新视图的关键，通过标识节点身份优化渲染性能，避免状态错乱。</p>\n"},{"title":"vue 的 key 在列表渲染中，使用 index 作为值有什么隐患？","answer":"<p>列表<strong>增删/排序</strong>时，<code>index</code> 会动态变化，Vue 可能<strong>错误复用 DOM 节点</strong>，导致表单项、组件状态与数据不匹配。</p>\n"},{"title":"怎么缓存当前的组件？缓存后怎么更新？说说你对keep-alive的理解是什么？","answer":"<p><strong>1. 如何缓存组件？</strong></p>\n<p>通过 <code>&lt;keep-alive&gt;</code> 包裹动态组件或路由组件，缓存其状态避免重复渲染：</p>\n<p><strong>2. 缓存后如何更新？</strong></p>\n<ul>\n<li><strong>生命周期钩子</strong>：\n被缓存的组件触发 <code>activated</code>（激活时）和 <code>deactivated</code>（离开时）钩子，而非 <code>created</code>/<code>mounted</code>。</li>\n<li><strong>强制更新策略</strong>：\n<ol>\n<li><strong>动态 <code>key</code></strong>：改变组件的唯一标识（如路由参数），触发重新渲染。</li>\n<li><strong><code>include/exclude</code> 控制</strong>：动态调整缓存组件范围。</li>\n</ol>\n</li>\n</ul>\n<p><strong>3. 对 <code>keep-alive</code> 的核心理解</strong></p>\n<ul>\n<li><strong>作用</strong>：\n<ul>\n<li>缓存组件实例，避免重复销毁与重建，<strong>提升性能</strong>。</li>\n<li>保留组件状态（如表单输入、滚动位置）。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong>：\n<ul>\n<li>频繁切换的 Tab 页、路由页面。</li>\n<li>需保留状态的复杂表单组件。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Vue中异步组件和动态组件的区别是什么？","answer":"<p>异步组件与动态组件的核心区别在于<strong>加载机制</strong>和<strong>使用场景</strong>：</p>\n<ol>\n<li>\n<p><strong>异步组件</strong>：</p>\n<ul>\n<li>\n<p><strong>用途</strong>：延迟加载组件代码，优化首屏性能（如路由懒加载）。</p>\n</li>\n<li>\n<p><strong>实现</strong>：通过 <code>defineAsyncComponent</code> 或返回 Promise 的工厂函数定义，按需加载资源。</p>\n</li>\n<li>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> AsyncComp</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> defineAsyncComponent</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#AB5959\"> import</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">./Component.vue</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">));</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>动态组件</strong>：</p>\n<ul>\n<li>\n<p><strong>用途</strong>：运行时动态切换同一挂载点的不同组件（如 Tab 切换）。</p>\n</li>\n<li>\n<p><strong>实现</strong>：通过 <code>&lt;component :is=&quot;currentComponent&quot;&gt;</code> 绑定组件名或组件对象。</p>\n</li>\n<li>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">component</span><span style=\"color:#999999\"> :</span><span style=\"color:#59873A\">is</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#B07D48\">isAdmin</span><span style=\"color:#AB5959\"> ?</span><span style=\"color:#B07D48\"> AdminPanel</span><span style=\"color:#AB5959\"> :</span><span style=\"color:#B07D48\"> UserPanel</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\"> /></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>关键区别</strong>：</p>\n<ul>\n<li>异步组件解决<strong>加载时机</strong>问题（性能优化），动态组件解决<strong>渲染目标</strong>问题（逻辑交互）。</li>\n<li>异步组件本质是<strong>代码分割</strong>，动态组件是<strong>条件渲染</strong>。</li>\n</ul>\n"},{"title":"Vue中组件和插件有什么区别？","answer":"<p>组件（Component）和插件（Plugin）在 Vue 中的核心区别如下：</p>\n<ol>\n<li><strong>功能定位</strong>：\n<ul>\n<li><strong>组件</strong>：封装可复用的 UI 单元（如按钮、弹窗），关注视图与交互逻辑。</li>\n<li><strong>插件</strong>：增强 Vue 的全局能力（如路由、状态管理、自定义指令），关注功能扩展。</li>\n</ul>\n</li>\n<li><strong>作用范围</strong>：\n<ul>\n<li><strong>组件</strong>：局部注册（单文件）或全局注册，需在模板中显式调用（如 <code>&lt;MyComponent&gt;</code>）。</li>\n<li><strong>插件</strong>：通过 <code>Vue.use()</code> 全局安装，自动注入功能（如 Vue Router 添加 <code>$router</code> 属性）。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>：\n<ul>\n<li><strong>组件</strong>：通过 <code>export default</code> 定义选项或 Composition API。</li>\n<li><strong>插件</strong>：需暴露 <code>install</code> 方法，接收 <code>Vue</code> 构造函数进行扩展。</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例</strong>：</p>\n<ul>\n<li>组件：封装一个 <code>&lt;DatePicker&gt;</code> 选择器；</li>\n<li>插件：开发一个全局错误监控工具（如 <code>Vue.use(ErrorTracker)</code>）。</li>\n</ul>\n"},{"title":"Vue常用的修饰符有哪些？有什么应用场景？","answer":"<p><strong>一、事件修饰符</strong></p>\n<ol>\n<li><strong><code>.stop</code></strong>\n<ul>\n<li><strong>作用</strong>：阻止事件冒泡。</li>\n<li><strong>场景</strong>：点击子元素时不触发父元素的点击事件。</li>\n</ul>\n</li>\n<li><strong><code>.prevent</code></strong>\n<ul>\n<li><strong>作用</strong>：阻止默认行为。</li>\n<li><strong>场景</strong>：表单提交时禁止页面刷新。</li>\n</ul>\n</li>\n<li><strong><code>.capture</code></strong>\n<ul>\n<li><strong>作用</strong>：事件捕获模式（由外到内触发）。</li>\n<li><strong>场景</strong>：父容器优先处理事件。</li>\n</ul>\n</li>\n<li><strong><code>.self</code></strong>\n<ul>\n<li><strong>作用</strong>：仅当事件从元素本身触发时执行（忽略子元素冒泡）。</li>\n<li><strong>场景</strong>：父容器仅响应自身点击，不被子元素冒泡影响。</li>\n</ul>\n</li>\n<li><strong><code>.once</code></strong>\n<ul>\n<li><strong>作用</strong>：事件只触发一次。</li>\n<li><strong>场景</strong>：按钮提交后禁用重复点击。</li>\n</ul>\n</li>\n<li><strong><code>.passive</code></strong>\n<ul>\n<li><strong>作用</strong>：优化滚动性能（不阻塞主线程）。</li>\n<li><strong>场景</strong>：移动端滚动监听（如 <code>@scroll.passive</code>）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>二、表单输入修饰符</strong></p>\n<ol>\n<li><strong><code>.lazy</code></strong>\n<ul>\n<li><strong>作用</strong>：输入框内容在 <code>change</code> 事件（非 <code>input</code>）时同步数据。</li>\n<li><strong>场景</strong>：减少实时同步频率（如搜索框输入完成后触发搜索）。</li>\n</ul>\n</li>\n<li><strong><code>.number</code></strong>\n<ul>\n<li><strong>作用</strong>：将输入值转为数值类型。</li>\n<li><strong>场景</strong>：表单输入数字（如年龄、价格）。</li>\n</ul>\n</li>\n<li><strong><code>.trim</code></strong>\n<ul>\n<li><strong>作用</strong>：去除输入内容首尾空格。</li>\n<li><strong>场景</strong>：用户名、邮箱输入自动清理空格。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、键盘事件修饰符</strong></p>\n<ol>\n<li><strong>按键修饰符</strong>（如 <code>.enter</code>、<code>.esc</code>、<code>.tab</code>）\n<ul>\n<li><strong>作用</strong>：监听特定按键事件。</li>\n<li><strong>场景</strong>：回车提交表单、ESC 关闭弹窗。</li>\n</ul>\n</li>\n<li><strong>系统修饰符</strong>（如 <code>.ctrl</code>、<code>.alt</code>、<code>.shift</code>）\n<ul>\n<li><strong>作用</strong>：组合键触发事件。</li>\n<li><strong>场景</strong>：快捷键操作（如 <code>Ctrl + S</code> 保存）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>四、鼠标修饰符</strong></p>\n<ul>\n<li><strong><code>.left</code>、<code>.right</code>、<code>.middle</code></strong>\n<ul>\n<li><strong>作用</strong>：监听特定鼠标按键事件。</li>\n<li><strong>场景</strong>：右键菜单、中键操作。</li>\n</ul>\n</li>\n</ul>\n<p><strong>五、其他修饰符</strong></p>\n<ol>\n<li><strong><code>.sync</code>（Vue 2）</strong>\n<ul>\n<li><strong>作用</strong>：实现父子组件双向绑定（Vue 3 已弃用，改用 <code>v-model</code> 参数）。</li>\n<li><strong>场景</strong>：简化父子组件数据同步。</li>\n</ul>\n</li>\n<li><strong><code>.native</code>（Vue 2）</strong>\n<ul>\n<li><strong>作用</strong>：监听组件根元素的原生事件（Vue 3 已移除，需通过 <code>emits</code> 声明）。</li>\n<li><strong>场景</strong>：在组件上直接绑定原生事件。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"你有写过自定义指令吗？自定义指令的应用场景有哪些？","answer":"<p><strong>实现过程：</strong></p>\n<ol>\n<li><strong>注册指令</strong>：\n<ul>\n<li><strong>全局注册</strong>：<code>Vue.directive('指令名', { 钩子函数 })</code>。</li>\n<li><strong>局部注册</strong>：在组件选项中定义 <code>directives: { 指令名: { 钩子函数 } }</code>。</li>\n</ul>\n</li>\n<li><strong>定义钩子函数</strong>：\n<ul>\n<li><strong><code>bind</code></strong>：指令首次绑定到元素时调用（初始化设置）。</li>\n<li><strong><code>inserted</code></strong>：元素插入父节点时调用（可访问 DOM）。</li>\n<li><strong><code>update</code></strong>：组件更新时调用（值变化但子元素未更新）。</li>\n<li><strong><code>componentUpdated</code></strong>：组件及子元素更新后调用。</li>\n<li><strong><code>unbind</code></strong>：指令与元素解绑时调用（清理副作用）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>应用场景：</strong></p>\n<ol>\n<li>\n<p><strong>DOM 操作增强</strong></p>\n<ul>\n<li><strong>自动聚焦</strong>：表单输入框初始化时自动聚焦。</li>\n<li><strong>图片懒加载</strong>：当图片进入可视区域时加载资源（结合 <code>IntersectionObserver</code>）。</li>\n</ul>\n</li>\n<li>\n<p><strong>交互优化</strong></p>\n<ul>\n<li><strong>防抖/节流</strong>：控制事件触发频率（如 <code>v-debounce</code> 优化搜索框输入）。</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#B07D48\">Vue</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">directive</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">debounce</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  inserted</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">el</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> binding</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">    let</span><span style=\"color:#B07D48\"> timer</span><span style=\"color:#999999\">;</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    el</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">addEventListener</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">input</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">      clearTimeout</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">timer</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">      timer</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> setTimeout</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#B07D48\"> binding</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">value</span><span style=\"color:#999999\">(),</span><span style=\"color:#2F798A\"> 500</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">    });</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>权限控制</strong></p>\n<ul>\n<li><strong>按钮权限</strong>：根据用户角色隐藏/禁用按钮。</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#B07D48\">Vue</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">directive</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">permission</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  inserted</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">el</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> binding</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    if</span><span style=\"color:#999999\"> (</span><span style=\"color:#AB5959\">!</span><span style=\"color:#59873A\">checkPermission</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">binding</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">value</span><span style=\"color:#999999\">))</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">      el</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">parentNode</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">removeChild</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">el</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">    }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 使用  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#B07D48\"> v-permission</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">'admin'</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">仅管理员可见</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>样式/动画控制</strong></p>\n<ul>\n<li><strong>高亮元素</strong>：特定条件下动态添加样式（如输入验证错误）。</li>\n<li><strong>拖拽指令</strong>：封装拖拽逻辑，复用至可拖拽组件。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Vue3 中 Teleport 组件的作用是什么？","answer":"<p>Vue Teleport 用于将组件模板内的内容<strong>渲染到 DOM 中的指定位置</strong>(如body)，解决父组件样式或结构限制（如 <code>overflow:hidden</code>、层级问题）。</p>\n"},{"title":"解释 Vue3 中 defineExpose 的作用","answer":"<ul>\n<li>默认情况下，<code>&lt;script setup&gt;</code> 的组件是<strong>封闭的</strong>，父组件无法直接访问子组件的内部状态或方法,<code>defineExpose</code> 可<strong>显式暴露子组件的属性或方法</strong>，允许父组件通过 <code>ref</code> 访问这些内容</li>\n</ul>\n"},{"title":"Vuex是什么？有哪几种属性？","answer":"<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，包含5个属性，分别是：</p>\n<ul>\n<li><strong>State</strong>：存储响应式数据；</li>\n<li><strong>Getters</strong>：计算属性（类似 <code>computed</code>）；</li>\n<li><strong>Mutations</strong>：<strong>同步</strong>修改 <code>state</code>（通过 <code>commit</code> 触发）；</li>\n<li><strong>Actions</strong>：<strong>异步</strong>操作（通过 <code>dispatch</code> 触发，内部可调用 <code>commit</code>）；</li>\n<li><strong>Modules</strong>：模块化拆分复杂 Store。</li>\n</ul>\n"},{"title":" Vuex中Action 和 Mutation 的区别？","answer":"<ul>\n<li><strong>Mutation</strong>：同步修改 <code>state</code>，通过 <code>commit</code> 调用；</li>\n<li><strong>Action</strong>：处理异步（如接口请求），通过 <code>dispatch</code> 调用，内部可提交多个 Mutation。</li>\n</ul>\n"},{"title":"页面刷新Vuex数据刷新丢失怎么办？","answer":"<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 页面加载时读取 localStorage  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">if</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">localStorage</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">getItem</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">store</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">))</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">  store</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">replaceState</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">JSON</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">parse</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">localStorage</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">getItem</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">store</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)));</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 监听 Vuex 变化，保存到 localStorage  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">store</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">subscribe</span><span style=\"color:#999999\">((</span><span style=\"color:#B07D48\">mutation</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> state</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">  localStorage</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">setItem</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">store</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> JSON</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">stringify</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">state</span><span style=\"color:#999999\">));</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n"},{"title":"Pinia 和 Vuex 的核心区别及优势？","answer":"<p><strong>一、核心区别</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>特性</strong></th>\n<th style=\"text-align:left\"><strong>Pinia</strong></th>\n<th style=\"text-align:left\"><strong>Vuex</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>API 设计</strong></td>\n<td style=\"text-align:left\">基于 Composition API，简化概念（无 mutations），更贴近 Vue 3 的语法</td>\n<td style=\"text-align:left\">基于 Flux 架构，需定义 <code>state</code>、<code>mutations</code>、<code>actions</code>、<code>getters</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>模块化</strong></td>\n<td style=\"text-align:left\">扁平化多 Store，每个 Store 独立定义，无需嵌套模块</td>\n<td style=\"text-align:left\">通过 <code>modules</code> 组织嵌套模块，需命名空间管理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>状态修改方式</strong></td>\n<td style=\"text-align:left\">在 <code>actions</code> 中直接修改 <code>state</code>（支持同步/异步）</td>\n<td style=\"text-align:left\">必须通过 <code>mutations</code> 同步修改 <code>state</code>，<code>actions</code> 处理异步后提交 <code>commit</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>TypeScript 支持</strong></td>\n<td style=\"text-align:left\">原生完全支持，类型推断更友好</td>\n<td style=\"text-align:left\">Vuex 4 对 TS 支持较弱，需额外配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>体积</strong></td>\n<td style=\"text-align:left\">约 1KB，轻量级</td>\n<td style=\"text-align:left\">较大（约 10KB）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>调试工具</strong></td>\n<td style=\"text-align:left\">不支持时间旅行（Time Travel）</td>\n<td style=\"text-align:left\">支持时间旅行和状态快照调试</td>\n</tr>\n</tbody>\n</table>\n<p><strong>二、Pinia 的优势</strong></p>\n<ol>\n<li><strong>简洁直观的 API</strong>\n<ul>\n<li>移除 <code>mutations</code>，状态修改直接在 <code>actions</code> 中完成，减少代码冗余。</li>\n<li>与 Vue 3 的组合式 API 风格无缝集成，例如通过 <code>defineStore</code> 定义 Store，代码更易读。</li>\n</ul>\n</li>\n<li><strong>灵活的模块化</strong>\n<ul>\n<li>支持多 Store 独立管理，每个 Store 通过 <code>defineStore</code> 生成，无需手动注册模块或处理命名空间冲突。</li>\n</ul>\n</li>\n<li><strong>TypeScript 友好</strong>\n<ul>\n<li>源码完全由 TS 编写，提供完整的类型推断，减少类型声明的工作量。</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>\n<ul>\n<li>基于 Vue 3 的响应式系统（Proxy），性能更高效。</li>\n<li>轻量级体积（约 1KB），减少打包负担。</li>\n</ul>\n</li>\n<li><strong>开发体验提升</strong>\n<ul>\n<li>直接通过函数调用触发 <code>actions</code>（如 <code>store.increment()</code>），无需 <code>dispatch</code> 或 <code>commit</code>。</li>\n</ul>\n</li>\n</ol>\n<p><strong>三、Vuex 的优势</strong></p>\n<ol>\n<li><strong>成熟的调试功能</strong>\n<ul>\n<li>支持时间旅行和状态快照，适合复杂场景的调试需求。</li>\n</ul>\n</li>\n<li><strong>严格的架构规范</strong>\n<ul>\n<li>通过 <code>mutations</code> 强制同步修改状态，保证状态变更的可追踪性和可预测性，适合大型项目维护。</li>\n</ul>\n</li>\n<li><strong>丰富的生态系统</strong>\n<ul>\n<li>社区资源丰富，插件生态完善（如持久化存储、日志插件）。</li>\n</ul>\n</li>\n<li><strong>集中式状态管理</strong>\n<ul>\n<li>单一 Store 结构适合需要全局统一管理的复杂应用场景。</li>\n</ul>\n</li>\n</ol>\n<p><strong>四、使用场景建议</strong></p>\n<ul>\n<li><strong>选择 Pinia</strong>：\n<ul>\n<li>Vue 3 项目，尤其是中小型应用或需要快速开发的场景。</li>\n<li>需要灵活的状态管理、TypeScript 深度集成或代码简洁性优先的项目。</li>\n</ul>\n</li>\n<li><strong>选择 Vuex</strong>：\n<ul>\n<li>Vue 2 项目或需要严格状态管理流程的大型应用。</li>\n<li>依赖时间旅行调试功能或已有 Vuex 生态集成的遗留项目。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"vue-router 中\\$route和\\$router的区别？","answer":"<ol>\n<li><strong><code>$router</code></strong>：\n<ul>\n<li>是 <strong>路由实例</strong>（如 <code>VueRouter</code> 的实例），用来<strong>控制路由跳转</strong>。</li>\n<li><strong>核心方法</strong>：<code>push()</code>（跳转）、<code>replace()</code>（替换当前路由）、<code>go()</code>（前进/后退）。</li>\n</ul>\n</li>\n<li><strong><code>$route</code></strong>：\n<ul>\n<li>是 <strong>当前路由信息对象</strong>，用来<strong>获取当前页面的路由参数、路径等</strong>。</li>\n<li><strong>核心属性</strong>：<code>path</code>（路径）、<code>params</code>（动态参数）、<code>query</code>（URL 参数）、<code>meta</code>（路由元信息）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"说说vue-router两种路由模式","answer":"<ol>\n<li><strong>Hash模式</strong>\n<ul>\n<li><strong>URL格式</strong>：带有 <code>#</code>，如 <code>http://example.com/#/home</code>。</li>\n<li><strong>原理</strong>：通过监听 <code>hashchange</code> 事件实现路由切换，变化不会触发服务器请求。</li>\n<li><strong>优点</strong>：兼容性好（支持旧浏览器），无需服务器配置。</li>\n<li><strong>缺点</strong>：URL 不够美观，对 SEO 不友好（# 后内容不参与服务端路由）。</li>\n</ul>\n</li>\n<li><strong>History模式</strong>\n<ul>\n<li><strong>URL格式</strong>：无 <code>#</code>，如 <code>http://example.com/home</code>。</li>\n<li><strong>原理</strong>：基于 HTML5 History API（<code>pushState</code>/<code>replaceState</code>）管理路由。</li>\n<li><strong>优点</strong>：URL 简洁，SEO 友好。</li>\n<li><strong>缺点</strong>：需服务器支持（所有路径返回入口文件，如 <code>index.html</code>），否则直接访问子路由会 404。</li>\n</ul>\n</li>\n</ol>\n<p><strong>选择建议</strong>：</p>\n<ul>\n<li>若无需考虑 SEO 或需兼容旧浏览器，可用 Hash 模式。</li>\n<li>若追求美观和 SEO，且能配置服务器（如 Nginx/Apache 重定向），则选 History 模式。</li>\n</ul>\n"},{"title":"vue-router有哪几种导航钩子?","answer":"<ol>\n<li><strong>全局导航钩子</strong></li>\n</ol>\n<p><strong>作用范围</strong>：所有路由切换都会触发。</p>\n<ul>\n<li><strong><code>beforeEach</code></strong>：路由跳转前触发（常用作<strong>登录验证</strong>、权限拦截）。</li>\n<li><strong><code>beforeResolve</code></strong>：导航被确认前触发（适合处理异步数据）。</li>\n<li><strong><code>afterEach</code></strong>：导航完成后触发（无 <code>next</code> 参数，常用于日志统计、页面标题设置）。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>路由独享钩子</strong></li>\n</ol>\n<p><strong>作用范围</strong>：仅在特定路由配置中生效。</p>\n<ul>\n<li><strong><code>beforeEnter</code></strong>：进入该路由前触发（类似全局 <code>beforeEach</code>，但只针对当前路由）。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>组件内钩子</strong></li>\n</ol>\n<p><strong>作用范围</strong>：在组件内定义，只影响当前组件相关的路由。</p>\n<ul>\n<li><strong><code>beforeRouteEnter</code></strong>：进入组件前触发（此时组件实例未创建，无法访问 <code>this</code>）。</li>\n<li><strong><code>beforeRouteUpdate</code></strong>：当前路由改变但组件被复用时触发（如动态参数 <code>/user/:id</code> 变化）。</li>\n<li><strong><code>beforeRouteLeave</code></strong>：离开组件前触发（常用于<strong>阻止未保存数据离开</strong>）。</li>\n</ul>\n"},{"title":"vue-router 如何实现路由拦截？","answer":"<p>Vue Router 通过<strong>导航守卫</strong>实现路由拦截，常用方式：</p>\n<ol>\n<li>\n<p><strong>全局前置守卫</strong>（<code>router.beforeEach</code>）：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#B07D48\">router</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">beforeEach</span><span style=\"color:#999999\">((</span><span style=\"color:#B07D48\">to</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> from</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> next</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  if</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">to</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">meta</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">requiresAuth</span><span style=\"color:#AB5959\"> &#x26;&#x26;</span><span style=\"color:#AB5959\"> !</span><span style=\"color:#B07D48\">isAuthenticated</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    next</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">/login</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 拦截未登录用户  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#1E754F\"> else</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    next</span><span style=\"color:#999999\">();</span><span style=\"color:#A0ADA0\"> // 放行  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>路由独享守卫</strong>（<code>beforeEnter</code>）：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> routes</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> [</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#998418\">    path</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">/admin</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#998418\">    component</span><span style=\"color:#999999\">:</span><span style=\"color:#B07D48\"> AdminPage</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    beforeEnter</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">to</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> from</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> next</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">      checkAdminPermission</span><span style=\"color:#999999\">()</span><span style=\"color:#AB5959\"> ?</span><span style=\"color:#59873A\"> next</span><span style=\"color:#999999\">()</span><span style=\"color:#AB5959\"> :</span><span style=\"color:#59873A\"> next</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">/403</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">    }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">];</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>组件内守卫</strong>（如 <code>beforeRouteEnter</code>）：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#1E754F\">export</span><span style=\"color:#1E754F\"> default</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  beforeRouteEnter</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">to</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> from</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> next</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">    // 无法访问 this，需通过回调  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    next</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">vm</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">      vm</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">checkData</span><span style=\"color:#999999\">();</span><span style=\"color:#A0ADA0\"> // 进入组件后执行  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">    });</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  },</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  beforeRouteLeave</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">to</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> from</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> next</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">    // 离开前确认  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    confirm</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">确认离开？</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span><span style=\"color:#AB5959\"> ?</span><span style=\"color:#59873A\"> next</span><span style=\"color:#999999\">()</span><span style=\"color:#AB5959\"> :</span><span style=\"color:#59873A\"> next</span><span style=\"color:#999999\">(</span><span style=\"color:#1E754F\">false</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ol>\n<p><strong>核心要点</strong>：</p>\n<ul>\n<li>通过 <code>next()</code> 控制流程，未调用则阻塞导航；</li>\n<li>结合路由元信息（<code>meta</code>）传递权限等参数；</li>\n<li>异步操作需返回 Promise 或调用 <code>next</code>。</li>\n</ul>\n"},{"title":"vue-router 实现路由懒加载","answer":"<p><strong>步骤 1：使用动态导入语法定义路由组件</strong></p>\n<p>将路由配置中的静态导入 (<code>import Component from './Component.vue'</code>) 改为动态导入 (<code>() =&gt; import('./Component.vue')</code>)。</p>\n<p><strong>步骤 2：使用 Webpack 魔法注释（可选）</strong></p>\n<p>通过注释 <code>/* webpackChunkName: &quot;chunk-name&quot; */</code> 指定生成的代码块名称，便于调试和优化。</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">const</span><span style=\"color:#B07D48\"> routes</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> [</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  {</span><span style=\"color:#998418\"> path</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">/user</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#59873A\"> component</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#59873A\"> import</span><span style=\"color:#999999\">(</span><span style=\"color:#A0ADA0\">/* webpackChunkName: \"user\" */</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">./views/User.vue</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> },</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  {</span><span style=\"color:#998418\"> path</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">/admin</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#59873A\"> component</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#59873A\"> import</span><span style=\"color:#999999\">(</span><span style=\"color:#A0ADA0\">/* webpackChunkName: \"admin\" */</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">./views/Admin.vue</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">];</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n"},{"title":"vue-router 有哪些传参方法？","answer":"<p>Vue Router 传参方式主要有三种：</p>\n<ol>\n<li>\n<p><strong>动态路由参数（Params）</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 路由配置  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">{</span><span style=\"color:#59873A\"> path</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">/user/:id</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#59873A\"> component</span><span style=\"color:#999999\">:</span><span style=\"color:#B07D48\"> User</span><span style=\"color:#999999\"> }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 跳转传参  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">router</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">push</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">/user/123</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">)</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 组件内获取  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">$route</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">params</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">id</span><span style=\"color:#A0ADA0\"> // \"123\"  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>查询参数（Query）</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 跳转传参  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">router</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">push</span><span style=\"color:#999999\">({</span><span style=\"color:#998418\"> path</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">/user</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> query</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> name</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">John</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\"> }</span><span style=\"color:#999999\"> })</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// URL 效果：/user?name=John  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 组件内获取  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">$route</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">query</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">name</span><span style=\"color:#A0ADA0\"> // \"John\"  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>Props 解耦传参</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 路由配置  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">{</span><span style=\"color:#59873A\"> path</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">/user/:id</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#59873A\"> component</span><span style=\"color:#999999\">:</span><span style=\"color:#B07D48\"> User</span><span style=\"color:#999999\">,</span><span style=\"color:#59873A\"> props</span><span style=\"color:#999999\">:</span><span style=\"color:#1E754F\"> true</span><span style=\"color:#999999\"> }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 组件接收  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">export</span><span style=\"color:#1E754F\"> default</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#998418\">  props</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">id</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">]</span><span style=\"color:#A0ADA0\"> // 直接通过 props 使用  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ol>\n<p><strong>其他方式</strong>：</p>\n<ul>\n<li><strong>命名路由 + Params</strong>（需 <code>name</code> 配合，<code>path</code> 跳转时 Params 失效）；</li>\n<li><strong>路由元信息（Meta）</strong>：通过 <code>$route.meta</code> 传递静态数据。</li>\n</ul>\n<p><strong>区别</strong>：</p>\n<ul>\n<li>Params 需提前声明路径占位符，Query 无需声明；</li>\n<li>Props 方式解耦组件与路由，提升复用性。</li>\n</ul>\n"},{"title":"vue-router 如何实现嵌套路由？","answer":"<p>Vue Router 通过路由配置中的 <code>children</code> 属性然后再父组件模板中放置**<code>&lt;router-view&gt;</code>**来实现嵌套路由</p>\n"},{"title":"Vue中的过滤器了解吗？过滤器的应用场景有哪些？","answer":"<p><strong>一、过滤器核心概念</strong></p>\n<ol>\n<li>\n<p><strong>定义</strong>：86</p>\n<ul>\n<li>过滤器（Filter）用于 <strong>格式化文本数据</strong>，在模板中通过 <code>|</code> 管道符调用，支持链式处理和多参数传递。</li>\n</ul>\n</li>\n<li>\n<p><strong>注册方式</strong>：</p>\n<ul>\n<li><strong>全局注册</strong>：<code>Vue.filter('filterName', function(value, ...args) { ... })</code></li>\n<li><strong>局部注册</strong>：在组件选项中定义 <code>filters: { filterName(value) { ... } }</code></li>\n</ul>\n</li>\n<li>\n<p><strong>基本用法</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#AB5959\">!--</span><span style=\"color:#B07D48\"> 单参数</span><span style=\"color:#AB5959\"> --</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">>{{</span><span style=\"color:#393A34\"> message | </span><span style=\"color:#B07D48\">capitalize</span><span style=\"color:#999999\"> }}&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#AB5959\">!--</span><span style=\"color:#B07D48\"> 多参数</span><span style=\"color:#AB5959\"> --</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">>{{</span><span style=\"color:#393A34\"> price | </span><span style=\"color:#59873A\">currency</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">￥</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\"> 2</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> }}&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ol>\n<p><strong>二、应用场景</strong></p>\n<ol>\n<li><strong>文本格式化</strong>\n<ul>\n<li><strong>日期格式化</strong>：时间戳转 <code>YYYY-MM-DD</code> 格式。</li>\n<li><strong>货币格式化</strong>：数字转带符号的金额（如 <code>1000 → ¥1,000.00</code>）。</li>\n<li><strong>大小写转换</strong>：如全大写 <code>text → TEXT</code>。</li>\n</ul>\n</li>\n<li><strong>数据展示优化</strong>\n<ul>\n<li><strong>文本截断</strong>：长文本显示为 <code>...</code>（如 <code>&quot;这是一段很长的文本&quot; → &quot;这是一段...&quot;</code>）。</li>\n<li><strong>敏感信息脱敏</strong>：手机号显示为 <code>138****5678</code>。</li>\n</ul>\n</li>\n<li><strong>状态映射</strong>\n<ul>\n<li><strong>枚举值转文本</strong>：如 <code>status: 1 → &quot;已支付&quot;</code>。</li>\n<li><strong>布尔值转语义</strong>：如 <code>isActive: true → &quot;启用&quot;</code>。</li>\n</ul>\n</li>\n</ol>\n<p><strong>注意事项</strong></p>\n<p>Vue 3 移除过滤器，推荐使用 <strong>计算属性</strong> 或 <strong>方法</strong> 替代。</p>\n"},{"title":"了解过vue中的diff算法吗？说说看","answer":"<p>Vue的diff算法用于高效更新虚拟DOM，减少真实DOM操作，提升性能。其核心思路如下：</p>\n<p><strong>1. 同级比较，不跨层级</strong></p>\n<ul>\n<li><strong>只对比同一层节点</strong>，若节点类型不同（如<code>div</code>变<code>p</code>），直接替换整个节点及子节点，不再深入比较。</li>\n</ul>\n<p><strong>2. 双端对比策略（处理子节点列表）</strong></p>\n<ul>\n<li><strong>四指针法</strong>：新旧子节点数组各设两个指针（旧头、旧尾、新头、新尾）。</li>\n<li><strong>步骤</strong>：\n<ol>\n<li><strong>头头对比</strong>：若相同，节点复用，指针后移。</li>\n<li><strong>尾尾对比</strong>：若相同，节点复用，指针前移。</li>\n<li><strong>旧头 vs 新尾</strong>：若相同，移动旧头节点到末尾，指针后移（旧头）、前移（新尾）。</li>\n<li><strong>旧尾 vs 新头</strong>：若相同，移动旧尾节点到头部，指针前移（旧尾）、后移（新头）。</li>\n<li><strong>均不匹配</strong>：通过<code>key</code>查找可复用节点，若找到则移动，否则新建节点。</li>\n</ol>\n</li>\n<li><strong>示例</strong>：\n旧列表<code>[A, B, C, D]</code> → 新列表<code>[C, B, A, E]</code>\n<ul>\n<li>通过双端对比，快速定位移动节点，减少DOM操作。</li>\n</ul>\n</li>\n</ul>\n<p><strong>3. Key的核心作用</strong></p>\n<ul>\n<li><strong>唯一标识节点</strong>：帮助Vue精准识别节点是否可复用，避免顺序错误。</li>\n<li><strong>无Key的隐患</strong>：列表变动时（如插入元素），可能导致错误复用（如输入框内容错位）。</li>\n</ul>\n<p><strong>4. 就地复用原则</strong></p>\n<ul>\n<li><strong>相同节点复用DOM</strong>：若新旧节点相同（标签名和key一致），仅更新属性和子节点，避免重建。</li>\n</ul>\n<p><strong>Vue3的优化</strong></p>\n<ul>\n<li><strong>静态节点提升</strong>：将不变节点提取为常量，跳过Diff。</li>\n<li><strong>Block Tree</strong>：将动态节点按结构分组，减少遍历范围。</li>\n<li><strong>Patch Flag</strong>：标记动态属性（如<code>class</code>或<code>text</code>），仅对比变化部分。</li>\n</ul>\n"},{"title":"Vue 模板是如何被编译成渲染函数的？AST 的作用是什么？","answer":"<p>Vue 模板的编译流程分为三步：</p>\n<ol>\n<li><strong>解析模板生成 AST（抽象语法树）</strong>：\n<ul>\n<li>将 HTML 模板解析为树状结构的 AST，每个节点描述元素、指令、属性等信息（如 <code>v-if</code>、<code>{{}}</code>）。</li>\n</ul>\n</li>\n<li><strong>优化 AST</strong>：\n<ul>\n<li><strong>静态标记</strong>：标记静态节点（无动态绑定），后续更新跳过其 Diff 比对，提升性能。</li>\n</ul>\n</li>\n<li><strong>生成渲染函数</strong>：\n<ul>\n<li>遍历 AST，递归生成 <code>_createElement</code> 等函数的嵌套调用，最终输出可执行 <code>render</code> 函数，用于创建虚拟 DOM。</li>\n</ul>\n</li>\n</ol>\n<p><strong>AST 的作用</strong>：</p>\n<ul>\n<li>作为<strong>中间表示层</strong>，将模板结构化，便于优化（如静态标记）和代码生成；</li>\n<li>解耦解析逻辑与生成逻辑，提高编译器的扩展性和维护性。</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">&#x3C;!-- 模板 --></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#1E754F\"> v-if</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#B07D48\">show</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">{{ msg }}</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p>转换为 AST 后：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">{</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  type</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 1</span><span style=\"color:#999999\">,</span><span style=\"color:#A0ADA0\"> // 元素节点  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  tag</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">div</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  attrs</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [{</span><span style=\"color:#998418\"> name</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">v-if</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> value</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">show</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\"> }],</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  children</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [{</span><span style=\"color:#998418\"> type</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 2</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> expression</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">_s(msg)</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> text</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">{{ msg }}</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\"> }]</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p>最终生成渲染函数：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> render</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">show</span><span style=\"color:#999999\">)</span><span style=\"color:#AB5959\"> ?</span><span style=\"color:#59873A\"> _c</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">div</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> [</span><span style=\"color:#59873A\">_v</span><span style=\"color:#999999\">(</span><span style=\"color:#59873A\">_s</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">msg</span><span style=\"color:#999999\">))])</span><span style=\"color:#AB5959\"> :</span><span style=\"color:#59873A\"> _e</span><span style=\"color:#999999\">()</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n"},{"title":"说下你的Vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？","answer":"<p><strong>一、基础目录结构（中小型项目）</strong></p>\n<pre><code><div class=\"language- \"><span class=\"lang\"></span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span>src/</span></span>\n<span class=\"line\"><span>├── assets/            # 静态资源（图片、字体、样式）</span></span>\n<span class=\"line\"><span>├── components/       # 公共组件（全局复用）</span></span>\n<span class=\"line\"><span>├── views/            # 页面级组件（路由对应页面）</span></span>\n<span class=\"line\"><span>├── router/           # 路由配置（模块化拆分）</span></span>\n<span class=\"line\"><span>├── store/            # 状态管理（Vuex/Pinia，按模块划分）</span></span>\n<span class=\"line\"><span>├── api/              # 接口层（按业务模块拆分接口）</span></span>\n<span class=\"line\"><span>├── utils/            # 工具函数（请求封装、日期处理等）</span></span>\n<span class=\"line\"><span>├── plugins/          # 插件（第三方库集成）</span></span>\n<span class=\"line\"><span>└── App.vue           # 根组件</span></span>\n<span class=\"line\"><span></span></span></code></pre></div></code></pre>\n<p><strong>二、大型项目优化结构</strong></p>\n<p><strong>1. 模块化拆分（按业务功能）</strong></p>\n<pre><code><div class=\"language- \"><span class=\"lang\"></span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span>src/</span></span>\n<span class=\"line\"><span>├── modules/          # 业务模块</span></span>\n<span class=\"line\"><span>│   ├── user/        # 用户模块</span></span>\n<span class=\"line\"><span>│   │   ├── api/     # 用户相关接口</span></span>\n<span class=\"line\"><span>│   │   ├── store/   # 用户状态管理</span></span>\n<span class=\"line\"><span>│   │   ├── components/ # 模块内复用组件</span></span>\n<span class=\"line\"><span>│   │   └── views/   # 用户相关页面</span></span>\n<span class=\"line\"><span>│   ├── product/     # 商品模块（同上）</span></span>\n<span class=\"line\"><span>│   └── order/       # 订单模块</span></span>\n<span class=\"line\"><span></span></span></code></pre></div></code></pre>\n<p><strong>2. 组件分层设计</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>层级</strong></th>\n<th style=\"text-align:left\"><strong>描述</strong></th>\n<th style=\"text-align:left\"><strong>示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础组件</strong></td>\n<td style=\"text-align:left\">与业务无关的原子组件，全局注册</td>\n<td style=\"text-align:left\"><code>Button</code>、<code>Input</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>业务组件</strong></td>\n<td style=\"text-align:left\">复用性高的业务模块组件，按模块存放</td>\n<td style=\"text-align:left\"><code>UserCard</code>、<code>ProductList</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>页面组件</strong></td>\n<td style=\"text-align:left\">路由对应的顶层页面，组合业务组件</td>\n<td style=\"text-align:left\"><code>UserProfile.vue</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>高阶组件</strong></td>\n<td style=\"text-align:left\">逻辑复用组件（如HOC、自定义指令）</td>\n<td style=\"text-align:left\"><code>withLoading</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>3. 其他关键优化</strong></p>\n<ul>\n<li><strong>路由分层</strong>：动态导入页面组件（懒加载），按模块拆分路由配置。</li>\n<li><strong>状态管理</strong>：Pinia/Vuex 按模块拆分，避免全局Store臃肿。</li>\n<li><strong>静态资源</strong>：图片按模块分类（如 <code>assets/images/user/</code>），样式按模块拆分（SCSS混入）。</li>\n<li><strong>代码规范</strong>：ESLint + Prettier 统一风格，Git提交规范（如Commitizen）。</li>\n</ul>\n<p><strong>三、组件划分原则</strong></p>\n<ol>\n<li><strong>单一职责</strong>：每个组件只关注一个功能（如 <code>SearchBar</code> 仅处理搜索逻辑）。</li>\n<li><strong>合理拆解</strong>：避免“上帝组件”，通过组合拆分（如列表页拆为 <code>Filter</code> + <code>Table</code> + <code>Pagination</code>）。</li>\n<li><strong>复用性评估</strong>：\n<ul>\n<li><strong>高频复用</strong> → 提升为全局组件（如 <code>BaseDialog</code>）。</li>\n<li><strong>低频复用</strong> → 保留在模块内（如 <code>OrderStatusTag</code>）。</li>\n</ul>\n</li>\n<li><strong>命名规范</strong>：\n<ul>\n<li>基础组件加前缀（如 <code>BaseButton</code>）。</li>\n<li>业务组件体现功能（如 <code>UserAvatarUploader</code>）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？","answer":"<p><strong>1. 获取并存储权限数据</strong></p>\n<ul>\n<li><strong>用户登录后</strong>，后端返回权限标识列表（如 <code>['add_user', 'edit_user']</code>）。</li>\n<li><strong>存储权限</strong>：将权限列表存入全局状态管理（如 Vuex 或 Pinia），确保响应式更新。</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 示例：Vuex Store</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">state</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  permissions</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> []</span></span>\n<span class=\"line\"><span style=\"color:#999999\">},</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">mutations</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  SET_PERMISSIONS</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">state</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> permissions</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    state</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">permissions</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> permissions</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>2. 实现权限校验逻辑</strong></p>\n<p><strong>方案一：自定义指令（推荐）</strong></p>\n<ul>\n<li><strong>创建指令 <code>v-permission</code></strong>：自动隐藏无权限的按钮。</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 全局指令（Vue 3）</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">app</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">directive</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">permission</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  mounted</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">el</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> binding</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">    const</span><span style=\"color:#999999\"> {</span><span style=\"color:#B07D48\"> value</span><span style=\"color:#999999\">:</span><span style=\"color:#B07D48\"> requiredPermission</span><span style=\"color:#999999\"> }</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> binding</span><span style=\"color:#999999\">;</span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">    const</span><span style=\"color:#B07D48\"> hasPermission</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> store</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">getters</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">permissions</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">includes</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">requiredPermission</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    if</span><span style=\"color:#999999\"> (</span><span style=\"color:#AB5959\">!</span><span style=\"color:#B07D48\">hasPermission</span><span style=\"color:#999999\">)</span><span style=\"color:#B07D48\"> el</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">parentNode</span><span style=\"color:#999999\">?.</span><span style=\"color:#59873A\">removeChild</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">el</span><span style=\"color:#999999\">);</span><span style=\"color:#A0ADA0\"> // 或 el.style.display = 'none'</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 使用</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#B07D48\"> v-permission</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">'delete_user'</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">删除用户</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>方案二：封装权限组件</strong></p>\n<ul>\n<li><strong>创建组件 <code>&lt;AuthButton&gt;</code></strong>：根据权限控制按钮显示。</li>\n</ul>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">&#x3C;!-- AuthButton.vue --></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">template</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#1E754F\"> v-if</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#B07D48\">hasPermission</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#1E754F\">slot</span><span style=\"color:#999999\">>&#x3C;/</span><span style=\"color:#1E754F\">slot</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">template</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">export</span><span style=\"color:#1E754F\"> default</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  props</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">permission</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">],</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  computed</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    hasPermission</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">      return</span><span style=\"color:#A65E2B\"> this</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">$store</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">getters</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">permissions</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">includes</span><span style=\"color:#999999\">(</span><span style=\"color:#A65E2B\">this</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">permission</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">    }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#393A34\">// 使用</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">AuthButton</span><span style=\"color:#B07D48\"> permission</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">edit_user</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">编辑用户</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">AuthButton</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>方案三：条件渲染 + 工具函数</strong></p>\n<ul>\n<li><strong>全局方法 <code>$hasPermission</code></strong>：快速校验权限。</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 注入全局方法（Vue 3）</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">app</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">config</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">globalProperties</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">$hasPermission</span><span style=\"color:#999999\"> =</span><span style=\"color:#AB5959\"> function</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">permission</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#A65E2B\"> this</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">$store</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">getters</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">permissions</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">includes</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">permission</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 使用</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#B07D48\"> v-if</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">$hasPermission('view_logs')</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">查看日志</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>3. 动态响应权限变化</strong></p>\n<ul>\n<li><strong>监听权限变更</strong>：当用户切换角色或权限更新时，确保按钮状态同步。</li>\n</ul>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 示例：用户切换角色后更新权限</span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">await</span><span style=\"color:#B07D48\"> store</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">dispatch</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">user/refreshPermissions</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>4. 高级场景：组合权限与权限组</strong></p>\n<ul>\n<li><strong>支持多权限校验</strong>：如“需同时满足A和B权限”或“满足任一即可”。</li>\n</ul>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#393A34\">// 工具函数扩展</span></span>\n<span class=\"line\"><span style=\"color:#393A34\">export const hasAllPermissions = (permissions) => </span></span>\n<span class=\"line\"><span style=\"color:#393A34\">  permissions.every(p => store.getters.permissions.includes(p));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#393A34\">export const hasAnyPermission = (permissions) => </span></span>\n<span class=\"line\"><span style=\"color:#393A34\">  permissions.some(p => store.getters.permissions.includes(p));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#393A34\">// 使用</span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">button</span><span style=\"color:#1E754F\"> v-if</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#59873A\">hasAllPermissions</span><span style=\"color:#999999\">([</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">add_user</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">edit_user</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">])</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">高级操作</span><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">button</span><span style=\"color:#999999\">></span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>总结</strong></p>\n<ul>\n<li><strong>核心流程</strong>：登录获取权限 → 存储至全局状态 → 校验权限 → 控制UI渲染。</li>\n<li><strong>推荐方案</strong>：\n<ul>\n<li><strong>简单场景</strong>：使用 <code>v-if + 全局方法</code> 快速实现。</li>\n<li><strong>复杂场景</strong>：通过<strong>自定义指令</strong>或<strong>权限组件</strong>封装，提升代码复用性。</li>\n</ul>\n</li>\n<li><strong>注意事项</strong>：\n<ul>\n<li>权限标识需与后端约定一致（如字符串格式）。</li>\n<li>避免在前端硬编码权限逻辑，确保灵活性。</li>\n<li>权限变更时及时更新状态，保持UI同步。</li>\n</ul>\n</li>\n</ul>\n<p>通过上述方案，可高效实现按钮级权限控制，兼顾代码维护性和用户体验。</p>\n"},{"title":"如何解决vue项目部署后页面出现白屏的问题？","answer":"<ol>\n<li>\n<p><strong>检查静态资源路径</strong></p>\n<ul>\n<li>确认 <code>vue.config.js</code> 中的 <code>publicPath</code> 是否与服务器部署路径匹配（如子目录部署需设置为 <code>'/子目录/'</code>）。</li>\n</ul>\n</li>\n<li>\n<p><strong>路由模式配置</strong></p>\n<ul>\n<li>\n<p><strong>History模式</strong>：确保服务器（如Nginx/Apache）配置了重定向规则，所有非静态资源请求返回 <code>index.html</code>。</p>\n<pre><code class=\"language-nginx\"># Nginx配置示例\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n</code></pre>\n</li>\n<li>\n<p><strong>Hash模式</strong>：改用 <code>hash</code> 模式（无需服务端配置），避免路由刷新404。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>排查资源加载失败</strong></p>\n<ul>\n<li>打开浏览器控制台（F12），查看 <code>Network</code> 面板中 JS/CSS 文件是否加载成功（404/403错误）。</li>\n<li>若路径错误，调整构建配置或服务器静态资源目录映射。</li>\n</ul>\n</li>\n<li>\n<p><strong>处理代码执行错误</strong></p>\n<ul>\n<li>\n<p>检查控制台是否有报错（如未捕获的Promise异常、依赖缺失）。</p>\n</li>\n<li>\n<p>开启生产环境 Source Map（临时调试）：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// vue.config.js</span></span>\n<span class=\"line\"><span style=\"color:#998418\">module</span><span style=\"color:#999999\">.</span><span style=\"color:#998418\">exports</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  productionSourceMap</span><span style=\"color:#999999\">:</span><span style=\"color:#1E754F\"> true</span><span style=\"color:#A0ADA0\"> // 构建后生成Source Map</span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p>修复代码逻辑后，关闭 Source Map 并重新构建。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>优化首屏加载速度</strong></p>\n<ul>\n<li><strong>代码分割</strong>：使用动态导入（<code>() =&gt; import()</code>）实现路由懒加载。</li>\n<li><strong>预加载关键资源</strong>：通过 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 提前加载核心文件。</li>\n<li><strong>启用Gzip/Brotli压缩</strong>：减少资源体积（需服务器支持）。</li>\n</ul>\n</li>\n<li>\n<p><strong>浏览器兼容性处理</strong></p>\n<ul>\n<li>\n<p>在 <code>babel.config.js</code> 中配置 <code>@babel/preset-env</code>，添加 <code>core-js</code> polyfill：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#59873A\">presets</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> [</span></span>\n<span class=\"line\"><span style=\"color:#999999\">  [</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">@vue/cli-plugin-babel/preset</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\"> </span></span>\n<span class=\"line\"><span style=\"color:#998418\">    useBuiltIns</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">usage</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#393A34\"> </span></span>\n<span class=\"line\"><span style=\"color:#998418\">    corejs</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 3</span><span style=\"color:#393A34\"> </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }]</span></span>\n<span class=\"line\"><span style=\"color:#999999\">]</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>服务器配置优化</strong></p>\n<ul>\n<li><strong>缓存策略</strong>：为静态资源设置长期缓存（<code>Cache-Control: max-age=31536000</code>）。</li>\n<li><strong>MIME类型检查</strong>：确保服务器正确返回 <code>.js</code>、<code>.css</code> 文件的MIME类型。</li>\n</ul>\n</li>\n<li>\n<p><strong>容错处理</strong></p>\n<ul>\n<li>\n<p>全局错误捕获：在 <code>main.js</code> 中监听 Vue 全局错误。</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#B07D48\">Vue</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">config</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">errorHandler</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">err</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">  // 上报错误至监控系统</span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">  console</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">error</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">全局错误:</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> err</span><span style=\"color:#999999\">);</span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例解决方案（Nginx + History模式）：</strong></p>\n<ol>\n<li>\n<p>构建时设置 <code>publicPath</code> 为 <code>/</code>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// vue.config.js</span></span>\n<span class=\"line\"><span style=\"color:#998418\">module</span><span style=\"color:#999999\">.</span><span style=\"color:#998418\">exports</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> {</span></span>\n<span class=\"line\"><span style=\"color:#998418\">  publicPath</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">/</span><span style=\"color:#B5695977\">'</span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p>配置Nginx重定向规则：</p>\n<pre><code class=\"language-nginx\">server {\n  location / {\n    root   /usr/share/nginx/html;\n    index  index.html;\n    try_files $uri $uri/ /index.html; # 关键配置\n  }\n}\n</code></pre>\n</li>\n<li>\n<p>检查控制台错误并修复代码逻辑，确保无执行异常。</p>\n</li>\n</ol>\n"},{"title":"Vue3性能提升体现在哪些方面？","answer":"<p><strong>1. 响应式系统优化（Proxy 替代 defineProperty）</strong></p>\n<ul>\n<li><strong>更高效</strong>：Proxy 直接代理对象，无需递归遍历属性，初始化速度和内存占用更优。</li>\n<li><strong>动态监听</strong>：支持监听对象新增/删除属性、数组索引修改等，无需 <code>Vue.set</code>/<code>Vue.delete</code>。</li>\n<li><strong>惰性监听</strong>：嵌套对象按需代理，减少不必要的深层响应式转换。</li>\n</ul>\n<p><strong>2. 编译阶段优化</strong></p>\n<ul>\n<li><strong>静态提升（Static Hoisting）</strong>：\n将模板中<strong>静态节点</strong>（无动态绑定的元素）提取为常量，避免重复创建虚拟 DOM。</li>\n<li><strong>Patch Flag 标记动态内容</strong>：\n虚拟 DOM 节点添加标记（如 <code>1</code> 表示文本动态），Diff 时仅比对标记部分，跳过静态内容。</li>\n<li><strong>Block Tree 优化</strong>：\n将动态节点按结构分组为“块”，减少递归遍历层级，提升 Diff 效率。</li>\n</ul>\n<p><strong>3. Tree-Shaking 支持</strong></p>\n<ul>\n<li><strong>按需编译</strong>：通过模块化设计（如 <code>createApp</code> 替代 <code>new Vue</code>），未使用的 API（如 <code>v-model</code> 修饰符）不会打包进生产环境。</li>\n<li><strong>体积减少</strong>：核心库体积从 Vue 2 的 ~20KB 压缩后降至 ~10KB，加载更快。</li>\n</ul>\n<p><strong>4. 虚拟 DOM 与 Diff 算法优化</strong></p>\n<ul>\n<li><strong>更精准的 Diff</strong>：结合 Patch Flag 和 Block Tree，减少无效比对，如静态节点直接跳过。</li>\n<li><strong>事件侦听缓存</strong>：同一元素的动态事件（如 <code>@click</code>）仅绑定一次，避免重复创建。</li>\n</ul>\n<p><strong>5. 组合式 API（Composition API）的间接优化</strong></p>\n<ul>\n<li><strong>逻辑复用</strong>：通过自定义 Hook 减少重复代码，避免 Options API 的碎片化，间接提升代码执行效率。</li>\n<li><strong>更细粒度控制</strong>：手动管理响应式依赖（如 <code>ref</code>/<code>reactive</code>），减少不必要的依赖追踪。</li>\n</ul>\n<p><strong>6. 服务端渲染（SSR）优化</strong></p>\n<ul>\n<li><strong>静态内容直出</strong>：静态节点在服务端直接渲染为字符串，客户端跳过 Hydration 过程。</li>\n<li><strong>流式渲染</strong>：支持分块传输 HTML，提升首屏加载速度。</li>\n</ul>\n<p><strong>7. 其他细节优化</strong></p>\n<ul>\n<li><strong>Fragment 支持</strong>：组件支持多根节点，减少无意义包裹元素（如 <code>&lt;div&gt;</code>）。</li>\n<li><strong>Teleport 组件</strong>：跨 DOM 层级渲染（如弹窗），避免冗余的父级样式影响。</li>\n</ul>\n"},{"title":"Vue3里为什么要用 Proxy API 替代 defineProperty API ？","answer":"<ol>\n<li><strong>更全面的数据劫持能力</strong>\n<ul>\n<li><strong>Object.defineProperty</strong>：\n<ul>\n<li>只能劫持对象的<strong>已有属性</strong>，需遍历每个属性递归设置。</li>\n<li>无法检测<strong>新增/删除属性</strong>（需借助 <code>Vue.set</code>/<code>Vue.delete</code>）。</li>\n<li>对<strong>数组索引修改</strong>（如 <code>arr[0] = 1</code>）和<strong>长度变化</strong>（如 <code>arr.length = 0</code>）无法监听，需重写数组方法（如 <code>push</code>、<code>pop</code>）。</li>\n</ul>\n</li>\n<li><strong>Proxy</strong>：\n<ul>\n<li>直接代理<strong>整个对象</strong>，自动拦截所有属性的增删改查（包括动态新增属性）。</li>\n<li>天然支持<strong>数组索引修改</strong>和<strong>原生数组方法</strong>，无需额外处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>性能优化</strong>\n<ul>\n<li><strong>初始化性能</strong>：Proxy 无需递归遍历对象属性，直接代理整个对象，初始化速度更快（尤其对复杂对象）。</li>\n<li><strong>惰性代理</strong>：Proxy 仅在访问嵌套对象时进行代理，减少不必要的响应式转换开销。</li>\n</ul>\n</li>\n<li><strong>功能扩展性</strong>\n<ul>\n<li><strong>支持更多操作</strong>：Proxy 可拦截 <code>has</code>（<code>in</code> 操作符）、<code>deleteProperty</code>（删除属性）、<code>ownKeys</code>（遍历属性）等操作，覆盖更全面的响应式场景。</li>\n<li><strong>兼容新数据结构</strong>：如 <code>Map</code>、<code>Set</code>、<code>WeakMap</code> 等集合类型，Proxy 可代理其原生方法（如 <code>map.set()</code>），而 <code>defineProperty</code> 无法实现。</li>\n</ul>\n</li>\n<li><strong>代码简化与维护性</strong>\n<ul>\n<li><strong>统一拦截逻辑</strong>：Proxy 通过 <code>get</code>/<code>set</code> 等统一拦截器处理所有操作，代码更简洁。</li>\n<li><strong>避免 Vue 2 的补丁式实现</strong>：如数组方法重写、<code>$set</code>/<code>$delete</code> 等 API 的冗余逻辑。</li>\n</ul>\n</li>\n<li><strong>浏览器兼容性取舍</strong>\n<ul>\n<li>Proxy 是 ES6 特性，不支持 IE11 等旧浏览器，但 Vue 3 明确放弃对 IE 的支持，得以拥抱更现代化的特性。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Vue3 所采用的 Composition Api 与 Vue2 使用的 Options Api 有什么不同？","answer":"<ol>\n<li><strong>代码组织方式</strong>\n<ul>\n<li><strong>Options API</strong>：按功能类型划分代码（如 <code>data</code>、<code>methods</code>、<code>computed</code>），逻辑分散在不同选项中，复杂组件中代码阅读困难。</li>\n<li><strong>Composition API</strong>：按逻辑功能组织代码（如用户管理、数据请求），通过 <code>setup</code> 函数聚合相关逻辑，提升内聚性。</li>\n</ul>\n</li>\n<li><strong>逻辑复用能力</strong>\n<ul>\n<li><strong>Options API</strong>：通过 Mixins 复用逻辑，但易引发命名冲突、数据来源不透明。</li>\n<li><strong>Composition API</strong>：通过自定义 Hook（如 <code>useFetch</code>）复用逻辑，基于函数组合，依赖清晰且无副作用冲突。</li>\n</ul>\n</li>\n<li><strong>类型系统支持</strong>\n<ul>\n<li><strong>Options API</strong>：<code>this</code> 上下文导致 TypeScript 类型推断困难（如访问 <code>methods</code> 中的函数）。</li>\n<li><strong>Composition API</strong>：基于函数和变量，天然支持 TypeScript 类型推导，代码更健壮。</li>\n</ul>\n</li>\n<li><strong>响应式管理</strong>\n<ul>\n<li><strong>Options API</strong>：依赖 <code>data</code> 和 <code>computed</code> 选项隐式管理响应式，灵活性较低。</li>\n<li><strong>Composition API</strong>：显式使用 <code>ref</code>/<code>reactive</code> 创建响应式数据，结合 <code>watch</code>/<code>computed</code> 动态控制，逻辑更透明。</li>\n</ul>\n</li>\n<li><strong>生命周期控制</strong>\n<ul>\n<li><strong>Options API</strong>：生命周期钩子（如 <code>mounted</code>）分散在代码中。</li>\n<li><strong>Composition API</strong>：通过 <code>onMounted</code> 等函数式钩子集中管理，支持逻辑内聚。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"说说Vue3中Treeshaking特性？","answer":"<p>Vue3 的 Tree-shaking 通过模块化设计，将功能拆分为独立函数或组件。打包时，<strong>没用到的代码（如未引入的API、组件）会被自动移除</strong>，减小体积。比如没用到 <code>Transition</code> 组件，最终打包就不会包含它。</p>\n<p>Vue3 通过以下设计实现高效的 Tree Shaking，显著减少打包体积：</p>\n<ol>\n<li><strong>模块化 API 设计</strong>\n<ul>\n<li><strong>按需导出</strong>：Vue 3 将核心功能拆分为独立的 ES 模块（如 <code>ref</code>、<code>reactive</code>、<code>watch</code>），开发者通过具名导入（<code>import { ref } from 'vue'</code>）仅引入所需功能。</li>\n<li><strong>全局 API 改造</strong>：移除 Vue 2 的全局实例方法（如 <code>Vue.nextTick</code>），改为模块导出（<code>import { nextTick } from 'vue'</code>），未使用的 API 自动被剔除。</li>\n</ul>\n</li>\n<li><strong>功能解耦</strong>\n<ul>\n<li><strong>内置组件/指令按需加载</strong>：如 <code>&lt;Transition&gt;</code>、<code>v-model</code> 等仅在引入时包含在构建产物中。</li>\n<li><strong>可选功能分离</strong>：如响应式系统、编译器、服务端渲染等拆分为独立模块，未启用的功能（如未使用服务端渲染）不参与打包。</li>\n</ul>\n</li>\n<li><strong>ES 模块构建</strong>\n<ul>\n<li><strong>ESM 格式支持</strong>：Vue 3 源码默认以 ES 模块发布，构建工具（如 Webpack、Rollup）能静态分析依赖关系，精准删除未引用代码。</li>\n<li><strong>副作用标记优化</strong>：通过 <code>package.json</code> 的 <code>sideEffects</code> 字段标记无副作用的文件，避免误删必要代码。</li>\n</ul>\n</li>\n</ol>\n<p><strong>效果</strong>：</p>\n<ul>\n<li><strong>体积优化</strong>：Vue 3 核心库体积从 Vue 2 的 ~20KB 压缩后降至 ~10KB。</li>\n<li><strong>灵活适配场景</strong>：开发者根据项目需求精准引入功能，避免冗余代码（如移动端项目移除服务端渲染相关代码）。</li>\n</ul>\n"},{"title":"Vue3中 ref 和 reactive 的区别及使用场景？","answer":"<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>选择依据</strong></th>\n<th style=\"text-align:left\"><strong><code>ref</code></strong></th>\n<th style=\"text-align:left\"><strong><code>reactive</code></strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>数据类型</strong></td>\n<td style=\"text-align:left\">基本类型、需要整体替换的对象</td>\n<td style=\"text-align:left\">复杂对象、嵌套数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>开发习惯</strong></td>\n<td style=\"text-align:left\">偏好显式 <code>.value</code> 操作</td>\n<td style=\"text-align:left\">偏好直接属性访问</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>灵活性</strong></td>\n<td style=\"text-align:left\">更高（支持替换对象、兼容基本类型）</td>\n<td style=\"text-align:left\">稍低（依赖对象结构）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>TypeScript</strong></td>\n<td style=\"text-align:left\">类型推断更简单</td>\n<td style=\"text-align:left\">需明确接口类型</td>\n</tr>\n</tbody>\n</table>\n<p><strong>推荐原则</strong>：</p>\n<ul>\n<li>优先用 <code>ref</code> 处理基本类型和需要灵活替换的场景；</li>\n<li>用 <code>reactive</code> 管理复杂对象，尤其是需要直接操作属性的场景；</li>\n<li>组合式函数优先返回 <code>ref</code>，方便调用方解构使用。</li>\n</ul>\n"},{"title":"Vue 中如何使用动态组件？","answer":"<p>在Vue中可以通过<code>&lt;component :is=&quot;组件变量&quot;&gt;</code>实现动态组件。比如用<code>v-bind:is</code>绑定一个组件名或导入的组件对象变量，Vue会根据变量值动态渲染对应组件。配合<code>keep-alive</code>包裹可以缓存组件状态，避免频繁销毁创建。</p>\n"},{"title":"谈谈你对Vue中transition的理解？","answer":"<p>Vue 的 <code>&lt;transition&gt;</code> 组件用于<strong>元素/组件的过渡动画</strong>，核心机制：</p>\n<ol>\n<li><strong>触发条件</strong>：\n<ul>\n<li>元素通过 <code>v-if</code>、<code>v-show</code> 或动态组件切换显示状态时触发。</li>\n</ul>\n</li>\n<li><strong>实现方式</strong>：\n<ul>\n<li><strong>CSS 过渡</strong>：自动应用 <code>v-enter</code>（进入开始）、<code>v-enter-active</code>（进入过程）、<code>v-leave-to</code>（离开结束）等类名，通过 CSS 定义动画（如 <code>transition</code> 属性）。</li>\n<li><strong>JS 钩子</strong>：通过事件（如 <code>@before-enter</code>、<code>@enter</code>）结合第三方库（如 GSAP）实现复杂动画。</li>\n</ul>\n</li>\n<li><strong>过渡模式</strong>：\n<ul>\n<li><code>mode=&quot;out-in&quot;</code>：先执行离开动画，再执行进入动画，避免布局冲突。</li>\n</ul>\n</li>\n<li><strong>列表过渡</strong>：\n<ul>\n<li>使用 <code>&lt;transition-group&gt;</code> 实现动态列表项（如 <code>v-for</code>）的排序动画，需为每项设置唯一 <code>key</code>。</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">transition</span><span style=\"color:#B07D48\"> name</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">fade</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B07D48\"> mode</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">out-in</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#393A34\">  &#x3C;div v-if=\"show\" key=\"content\">内容&#x3C;/div>  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">transition</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">style</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">fade-enter-active</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> .</span><span style=\"color:#B07D48\">fade-leave-active</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#998418\">  transition</span><span style=\"color:#999999\">:</span><span style=\"color:#393A34\"> opacity </span><span style=\"color:#2F798A\">0.5</span><span style=\"color:#AB5959\">s</span><span style=\"color:#999999\">;</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">fade-enter</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> .</span><span style=\"color:#B07D48\">fade-leave-to</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#998418\">  opacity</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 0</span><span style=\"color:#999999\">;</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  vue</span></span>\n<span class=\"line\"><span style=\"color:#393A34\">&#x3C;/</span><span style=\"color:#1E754F\">style</span><span style=\"color:#AB5959\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>优势</strong>：简化动画逻辑，提升交互体验，支持 CSS/JS 灵活控制。</p>\n"},{"title":"assets和static的区别？","answer":"<p><code>assets</code> 目录，在编译过程中会被 webpack 处理，当做模块依赖，只支持相对路径的形式。一般放置可能会变动的文件。</p>\n<p><code>static</code> 目录，一般存放第三方文件，不会被 webpack 解析，会直接被复制到最终的打包目录（默认是 <code>dist/static</code> ）下，必须使用绝对路径引用，这些文件是不会变动的。</p>\n"},{"title":"vue初始化页面闪动问题","answer":"<p>使用vue开发时，在vue初始化之前，由于 <code>div</code> 是不归 <code>vue</code> 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于 <code>{{message}}</code> 的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。首先：在css里加上 <code>[v-cloak] { display: none; }</code> 。如果没有彻底解决问题，则在根元素加上 style=&quot;display: none;&quot; :style=&quot;{display:  block }&quot;</p>\n"},{"title":"Vue 3 中的 watch 和 watchEffect 有什么区别？","answer":"<p><strong>1. 依赖收集方式</strong></p>\n<ul>\n<li><strong><code>watch</code></strong>：需<strong>显式声明</strong>监听的数据源（如 <code>() =&gt; state.count</code>），仅响应这些源的变化。</li>\n<li><strong><code>watchEffect</code></strong>：<strong>自动收集</strong>回调中<strong>所有响应式依赖</strong>，无需手动指定。</li>\n</ul>\n<p><strong>2. 执行时机</strong></p>\n<ul>\n<li><strong><code>watch</code></strong>：默认<strong>惰性执行</strong>（依赖变化时才触发），可配置 <code>immediate: true</code> 立即执行。</li>\n<li><strong><code>watchEffect</code></strong>：<strong>立即执行一次</strong>（初始化时自动运行），随后依赖变化时触发。</li>\n</ul>\n<p><strong>3. 旧值获取</strong></p>\n<ul>\n<li><strong><code>watch</code></strong>：可获取旧值和新值（<code>(newVal, oldVal) =&gt; {}</code>）。</li>\n<li><strong><code>watchEffect</code></strong>：<strong>无法直接获取旧值</strong>（仅能访问当前值）。</li>\n</ul>\n<p><strong>4. 监听多源</strong></p>\n<ul>\n<li>\n<p><strong><code>watch</code></strong>：支持同时监听多个数据源（数组形式）：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#59873A\">watch</span><span style=\"color:#999999\">([</span><span style=\"color:#B07D48\">source1</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> source2</span><span style=\"color:#999999\">],</span><span style=\"color:#999999\"> ([</span><span style=\"color:#B07D48\">new1</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> new2</span><span style=\"color:#999999\">])</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {})</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong><code>watchEffect</code></strong>：隐式依赖，无法显式声明多源。</p>\n</li>\n</ul>\n<p><strong>5. 配置选项</strong></p>\n<ul>\n<li><strong><code>watch</code></strong>：可配置 <code>deep</code>（深度监听）、<code>flush</code>（触发时机）等选项。</li>\n<li><strong><code>watchEffect</code></strong>：无 <code>deep</code> 配置（自动跟踪嵌套属性），但可设置 <code>flush</code>。</li>\n</ul>\n<p><strong>使用场景对比</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><strong>场景</strong></th>\n<th style=\"text-align:left\"><strong>推荐 API</strong></th>\n<th style=\"text-align:left\"><strong>示例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">需要旧值对比</td>\n<td style=\"text-align:left\"><code>watch</code></td>\n<td style=\"text-align:left\">记录表单字段变化前后的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">监听特定数据源</td>\n<td style=\"text-align:left\"><code>watch</code></td>\n<td style=\"text-align:left\">路由参数变化时加载数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">自动追踪多个依赖</td>\n<td style=\"text-align:left\"><code>watchEffect</code></td>\n<td style=\"text-align:left\">根据筛选条件自动查询数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">立即执行副作用</td>\n<td style=\"text-align:left\"><code>watchEffect</code></td>\n<td style=\"text-align:left\">初始化时加载数据并监听依赖变化</td>\n</tr>\n</tbody>\n</table>\n<p><strong>总结</strong></p>\n<ul>\n<li><strong><code>watch</code></strong>：精准控制监听目标，适合需要旧值或条件触发的场景。</li>\n<li><strong><code>watchEffect</code></strong>：简化依赖管理，适合自动追踪和立即执行的副作用。</li>\n</ul>\n"},{"title":"Vue函数式组件的特点是什么？与普通组件的区别？","answer":"<p>Vue 函数式组件是<strong>无状态、无实例</strong>的组件，特点及区别如下：</p>\n<ol>\n<li><strong>特点</strong>：\n<ul>\n<li><strong>性能高</strong>：无响应式数据与实例化开销，仅依赖 <code>props</code> 渲染；</li>\n<li><strong>纯渲染</strong>：通过 <code>render</code> 函数或模板返回 VNode，无生命周期钩子；</li>\n<li><strong>访问方式</strong>：通过 <code>context</code> 参数获取 <code>props</code>、<code>slots</code> 等数据。</li>\n</ul>\n</li>\n<li><strong>与普通组件区别</strong>：\n<ul>\n<li><strong>状态管理</strong>：普通组件可维护自身状态（<code>data</code>），函数式组件无状态；</li>\n<li><strong>实例化</strong>：普通组件有 <code>this</code> 实例，函数式组件无实例，无法访问 <code>ref</code>；</li>\n<li><strong>使用场景</strong>：函数式组件适合纯展示型内容（如静态列表项），普通组件适合交互复杂、需状态管理的场景。</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例（Vue 3）</strong>：</p>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#393A34\">const FunctionalComp = (props, context) => {  </span></span>\n<span class=\"line\"><span style=\"color:#393A34\">  return h('div', context.attrs, props.text);  </span></span>\n<span class=\"line\"><span style=\"color:#393A34\">};  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>总结</strong>：函数式组件轻量高效，但功能受限，需权衡场景使用。</p>\n"},{"title":"在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？","answer":"<p>在 Vue 的 <code>v-for</code> 中，默认情况下为每个元素单独绑定事件（如 <code>@click</code>）会创建多个监听器，对长列表可能有性能开销。是否使用事件代理需权衡场景：</p>\n<ol>\n<li><strong>直接绑定（无需代理）</strong>：\n<ul>\n<li><strong>优点</strong>：逻辑直观，可通过参数直接传递作用域数据（如 <code>@click=&quot;handleClick(item)&quot;</code>）。</li>\n<li><strong>缺点</strong>：列表项多时内存占用高（每个元素独立监听），动态增删项可能导致监听器冗余。</li>\n</ul>\n</li>\n<li><strong>事件代理（推荐长列表）</strong>：\n<ul>\n<li><strong>实现方式</strong>：在父元素绑定一个监听器，通过事件对象 <code>event.target</code> 定位触发元素，结合 <code>data-*</code> 属性传递标识。</li>\n<li><strong>优点</strong>：内存优化（单监听器），适合动态列表（避免频繁绑定/解绑）。</li>\n<li><strong>缺点</strong>：需手动处理事件目标过滤，无法直接利用 Vue 的响应式数据。</li>\n</ul>\n</li>\n</ol>\n<p><strong>示例</strong></p>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">template</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;</span><span style=\"color:#1E754F\">ul</span><span style=\"color:#999999\"> @</span><span style=\"color:#59873A\">click</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#B07D48\">handleProxyClick</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">    &#x3C;</span><span style=\"color:#1E754F\">li</span><span style=\"color:#1E754F\"> v-for</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#B07D48\">item</span><span style=\"color:#AB5959\"> in</span><span style=\"color:#B07D48\"> list</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\"> :</span><span style=\"color:#59873A\">key</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#B07D48\">item</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">id</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\"> :</span><span style=\"color:#59873A\">data-id</span><span style=\"color:#999999\">=</span><span style=\"color:#999999\">\"</span><span style=\"color:#B07D48\">item</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">id</span><span style=\"color:#999999\">\"</span><span style=\"color:#999999\">>{{</span><span style=\"color:#B07D48\"> item</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">name</span><span style=\"color:#999999\"> }}&#x3C;/</span><span style=\"color:#1E754F\">li</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  &#x3C;/</span><span style=\"color:#1E754F\">ul</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">template</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">export</span><span style=\"color:#1E754F\"> default</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#998418\">  methods</span><span style=\"color:#999999\">:</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">    handleProxyClick</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">event</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">      const</span><span style=\"color:#B07D48\"> id</span><span style=\"color:#999999\"> =</span><span style=\"color:#B07D48\"> event</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">target</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">dataset</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">id</span><span style=\"color:#999999\">;</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">      if</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">id</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">        const</span><span style=\"color:#B07D48\"> item</span><span style=\"color:#999999\"> =</span><span style=\"color:#A65E2B\"> this</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">list</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">find</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">item</span><span style=\"color:#999999\"> =></span><span style=\"color:#B07D48\"> item</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">id</span><span style=\"color:#AB5959\"> ===</span><span style=\"color:#B07D48\"> id</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">        // 处理逻辑  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">      }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">    }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  }</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">};</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">script</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n"},{"title":"为什么需要 toRef 和 toRefs？在解构 reactive 对象时它们的作用是什么？","answer":"<p><code>oRef</code> 和 <code>toRefs</code> 用于在解构 Vue 3 的 <code>reactive</code> 对象时<strong>保持响应式</strong>。</p>\n<ul>\n<li><strong>直接解构的问题</strong>：\n若直接解构 <code>reactive</code> 对象，得到的属性是<strong>普通值</strong>，失去响应性。</li>\n<li><strong><code>toRef</code> 的作用</strong>：\n将 <code>reactive</code> 对象的<strong>单个属性</strong>转为 <code>ref</code>，保持与源属性的响应式连接。</li>\n<li><strong><code>toRefs</code> 的作用</strong>：\n将整个 <code>reactive</code> 对象的所有属性转为 <code>ref</code> 的普通对象，便于解构后仍保留响应性。</li>\n</ul>\n"},{"title":"如何编写一个自定义 Hook ？需要注意哪些问题？","answer":"<p><strong>如何编写</strong></p>\n<ol>\n<li><strong>命名规范</strong>：以 <code>use</code> 开头（如 <code>useFetch</code>），遵循 React Hooks 规则；</li>\n<li><strong>提取逻辑</strong>：将组件中的状态、副作用等封装为函数，返回需暴露的数据/方法；</li>\n<li><strong>组合原生 Hooks</strong>：灵活使用 <code>useState</code>、<code>useEffect</code> 等构建功能；</li>\n<li><strong>参数与返回值</strong>：通过入参定制逻辑，返回结构化的数据供组件使用。</li>\n</ol>\n<p><strong>示例</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#A0ADA0\">// 自定义 Hook：获取鼠标位置  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> useMousePosition</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  const</span><span style=\"color:#999999\"> [</span><span style=\"color:#B07D48\">position</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> setPosition</span><span style=\"color:#999999\">]</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> useState</span><span style=\"color:#999999\">({</span><span style=\"color:#998418\"> x</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 0</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> y</span><span style=\"color:#999999\">:</span><span style=\"color:#2F798A\"> 0</span><span style=\"color:#999999\"> });</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">  useEffect</span><span style=\"color:#999999\">(()</span><span style=\"color:#999999\"> =></span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">    const</span><span style=\"color:#59873A\"> handleMove</span><span style=\"color:#999999\"> =</span><span style=\"color:#999999\"> (</span><span style=\"color:#B07D48\">e</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> =></span><span style=\"color:#59873A\"> setPosition</span><span style=\"color:#999999\">({</span><span style=\"color:#998418\"> x</span><span style=\"color:#999999\">:</span><span style=\"color:#B07D48\"> e</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">clientX</span><span style=\"color:#999999\">,</span><span style=\"color:#998418\"> y</span><span style=\"color:#999999\">:</span><span style=\"color:#B07D48\"> e</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">clientY</span><span style=\"color:#999999\"> });</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#B07D48\">    window</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">addEventListener</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">mousemove</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> handleMove</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">    return</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#B07D48\"> window</span><span style=\"color:#999999\">.</span><span style=\"color:#59873A\">removeEventListener</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">mousemove</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> handleMove</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">  },</span><span style=\"color:#999999\"> []);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#B07D48\"> position</span><span style=\"color:#999999\">;</span><span style=\"color:#A0ADA0\"> // 返回坐标数据  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 组件中使用  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">function</span><span style=\"color:#59873A\"> App</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#AB5959\">  const</span><span style=\"color:#999999\"> {</span><span style=\"color:#B07D48\"> x</span><span style=\"color:#999999\">,</span><span style=\"color:#B07D48\"> y</span><span style=\"color:#999999\"> }</span><span style=\"color:#999999\"> =</span><span style=\"color:#59873A\"> useMousePosition</span><span style=\"color:#999999\">();</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#999999\"> &#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">鼠标位置：</span><span style=\"color:#999999\">{</span><span style=\"color:#B07D48\">x</span><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">, </span><span style=\"color:#999999\">{</span><span style=\"color:#B07D48\">y</span><span style=\"color:#999999\">}&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">>;</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n<p><strong>注意事项</strong></p>\n<ul>\n<li><strong>响应式数据</strong>：返回 <code>ref</code>/<code>reactive</code>，确保组件中响应性生效；</li>\n<li><strong>副作用清理</strong>：在 <code>onUnmounted</code> 中移除事件监听、定时器等，避免内存泄漏；</li>\n<li><strong>参数设计</strong>：支持灵活配置（如 <code>useFetch(url, options)</code>），通过参数控制逻辑；</li>\n<li><strong>单一职责</strong>：一个 Hook 解决一个问题（如 <code>useLocalStorage</code> 只处理本地存储）；</li>\n<li><strong>依赖管理</strong>：若依赖其他 Hook 或上下文，显式声明而非隐式耦合。</li>\n</ul>\n"},{"title":"render 函数了解吗？","answer":"<p>Vue 的 <code>render</code> 函数通过 <strong>JavaScript 编程式生成虚拟 DOM</strong>，替代模板语法，适用于复杂动态渲染场景。</p>\n<p><strong>核心要点</strong>：</p>\n<ol>\n<li>\n<p><strong>基本用法</strong>：</p>\n<pre><code class=\"language-javascript\"><div class=\"language-javascript \"><span class=\"lang\">javascript</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#59873A\">render</span><span style=\"color:#999999\">(</span><span style=\"color:#B07D48\">h</span><span style=\"color:#999999\">)</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#59873A\"> h</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">div</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#999999\"> {</span><span style=\"color:#998418\"> class</span><span style=\"color:#999999\">:</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">title</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\"> },</span><span style=\"color:#A65E2B\"> this</span><span style=\"color:#999999\">.</span><span style=\"color:#B07D48\">message</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#A0ADA0\">// 或组合式 API 中使用  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">import</span><span style=\"color:#999999\"> {</span><span style=\"color:#B07D48\"> h</span><span style=\"color:#999999\"> }</span><span style=\"color:#1E754F\"> from</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">vue</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">;</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#59873A\">setup</span><span style=\"color:#999999\">()</span><span style=\"color:#999999\"> {</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#1E754F\">  return</span><span style=\"color:#999999\"> ()</span><span style=\"color:#999999\"> =></span><span style=\"color:#59873A\"> h</span><span style=\"color:#999999\">(</span><span style=\"color:#B5695977\">'</span><span style=\"color:#B56959\">div</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">,</span><span style=\"color:#B5695977\"> '</span><span style=\"color:#B56959\">Hello</span><span style=\"color:#B5695977\">'</span><span style=\"color:#999999\">);</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">}</span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n</li>\n<li>\n<p><strong>优势</strong>：</p>\n<ul>\n<li><strong>灵活控制</strong>：可结合 JS 逻辑动态生成节点（如递归、复杂条件分支）；</li>\n<li><strong>性能优化</strong>：手动控制渲染逻辑，避免冗余渲染；</li>\n<li><strong>JSX 支持</strong>：通过插件编译为 <code>h</code> 函数调用，提升可读性。</li>\n</ul>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>高阶组件（HOC）封装；</li>\n<li>动态组件（如根据配置渲染不同类型组件）；</li>\n<li>需深度操作 VNode 的场景（如自定义渲染器）。</li>\n</ul>\n</li>\n</ol>\n<p><strong>与模板对比</strong>：</p>\n<ul>\n<li>模板更直观，适合简单/静态结构；</li>\n<li>Render 函数适合逻辑复杂或需编程式生成的场景。</li>\n</ul>\n"},{"title":"请叙述Vue 中使用了哪些设计模式？","answer":"<p>Vue 中主要应用了以下设计模式：</p>\n<ol>\n<li><strong>观察者模式（Observer Pattern）</strong>：\n<ul>\n<li><strong>响应式系统</strong>：通过 <code>Object.defineProperty</code>（Vue 2）或 <code>Proxy</code>（Vue 3）劫持数据变化，通知依赖（Watcher）更新视图。</li>\n</ul>\n</li>\n<li><strong>发布-订阅模式（Pub-Sub Pattern）</strong>：\n<ul>\n<li><strong>事件机制</strong>：父子组件通过 <code>$emit</code> 和 <code>$on</code> 通信，解耦事件触发与监听逻辑。</li>\n</ul>\n</li>\n<li><strong>组合模式（Composite Pattern）</strong>：\n<ul>\n<li><strong>组件树结构</strong>：组件可嵌套组合成树形结构，统一管理父子组件的行为（如插槽、作用域插槽）。</li>\n</ul>\n</li>\n<li><strong>代理模式（Proxy Pattern）</strong>：\n<ul>\n<li><strong>数据劫持</strong>：Vue 3 使用 <code>Proxy</code> 代理对象，拦截数据操作以实现响应式更新。</li>\n</ul>\n</li>\n<li><strong>单例模式（Singleton Pattern）</strong>：\n<ul>\n<li><strong>Vuex Store</strong>：全局唯一状态管理实例，确保数据源统一。</li>\n</ul>\n</li>\n<li><strong>工厂模式（Factory Pattern）</strong>：\n<ul>\n<li><strong>组件动态创建</strong>：如异步组件通过工厂函数延迟加载，<code>&lt;component :is=&quot;type&quot;&gt;</code> 动态渲染组件。</li>\n</ul>\n</li>\n<li><strong>策略模式（Strategy Pattern）</strong>：\n<ul>\n<li><strong>指令系统</strong>：不同指令（如 <code>v-if</code>、<code>v-for</code>）对应不同的 DOM 操作策略，动态选择处理逻辑。</li>\n</ul>\n</li>\n</ol>\n<p><strong>其他模式</strong>：</p>\n<ul>\n<li><strong>装饰器模式</strong>（通过 <code>@Component</code> 装饰类组件）；</li>\n<li><strong>模板方法模式</strong>（生命周期钩子定义通用流程，用户覆盖具体步骤）。</li>\n</ul>\n"},{"title":"Vue项目开发中有些什么性能优化手段?","answer":"<ol>\n<li><strong>代码层面</strong>：\n<ul>\n<li><strong>懒加载路由</strong>：<code>component: () =&gt; import('...')</code> 分割代码；</li>\n<li><strong>图片/资源优化</strong>：压缩图片、使用 WebP 格式、CDN 加速；</li>\n<li><strong>避免 <code>v-if</code> 与 <code>v-for</code> 混用</strong>：优先用 <code>computed</code> 过滤数据后渲染；</li>\n<li><strong>合理使用 <code>key</code></strong>：列表渲染时唯一 <code>key</code> 提升 Diff 效率；</li>\n<li><strong>冻结大对象</strong>：<code>Object.freeze()</code> 避免非必要响应式转换。</li>\n</ul>\n</li>\n<li><strong>组件优化</strong>：\n<ul>\n<li><strong>函数式组件</strong>：无状态组件用 <code>functional: true</code> 减少开销；</li>\n<li><strong>异步组件</strong>：动态加载非首屏组件（<code>defineAsyncComponent</code>）；</li>\n<li><strong>按需引入</strong>：如 ECharts/Element 组件库避免全量导入。</li>\n</ul>\n</li>\n<li><strong>运行时优化</strong>：\n<ul>\n<li><strong>防抖/节流</strong>：高频事件（<code>resize</code>、<code>input</code>）限制触发频率；</li>\n<li><strong>虚拟滚动</strong>：长列表用 <code>vue-virtual-scroller</code> 减少 DOM 节点；</li>\n<li><strong><code>v-memo</code></strong>（Vue 3.2+）：缓存静态子树，跳过重复渲染。</li>\n</ul>\n</li>\n<li><strong>构建优化</strong>：\n<ul>\n<li><strong>压缩混淆</strong>：Webpack/Vite 开启 <code>Terser</code> 压缩代码；</li>\n<li><strong>Tree-shaking</strong>：移除未使用代码；</li>\n<li><strong>预渲染/SSG</strong>：静态页面生成（如 VitePress、Nuxt）。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Vue中的v-cloak有什么作用？","answer":"<p><code>v-cloak</code> 用于<strong>解决 Vue 实例初始化前模板表达式（如 <code>{{ data }}</code>）短暂暴露的问题</strong>。</p>\n<pre><code class=\"language-vue\"><div class=\"language-vue \"><span class=\"lang\">vue</span><pre class=\"shiki vitesse-light\" style=\"background-color:#ffffff;color:#393a34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#999999\">&#x3C;</span><span style=\"color:#1E754F\">div</span><span style=\"color:#B07D48\"> id</span><span style=\"color:#999999\">=</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#B56959\">app</span><span style=\"color:#B5695977\">\"</span><span style=\"color:#59873A\"> v-cloak</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"><span style=\"color:#393A34\">  {{ message }}  </span></span>\n<span class=\"line\"><span style=\"color:#999999\">&#x3C;/</span><span style=\"color:#1E754F\">div</span><span style=\"color:#999999\">></span><span style=\"color:#393A34\">  </span></span>\n<span class=\"line\"></span></code></pre></div></code></pre>\n"},{"title":"你知道Vue SSR吗？","answer":"<p>Vue SSR（服务端渲染）指在<strong>服务端生成完整 HTML</strong> 返回给客户端，解决 SPA 首屏白屏、SEO 差等问题。</p>\n<p><strong>核心作用</strong>：</p>\n<ul>\n<li><strong>首屏直出</strong>：加速首屏加载，提升用户体验；</li>\n<li><strong>SEO 友好</strong>：爬虫直接抓取服务端渲染的完整内容；</li>\n<li><strong>同构开发</strong>：同一套代码在服务端和客户端执行（如 Nuxt.js 框架）。</li>\n</ul>\n<p><strong>实现原理</strong>：</p>\n<ul>\n<li>服务端通过 <code>vue-server-renderer</code> 将 Vue 实例渲染为 HTML 字符串；</li>\n<li>客户端激活（Hydration）使静态 HTML 变为可交互的 SPA。</li>\n</ul>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>需 SEO 的页面（如官网、博客）；</li>\n<li>弱网络环境下需快速呈现内容。</li>\n</ul>\n<p><strong>权衡点</strong>：</p>\n<ul>\n<li><strong>优点</strong>：优化首屏性能、支持 SEO；</li>\n<li><strong>缺点</strong>：增加服务器负载、开发复杂度较高。</li>\n</ul>\n"},{"title":"你认为组件封装的一些基本准则是什么？","answer":"<p>组件封装的一些基本准则包括：</p>\n<ol>\n<li><strong>单一职责原则</strong>：一个组件应该具有单一的功能，并且只负责完成该功能，避免组件过于庞大和复杂。</li>\n<li><strong>高内聚低耦</strong>合：组件内部的各个部分之间应该紧密相关，组件与其他组件之间应该尽量解耦，减少对外部的依赖。</li>\n<li><strong>易用性</strong>：组件应该易于使用，提供清晰的接口和文档，使用户能够方便地使用组件。</li>\n<li><strong>可扩展性</strong>：组件应该具有良好的扩展性，能够方便地添加新的功能或进行修改，同时不影响已有的功能。</li>\n<li><strong>可重用性</strong>：组件应该是可重用的，能够在多个项目中使用，减少重复开发的工作量。</li>\n<li><strong>高效性</strong>：组件应该具有高性能和低资源消耗的特点，不会成为整个系统的性能瓶颈。</li>\n<li><strong>安全性</strong>：组件应该具有安全性，能够防止恶意使用或攻击。</li>\n<li><strong>可测试性</strong>：组件应该容易进行单元测试和集成测试，以保证组件的质量和稳定性。</li>\n</ol>\n"}]