[{"title":"说说你对算法的理解，应用场景？","answer":""},{"title":"说说你对数据结构的理解？有哪些？区别？","answer":""},{"title":"什么是时间复杂度，空间复杂度？","answer":""},{"title":"什么是链表？如何实现一个简单的单链表？","answer":""},{"title":"说说你对树的理解？应用场景？","answer":""},{"title":"说说你对堆，栈，队列的理解？应用场景？","answer":""},{"title":"什么是图？","answer":""},{"title":"什么是哈希表？如何使用对象实现一个简单的哈希表？","answer":""},{"title":"如何实现深度优先搜索（DFS）和广度优先搜索（BFS）？","answer":""},{"title":"说说你对二分查找的理解？应用场景？","answer":""},{"title":"说说你对动态规划的理解？应用场景？","answer":""},{"title":"说说你对贪心算法，回溯算法的理解？应用场景？","answer":""},{"title":"冒泡排序","answer":"![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/冒泡排序.webp)\r\n\r\n```javascript\r\nfunction bubbleSort(arr){\r\n  for (let i = 0; i < arr.length - 1; i++) {\r\n    for (let j = 0; j < arr.length - i - 1; j++) {\r\n      if(arr[j]>arr[j+1]){\r\n        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]\r\n      }\r\n    }\r\n  }\r\n  return arr\r\n}\r\n```"},{"title":"选择排序","answer":"![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/选择排序.webp)\r\n\r\n```javascript\r\nfunction selectSort(arr) {\r\n  for (let i = 0; i < arr.length - 1; i++) {\r\n    let min = i\r\n    for (let j = i + 1; j < arr.length; j++) {\r\n      if (arr[j] < arr[min]) {\r\n        min = j\r\n      }\r\n    }\r\n    [arr[i], arr[min]] = [arr[min], arr[i]]\r\n  }\r\n}\r\n```"},{"title":"插入排序","answer":"![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/插入排序.webp)\r\n\r\n```javascript\r\nfunction insertSort(arr) {\r\n  // 从第 2 个元素开始遍历序列\r\n  for (let i = 1; i < arr.length; i++) {\r\n    let j = i;\r\n    //记录要插入的目标元素\r\n    let target = arr[j];\r\n    //从 target 所在位置向前遍历，直至找到一个比目标元素小的元素，目标元素插入到该元素之后的位置\r\n    while (j > 0 && arr[j - 1] > target) {\r\n      //移动前一个元素的位置，将其向后移动一个位置\r\n      arr[j] = arr[j - 1];\r\n      j--;\r\n    }\r\n    arr[j] = target;\r\n  }\r\n  return arr;\r\n}\r\n```"},{"title":"快速排序","answer":"![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/快速排序.webp)\r\n\r\n```javascript\r\nfunction quickSort(arr) {\r\n  if(arr.length <= 1) return arr\r\n  let pivot = arr[0]\r\n  let left = []\r\n  let right = []\r\n  for (let i = 1; i < arr.length; i++) {\r\n    if(arr[i] < pivot) {\r\n      left.push(arr[i])\r\n    }else {\r\n      right.push(arr[i])\r\n    }\r\n  }\r\n  return [...quickSort(left), pivot, ...quickSort(right)]\r\n}\r\n```\r\n\r\n\r\n\r\n```javascript\r\nfunction quickSort(array, start, end) {\r\n  if (start >= end) {\r\n    return;\r\n  }\r\n  let pivot = array[start];\r\n  let left = start + 1;\r\n  let right = end;\r\n  while (left < right) {\r\n    while (left < right && array[left] <= pivot) {\r\n      left++;\r\n    }\r\n    while (left < right && array[right] >= pivot) {\r\n      right--;\r\n    }\r\n    if (left < right) {\r\n      let temp = array[left];\r\n      array[left] = array[right];\r\n      array[right] = temp;\r\n    }\r\n  }\r\n  array[start] = array[right];\r\n  array[right] = pivot;\r\n  quickSort(array, start, right - 1);\r\n  quickSort(array, right + 1, end);\r\n  return array\r\n}\r\n```"},{"title":"归并排序","answer":"![](https://6c73-lsj97-9giu4cj4abdc0985-1256331827.tcb.qcloud.la/imgs/2025_04/归并排序.webp)\r\n\r\n```javascript\r\nfunction MergeSort(array) {\r\n  let len = array.length;\r\n\r\n  // 当每个子序列中仅有1个元素时返回\r\n  if (len <= 1) {\r\n    return array;\r\n  }\r\n  // 将给定的列表分为两半\r\n  let num = Math.floor(len / 2);\r\n  let left = MergeSort(array.slice(0, num));\r\n  let right = MergeSort(array.slice(num, array.length));\r\n  return merge(left, right);\r\n\r\n  function merge(left, right) {\r\n    let [l, r] = [0, 0];\r\n    let result = [];\r\n    // 从 left 和 right 区域中各个取出第一个元素，比较它们的大小\r\n    while (l < left.length && r < right.length) {\r\n      // 将较小的元素添加到result中，然后从较小元素所在的区域内取出下一个元素，继续进行比较；\r\n      if (left[l] < right[r]) {\r\n        result.push(left[l]);\r\n        l++;\r\n      } else {\r\n        result.push(right[r]);\r\n        r++;\r\n      }\r\n    }\r\n    // 如果 left 或者 right 有一方为空，则直接将另一方的所有元素依次添加到result中\r\n    result = result.concat(left.slice(l, left.length));\r\n    result = result.concat(right.slice(r, right.length));\r\n    return result;\r\n  }\r\n}\r\n```"},{"title":"反转链表","answer":"```javascript\r\nfunction reverseLinkList(head) {\r\n  let pre = null\r\n  let cur = head\r\n  while (cur) {\r\n    let next = cur.next\r\n    cur.next = pre\r\n    pre = cur\r\n    cur = next\r\n  }\r\n}\r\n\r\n```"},{"title":"K个一组翻转链表","answer":"```javascript\r\nfunction reverseKGroup(head, k) {\r\n  if(head === null||k===1) return head\r\n  let a,b\r\n  a = b = head\r\n  for (let i = 0; i < k; i++) {\r\n    if(b === null) return head\r\n    b = b.next\r\n  }\r\n  let newHead = reverse(a,b)\r\n  a.next = reverseKGroup(b,k)\r\n  function reverse(a,b){\r\n    let pre = null\r\n    let cur = a\r\n    while(cur!==b){\r\n      let next = cur.next\r\n      cur.next = pre\r\n      pre = cur\r\n      cur = next\r\n    }\r\n    return pre\r\n  }\r\n  return newHead\r\n}\r\n```"},{"title":"判断链表是否有环","answer":"```javascript\r\nfunction isRingLinkList(head) {\r\n  let fast = head\r\n  let slow = head\r\n  while (fast && fast.next) {\r\n    fast = fast.next.next\r\n    slow = slow.next\r\n    if (fast === slow) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n```"},{"title":"二叉树的遍历  ","answer":"[二叉树的遍历](https://segmentfault.com/a/1190000016226334)"},{"title":"二叉树搜索","answer":"[二叉树的搜索](http://blog.csdn.net/ZHANGYANG_1109/article/details/123686185)"},{"title":"二叉树diff算法","answer":"[二叉树diff算法](https://blog.csdn.net/qq_34388186/article/details/145052647)"},{"title":"图的最小生成树","answer":"[图的最小生成树](https://www.yisu.com/jc/169229.html)"},{"title":"斐波那契数列","answer":"```javascript\r\n//普通递归\r\nfunction fib(num) {\r\n  if (num < 2) {\r\n    return num;\r\n  }\r\n\r\n  return fib(num - 1) + fib(num - 2);\r\n}\r\n//尾递归\r\n\r\nfunction fib2(n,a = 0,b = 1) {\r\n    if(n === 0) return a;\r\n    if(n === 1 ) return b;\r\n    return fib2(n - 1, b,a+ b)\r\n}\r\n//动态规划\r\n\r\nfunction fib3(n) {\r\n    if( n === 0 || n === 1) return n\r\n    let a = 0,b = 1;\r\n    let temp = 0;\r\n    for(let i = 2; i <= n; i++) {\r\n        temp = a + b;\r\n        a = b;\r\n        b = temp\r\n    }\r\n    return temp;\r\n}\r\n\r\n```"},{"title":"青蛙跳台阶问题","answer":"```javascript\r\nfunction jumpFloor(number)\r\n{\r\n    if(number === 1){\r\n        return 1\r\n    }\r\n    if(number === 2){\r\n        return 2\r\n    }\r\n    if(number > 2){\r\n        return jumpFloor(number-1)+jumpFloor(number-2)\r\n    }\r\n}\r\n```"},{"title":"电话号码组合","answer":"```javascript\r\nfunction letterCombinations(digits) {\r\n  if (!digits) return [];\r\n\r\n  const phoneMap = {\r\n    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\r\n    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\r\n  };\r\n\r\n  const result = [];\r\n\r\n  function backtrack(combination, nextDigits) {\r\n    if (nextDigits.length === 0) {\r\n      result.push(combination);\r\n    } else {\r\n      const digit = nextDigits[0];\r\n      const letters = phoneMap[digit];\r\n      for (let i = 0; i < letters.length; i++) {\r\n        backtrack(combination + letters[i], nextDigits.slice(1));\r\n      }\r\n    }\r\n  }\r\n\r\n  backtrack('', digits);\r\n  return result;\r\n}\r\n```"},{"title":"字符串所有排列组合","answer":"```javascript\r\nfunction getPermutation(str) {\r\n  const res = []\r\n  const dfs = (path) => {\r\n    if (path.length === str.length) {\r\n      res.push(path)\r\n      return\r\n    }\r\n    for (let i = 0; i < str.length; i++) {\r\n      if (path.includes(str[i])) continue\r\n      dfs(path + str[i])\r\n    }\r\n  }\r\n  dfs('')\r\n  return res\r\n}\r\n```"},{"title":"最长回文子串","answer":"```javascript\r\nfunction longestPalindrome(s) {\r\n  if (s.length === 1) return s;\r\n  let maxRes = 0, maxStr = '';\r\n  for (let i = 0; i < s.length; i++) {\r\n    let str1 = palindrome(s, i, i);\r\n    if (str1.length > maxRes) {\r\n      maxStr = str1;\r\n      maxRes = str1.length;\r\n    }\r\n  }\r\n  function palindrome(s, l, r) {\r\n    while (l >= 0 && r < s.length && s[l] === s[r]) {\r\n      l--;\r\n      r++;\r\n    }\r\n    return s.slice(l + 1, r);\r\n  }\r\n  return maxStr;\r\n}\r\n```"},{"title":"版本号排序","answer":"```javascript\r\nfunction versionSort(arr) {\r\n  return arr.sort((a,b)=>{\r\n    const arr1 = a.split('.')\r\n    const arr2 = b.split('.')\r\n    while(arr1.length || arr2.length){\r\n      const a1 = arr1.shift()\r\n      const b1 = arr2.shift()\r\n      if(!a1)return -1\r\n      if(!b1)return 1\r\n      if(a1!==b1){\r\n        return a1 - b1\r\n      }\r\n    }\r\n  })\r\n}\r\n```"},{"title":"<span id=\"flat\">数组拍平</span>","answer":"- Array.prototype.flat(depth)\r\n\r\n```javascript\r\n  let newArray = arr.flat(Infinity)\r\n```\r\n\r\n- 迭代\r\n\r\n```javascript\r\nfunction flatten(array) {\r\n  const result = [];\r\n  const stack = [array];\r\n  while (stack.length > 0) {\r\n    const item = stack.pop();\r\n    if (Array.isArray(item)) {\r\n      for (let i = item.length - 1; i >= 0; i--) {\r\n        stack.push(item[i]);\r\n      }\r\n    } else {\r\n      result.push(item);\r\n    }\r\n  }\r\n  return result.reverse();\r\n}\r\n```\r\n\r\n- 递归\r\n\r\n```javascript\r\nfunction arrayFlat(arr) {\r\n  let result = []\r\n  arr.forEach(item => {\r\n    if (item instanceof Array) {\r\n      result = result.concat(arrayFlat(item))\r\n    } else {\r\n      result.push(item)\r\n    }\r\n  })\r\n  return result\r\n}\r\n\r\nfunction arrayFlat2(arr) {\r\n  return arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? arrayFlat2(cur) : cur), [])\r\n}\r\n```\r\n\r\n- 简单情况toString\r\n\r\n```javascript\r\nfunction arrayFlat(arr) {\r\n  return arr.toString().split(',').map(item=>parseInt(item))\r\n}\r\n```"},{"title":"有效的括号","answer":"给定一个只包括'('，')'，'{'，'}'，'['，']'的字符串s，判断字符串是否有效。\r\n\r\n```java\r\nfunction isValidBrackets(str) {\r\n  const map = new Map([['(', ')'], ['[', ']'], ['{', '}'],])\r\n  const stack = []\r\n\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (map.has(str[i])) {\r\n      stack.push(str[i])\r\n    } else if (map.get(stack[stack.length - 1]) === str[i]) {\r\n      stack.pop()\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  return stack.length === 0\r\n}\r\n```"},{"title":"最长递增子序列","answer":"在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。\r\n\r\n[最长递增子序列](https://www.bilibili.com/video/BV19M4m1X7Do/?spm_id_from=333.337.search-card.all.click&vd_source=a4e90c849b91dfcaf761cb42efd7e48c)\r\n\r\n```javascript\r\nfunction LIS(nums) {\r\n  if(nums.length === 0) return []\r\n  const results = [[nums[0]]];\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const current = nums[i];\r\n    _update(current)\r\n  }\r\n\r\n  function _update(n) {\r\n    for (let i = results.length - 1; i >= 0; i--) {\r\n      const line = results[i];\r\n      const tail = line[line.length - 1];\r\n\r\n      if (tail < n) {\r\n        results[i + 1] = [...line, n];\r\n        break\r\n      }else if (n < tail && i === 0) {\r\n        results[0] = [n]\r\n      }\r\n    }\r\n  }\r\n  return results[results.length - 1]\r\n}\r\n```"},{"title":"滑动窗口最大值","answer":"给定一个长度为n的数组和一个大小为m的滑动窗口(0<m<=n)请找出所有滑动窗口里的最大值。\r\n\r\n- 双端队列\r\n\r\n```javascript\r\nfunction maxSlidingWindow(nums, k) {\r\n  let window = [...nums.slice(0,k)]\r\n  let res = []\r\n  for (let i = k; i < nums.length; i++) {\r\n    res.push(Math.max(...window))\r\n    window.shift()\r\n    window.push(nums[i])\r\n  }\r\n  return res\r\n}\r\n```\r\n\r\n- 单调队列\r\n\r\n```javascript\r\nvar maxSlidingWindow2 = function (nums, k) {\r\n  // 边界条件\r\n  if (k > nums.length || k <= 0) return []\r\n  let deque = [], res = []\r\n  for (let i = 0; i < nums.length; i++) {\r\n    // 如果nums[i]比栈尾的数大，则弹出\r\n    while (deque.length && deque[deque.length - 1] < nums[i]) {\r\n      deque.pop()\r\n    }\r\n    // nums[i]入栈\r\n    deque.push(nums[i])\r\n    // 删除离开窗口的元素\r\n    if (deque[0] === nums[i - k]) deque.shift()\r\n    // 推入最大值\r\n    if (i >= k - 1) res.push(deque[0])\r\n  }\r\n  return res\r\n};\r\n```"},{"title":"两数之和","answer":"给定一个数组 nums 和一个目标值 target，在该数组中找出和为目标值的两个数。\r\n\r\n```javascript\r\nfunction towSum(nums, target) {\r\n  for (let i = 0; i < nums.length; i++) {\r\n    for (let j = i + 1; j < nums.length; j++) {\r\n      if (nums[i] + nums[j] === target) {\r\n        return [i, j]\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction towSum2(nums, target) {\r\n    const map = new Map();\r\n    for(let i = 0, len = nums.length; i < len; i++){\r\n        if(map.get(nums[i]) !== undefined){\r\n            return [map.get(nums[i]), i];\r\n        } else {\r\n            map.set(target - nums[i], i);\r\n        }\r\n    }\r\n    return [];\r\n};\r\n\r\n```"},{"title":"三数之和","answer":"给定一个数组nums，判断 nums 中是否存在三个元素`a，b，c`，使得 `a + b + c = target`，找出所有满足条件且不重复的三元组合。\r\n\r\n```javascript\r\nfunction findThree(arr, target) {\r\n  // 先将数组从小到大排序\r\n  arr.sort((a, b) => a - b)\r\n  let result = [];\r\n  for (let i = 0; i < arr.length - 2; i++) {\r\n    // 跳过重复的arr[i]值, 比如[2, 1, 1],跳过第二个1\r\n    if (i && arr[i] === arr[i - 1]) continue;\r\n    let left = i + 1;\r\n    let right = arr.length - 1;\r\n\r\n    // 双端指针left、right\r\n    while (left < right) {\r\n      let sum = arr[i] + arr[left] + arr[right];\r\n      if (sum > target) {\r\n        right--;\r\n      } else if (sum < target) {\r\n        left++;\r\n      } else {\r\n        // 先取arr[left]，然后left++, 两步合成一步；arr[right--]同样的逻辑\r\n        result.push([arr[i], arr[left++], arr[right--]]);\r\n        while (arr[left] === arr[left - 1]) {\r\n          // 跳过重复的arr[left]值,\r\n          left++;\r\n        }\r\n        while (arr[right] === arr[right + 1]) {\r\n          // 跳过重复的arr[right]值\r\n          right--;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n```"},{"title":"判断输入是不是回文字符串","answer":"```javascript\r\nfunction isPlalindrome(input) {\r\n  if (typeof input !== 'string') return false;\r\n  return input.split('').reverse().join('') === input;\r\n}\r\n\r\nfunction isPlalindrome2(input) {\r\n  if (typeof input !== 'string') return false;\r\n  let i = 0, j = input.length - 1\r\n  while(i < j) {\r\n      if(input.charAt(i) !== input.charAt(j)) return false\r\n      i ++\r\n      j --\r\n  }\r\n  return true\r\n}\r\n```"},{"title":"买卖股票的最佳时机","answer":"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\r\n\r\n```javascript\r\nfunction bestTimeBuyStock(prices) {\r\n  let minPrice = Infinity\r\n  let maxProfit = 0\r\n  for (let i = 0; i < prices.length; i++) {\r\n    if (prices[i] < minPrice) {\r\n      minPrice = prices[i]\r\n    } else if (prices[i] - minPrice > maxProfit) {\r\n      maxProfit = prices[i] - minPrice\r\n    }\r\n  }\r\n  return maxProfit\r\n}\r\n```\r\n\r\n其他版本买股票问题：[买卖股票的最佳时机](https://zhuanlan.zhihu.com/p/136811810)"},{"title":"计算多个数组的交集","answer":"```javascript\r\nconst getIntersection = (...arrs) => {\r\n  return arrs.reduce((pre, cur) => {\r\n    return cur.filter(item => pre.includes(item));\r\n  })\r\n}\r\n```"},{"title":"背包问题","answer":"- 贪心算法（物品可分割）\r\n\r\n假设一个背包可以装 100 kg 物品，我们有如下 5 种豆子，每种豆子的总量和总价值各不相同，为了让背包中所装的物品总价值最大，我们如何选择在背包中装哪些豆子，每种豆子该装多少？\r\n\r\n| 物品 | 总量（kg） | 总价值（元） |\r\n| ---- | ---------- | ------------ |\r\n| 黄豆 | 100        | 100          |\r\n| 绿豆 | 30         | 90           |\r\n| 红豆 | 60         | 120          |\r\n| 黑豆 | 20         | 80           |\r\n| 青豆 | 50         | 75           |\r\n\r\n先对物品进行价值排序，先装价值高的，装到不能装为止。\r\n\r\n```javascript\r\nfunction knapsack(max, goods) {\r\n  const arr = goods.map(item => {\r\n    item.value = item.price / item.weight\r\n    return item\r\n  })\r\n  let total = 0\r\n  let rest = max\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (rest >= arr[i].weight) {\r\n      total += arr[i].price\r\n      rest -= arr[i].weight\r\n    }else {\r\n      total += arr[i].value * rest\r\n      break\r\n    }\r\n  }\r\n  return total\r\n}\r\n```\r\n\r\n- 动态规划\r\n\r\n  [实现动态规划01背包问题](https://blog.csdn.net/qq_38951259/article/details/129386435)\r\n\r\n  [01背包问题算法动画讲解](https://www.bilibili.com/video/BV1pY4y1J7na/?spm_id_from=333.337.search-card.all.click&vd_source=a4e90c849b91dfcaf761cb42efd7e48c)"},{"title":"N皇后问题","answer":"[N 皇后经典算法解析](https://juejin.cn/post/6967155502820098085)"},{"title":"数组去重","answer":"```javascript\r\nfunction arrayDeduplication(arr) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = i + 1; j < arr.length; j++) {\r\n      if (arr[i] === arr[j]) { \r\n        arr.splice(j, 1)\r\n        j--\r\n      }\r\n    }\r\n  }\r\n  return arr\r\n}\r\n```"},{"title":"列表转树","answer":"```javascript\r\nfunction listToTree(list) {\r\n  list.forEach(item=>{\r\n    item.children = []\r\n    list.forEach(item2=>{\r\n      if(item2.parentId === item.id){\r\n        item.children.push(item2)\r\n      }\r\n    })\r\n  })\r\n  list = list.filter(item=>item.parentId === 0)\r\n}\r\n```"}]