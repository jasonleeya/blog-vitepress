[{"title":"实现交换两个变量","answer":"JavaScript交换两个变量的常用方法：\r\n\r\n1. **临时变量法**（通用性强，推荐）：\r\n\r\n   ```javascript\r\n   let a = 1, b = 2;  \r\n   let temp = a;  \r\n   a = b;  \r\n   b = temp;  \r\n   console.log(a, b); // 输出 2 1  \r\n   ```\r\n\r\n2. **解构赋值法**（ES6+，简洁）：\r\n\r\n   ```javascript\r\n   [a, b] = [b, a]; // 直接交换  \r\n   ```\r\n\r\n3. **数学运算法**（仅限数值类型）：\r\n\r\n   ```javascript\r\n   a = a + b;  \r\n   b = a - b;  \r\n   a = a - b;  \r\n   ```\r\n\r\n4. **位运算异或法**（仅限整数）：\r\n\r\n   ```javascript\r\n   a = a ^ b;  \r\n   b = a ^ b;  \r\n   a = a ^ b; \r\n   ```"},{"title":"简单实现Promise","answer":"```javascript\r\nclass MyPromise {\r\n  constructor(executor) {\r\n    this.state = 'pending'; // 状态：pending/fulfilled/rejected\r\n    this.value = undefined; // 成功值\r\n    this.reason = undefined; // 失败原因\r\n    this.onFulfilledCallbacks = []; // 成功回调队列\r\n    this.onRejectedCallbacks = []; // 失败回调队列\r\n\r\n    const resolve = (value) => {\r\n      if (this.state === 'pending') {\r\n        this.state = 'fulfilled';\r\n        this.value = value;\r\n        this.onFulfilledCallbacks.forEach(fn => fn()); // 执行异步回调\r\n      }\r\n    };\r\n\r\n    const reject = (reason) => {\r\n      if (this.state === 'pending') {\r\n        this.state = 'rejected';\r\n        this.reason = reason;\r\n        this.onRejectedCallbacks.forEach(fn => fn()); // 执行异步回调\r\n      }\r\n    };\r\n\r\n    try {\r\n      executor(resolve, reject); // 立即执行执行器函数\r\n    } catch (err) {\r\n      reject(err); // 捕获同步错误\r\n    }\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    // 处理值穿透（then() 无参数时传递值）\r\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\r\n    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err; };\r\n\r\n    const promise2 = new MyPromise((resolve, reject) => {\r\n      const handleFulfilled = () => {\r\n        setTimeout(() => { // 确保异步执行\r\n          try {\r\n            const x = onFulfilled(this.value);\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (err) {\r\n            reject(err);\r\n          }\r\n        }, 0);\r\n      };\r\n\r\n      const handleRejected = () => {\r\n        setTimeout(() => {\r\n          try {\r\n            const x = onRejected(this.reason);\r\n            resolvePromise(promise2, x, resolve, reject);\r\n          } catch (err) {\r\n            reject(err);\r\n          }\r\n        }, 0);\r\n      };\r\n\r\n      if (this.state === 'fulfilled') {\r\n        handleFulfilled();\r\n      } else if (this.state === 'rejected') {\r\n        handleRejected();\r\n      } else { // pending 状态时存储回调\r\n        this.onFulfilledCallbacks.push(handleFulfilled);\r\n        this.onRejectedCallbacks.push(handleRejected);\r\n      }\r\n    });\r\n\r\n    return promise2; // 返回新 Promise 实现链式调用\r\n  }\r\n}\r\n\r\n// 处理 then 返回值的解析（支持返回 Promise 或普通值）\r\nfunction resolvePromise(promise2, x, resolve, reject) {\r\n  if (promise2 === x) { // 禁止循环引用\r\n    return reject(new TypeError('Chaining cycle detected'));\r\n  }\r\n  if (x instanceof MyPromise) { // 递归解析 Promise\r\n    x.then(resolve, reject);\r\n  } else {\r\n    resolve(x);\r\n  }\r\n}\r\n```"},{"title":"如何用Promise实现超时控制？","answer":"**1. 基础实现：超时抛出错误**\r\n\r\n```javascript\r\nfunction timeoutPromise(promise, timeout) {  \r\n  // 创建超时 Promise，到达时间后 reject  \r\n  const timeoutP = new Promise((_, reject) => {  \r\n    setTimeout(() => reject(new Error('请求超时')), timeout);  \r\n  });  \r\n\r\n  // 返回竞速结果  \r\n  return Promise.race([promise, timeoutP]);  \r\n}  \r\n\r\n// 使用示例  \r\nconst fetchData = fetch('https://api.example.com');  \r\ntimeoutPromise(fetchData, 5000)  \r\n  .then(res => console.log('成功:', res))  \r\n  .catch(err => console.error('失败:', err));  \r\n```\r\n\r\n**2. 结合 AbortController 取消实际请求（如 fetch）**\r\n\r\n```javascript\r\nfunction fetchWithTimeout(url, timeout = 5000) {  \r\n  const controller = new AbortController();  \r\n  const timeoutId = setTimeout(() => controller.abort(), timeout);  \r\n\r\n  return fetch(url, { signal: controller.signal })  \r\n    .finally(() => clearTimeout(timeoutId)); // 清理定时器  \r\n}  \r\n\r\n// 使用：超时后自动取消请求  \r\nfetchWithTimeout('https://api.example.com', 3000)  \r\n  .catch(err => {  \r\n    if (err.name === 'AbortError') console.log('请求超时');  \r\n    else console.error('其他错误:', err);  \r\n  });  \r\n```"},{"title":"手写代码实现Promise.all","answer":"手写 `Promise.all` 的核心在于**并发执行所有Promise**，并**按顺序收集结果**，遇到失败立即终止。以下是实现代码及解析：\r\n\r\n```javascript\r\nfunction myPromiseAll(promises) {  \r\n  return new Promise((resolve, reject) => {  \r\n    // 1. 校验输入是否为可迭代对象  \r\n    if (typeof promises?.[Symbol.iterator] !== 'function') {  \r\n      return reject(new TypeError('Argument is not iterable'));  \r\n    }  \r\n    const results = [];  \r\n    let count = 0;  \r\n    // 2. 处理空数组直接返回  \r\n    if (promises.length === 0) return resolve(results);  \r\n\r\n    promises.forEach((item, index) => {  \r\n      // 3. 统一转Promise处理非Promise值  \r\n      Promise.resolve(item)  \r\n        .then((value) => {  \r\n          results[index] = value; // 按索引存储结果  \r\n          if (++count === promises.length) resolve(results);  \r\n        })  \r\n        .catch(reject); // 4. 任意失败立即reject  \r\n    });  \r\n  });  \r\n}  \r\n```\r\n\r\n**关键点解释**：\r\n\r\n- **输入校验**：通过 `Symbol.iterator` 判断是否可迭代（如数组、Set）。\r\n- **结果顺序**：利用闭包中的 `index` 确保结果顺序与输入一致。\r\n- **并发执行**：`forEach` 立即启动所有Promise，无需等待前一个完成。\r\n- **错误处理**：首个失败直接触发 `reject`，其他Promise继续执行但不处理结果。\r\n\r\n**测试用例**：\r\n\r\n```javascript\r\n// 成功场景  \r\nmyPromiseAll([1, Promise.resolve(2), Promise.resolve(3)])  \r\n  .then(console.log); // 输出 [1, 2, 3]  \r\n\r\n// 失败场景  \r\nmyPromiseAll([Promise.reject('error'), Promise.resolve(2)])  \r\n  .catch(console.log); // 输出 'error'  \r\n```\r\n\r\n**与原生的差异**：\r\n\r\n- **行为一致**：所有Promise立即执行，无法取消。\r\n- **边界处理**：对非Promise值的转换（`Promise.resolve`）逻辑相同。"},{"title":"手写代码实现Promise.race","answer":"手写 `Promise.race` 的核心在于**监听所有Promise，首个完成（无论成功/失败）的结果决定最终状态**。以下是实现代码及解析：\r\n\r\n```javascript\r\nfunction myPromiseRace(promises) {  \r\n  return new Promise((resolve, reject) => {  \r\n    // 1. 校验输入是否为可迭代对象  \r\n    if (typeof promises?.[Symbol.iterator] !== 'function') {  \r\n      return reject(new TypeError('Argument is not iterable'));  \r\n    }  \r\n    // 2. 遍历每个Promise，监听首个结果  \r\n    for (const item of promises) {  \r\n      // 3. 统一转Promise处理非Promise值  \r\n      Promise.resolve(item)  \r\n        .then(resolve)  // 首个resolve触发外层成功  \r\n        .catch(reject); // 首个reject触发外层失败  \r\n    }  \r\n  });  \r\n}  \r\n```\r\n\r\n**关键点解释**：\r\n\r\n- **立即执行**：所有Promise同时启动，竞争执行。\r\n- **首个完成优先**：无论是成功（`resolve`）还是失败（`reject`），首个完成的Promise直接决定最终状态。\r\n- **非Promise处理**：通过 `Promise.resolve` 包装确保统一处理（如数值、普通对象）。\r\n\r\n**测试用例**：\r\n\r\n```javascript\r\n// 成功场景（首个为数值）  \r\nmyPromiseRace([1, new Promise(res => setTimeout(res, 100, 2))])  \r\n  .then(console.log); // 输出 1  \r\n\r\n// 失败场景  \r\nmyPromiseRace([  \r\n  new Promise((_, rej) => setTimeout(rej, 50, 'error1')),  \r\n  new Promise((_, rej) => setTimeout(rej, 10, 'error2'))  \r\n]).catch(console.log); // 输出 'error2'（更快完成）  \r\n\r\n// 混合类型  \r\nmyPromiseRace([Promise.resolve('fast'), 42])  \r\n  .then(console.log); // 输出 'fast'  \r\n```\r\n\r\n**与原生的差异**：\r\n\r\n- **行为一致**：所有Promise立即执行且不可取消。\r\n- **边界处理**：空输入直接返回 `pending` 状态的Promise（需调用方自行处理）。\r\n\r\n**适用场景**：\r\n\r\n- 接口超时控制（如与 `setTimeout` 结合）\r\n- 竞速请求（取最快响应结果）"},{"title":"手写代码实现Promise.allSettled","answer":"以下是 `Promise.allSettled` 的手动实现，核心思路是 **收集所有 Promise 的结果（无论成功/失败）**，并在全部完成后返回结果数组：\r\n\r\n```javascript\r\nfunction promiseAllSettled(promises) {\r\n  return new Promise((resolve) => {\r\n    // 空数组直接返回\r\n    if (promises.length === 0) {\r\n      resolve([]);\r\n      return;\r\n    }\r\n\r\n    const results = new Array(promises.length); // 结果数组，保持顺序\r\n    let completed = 0; // 完成计数器\r\n\r\n    promises.forEach((promise, index) => {\r\n      // 处理非 Promise 值（如数字、普通对象）\r\n      Promise.resolve(promise)\r\n        .then(value => {\r\n          results[index] = { status: 'fulfilled', value };\r\n        })\r\n        .catch(reason => {\r\n          results[index] = { status: 'rejected', reason };\r\n        })\r\n        .finally(() => {\r\n          completed++;\r\n          // 全部完成时 resolve\r\n          if (completed === promises.length) {\r\n            resolve(results);\r\n          }\r\n        });\r\n    });\r\n  });\r\n}\r\n```\r\n\r\n**实现解析**\r\n\r\n1. **统一处理输入**：\r\n   - 使用 `Promise.resolve()` 包装每个元素，确保处理的是 Promise 对象。\r\n   - 支持混合类型输入（如 `[42, fetch('/data')]`）。\r\n2. **保持结果顺序**：\r\n   - 通过 `index` 将结果存入数组对应位置，与输入顺序一致。\r\n3. **完成计数器**：\r\n   - 每个 Promise 完成后（无论成功/失败）触发 `finally`，计数器累加。\r\n   - 当计数器等于输入数组长度时，返回最终结果。"},{"title":"使用Promise实现一个限制并发数的函数","answer":"```javascript\r\nfunction limitConcurrency(tasks, max) {  \r\n  return new Promise(resolve => {  \r\n    let index = 0, active = 0, completed = 0;  \r\n    const results = [];  \r\n\r\n    function next() {  \r\n      // 所有任务完成  \r\n      if (completed === tasks.length) return resolve(results);  \r\n\r\n      // 启动新任务（不超过最大并发数）  \r\n      while (active < max && index < tasks.length) {  \r\n        const current = index++;  \r\n        active++;  \r\n        const task = tasks[current];  \r\n        Promise.resolve(task())  \r\n          .then(res => results[current] = res)  \r\n          .catch(err => results[current] = err)  \r\n          .finally(() => {  \r\n            active--;  \r\n            completed++;  \r\n            next(); // 触发下一个任务  \r\n          });  \r\n      }  \r\n    }  \r\n\r\n    next(); // 初始调用  \r\n  });  \r\n} \r\n```"},{"title":"async/await 原理， 手写 async 函数？","answer":"**一、核心原理**\r\n\r\n1. **生成器函数（Generator）**：\r\n   `async` 函数被转换为生成器函数，`await` 对应 `yield`，用于暂停执行。\r\n2. **自动执行器**：\r\n   递归调用生成器的 `next()`，自动处理 `yield` 返回的 `Promise`，实现异步流程控制。\r\n\r\n**二、手写 `async` 函数实现**\r\n\r\n```javascript\r\nfunction myAsync(generatorFn) {\r\n  return function (...args) {\r\n    const gen = generatorFn.apply(this, args); // 初始化生成器\r\n\r\n    // 返回Promise，支持链式调用\r\n    return new Promise((resolve, reject) => {\r\n      // 递归处理生成器的 yield\r\n      function step(key, arg) {\r\n        let result;\r\n        try {\r\n          result = gen[key](arg); // 执行 next 或 throw\r\n        } catch (error) {\r\n          return reject(error); // 捕获同步错误\r\n        }\r\n\r\n        const { value, done } = result;\r\n        if (done) {\r\n          return resolve(value); // 生成器执行完毕，返回最终结果\r\n        } else {\r\n          // 统一转为Promise处理（支持非Promise值）\r\n          return Promise.resolve(value).then(\r\n            val => step(\"next\", val), // 异步成功，继续下一步\r\n            err => step(\"throw\", err) // 异步失败，抛出错误\r\n          );\r\n        }\r\n      }\r\n\r\n      step(\"next\"); // 启动执行\r\n    });\r\n  };\r\n}\r\n```\r\n\r\n**三、使用示例**\r\n\r\n```javascript\r\n// 定义生成器函数（模拟 async 函数）\r\nconst asyncFunc = myAsync(function* () {\r\n  try {\r\n    const data1 = yield fetchData1(); // 模拟 await\r\n    const data2 = yield fetchData2(data1);\r\n    return data2;\r\n  } catch (error) {\r\n    console.log(\"捕获错误:\", error);\r\n  }\r\n});\r\n\r\n// 执行手写的 async 函数\r\nasyncFunc().then(result => console.log(\"结果:\", result));\r\n```\r\n\r\n**四、原理解析**\r\n\r\n1. **生成器控制流程**：\r\n   - `yield` 暂停执行，返回 `Promise`。\r\n   - `next()` 恢复执行，并传入异步结果。\r\n2. **错误处理**：\r\n   - 通过 `try/catch` 包裹生成器方法调用，捕获同步错误。\r\n   - 异步错误通过 `Promise.catch` 触发生成器的 `throw` 方法。\r\n3. **自动递归**：\r\n   - `step` 函数递归调用自身，直到生成器完成（`done: true`）"},{"title":"实现深拷贝","answer":"[深拷贝浅拷贝的区别？如何实现一个深拷贝？](#deepClone)"},{"title":"实现防抖节流","answer":"[什么是防抖和节流？有什么区别？如何实现？](#throttled-and-debounce)"},{"title":"实现数组去重","answer":"[你知道哪些数组去重方法？](#uniqueArray)"},{"title":"手写发布-订阅模式","answer":"```javascript\r\nclass EventEmitter {  \r\n  constructor() {  \r\n    this.events = {}; // 存储事件及回调 { event: [callback1, callback2] }  \r\n  }  \r\n\r\n  // 订阅事件  \r\n  on(event, listener) {  \r\n    if (!this.events[event]) this.events[event] = [];  \r\n    this.events[event].push(listener);  \r\n    // 返回取消订阅的函数  \r\n    return () => this.off(event, listener);  \r\n  }  \r\n\r\n  // 取消订阅  \r\n  off(event, listener) {  \r\n    if (!this.events[event]) return;  \r\n    const index = this.events[event].indexOf(listener);  \r\n    if (index > -1) this.events[event].splice(index, 1);  \r\n  }  \r\n\r\n  // 触发事件  \r\n  emit(event, ...args) {  \r\n    if (!this.events[event]) return;  \r\n    // 复制数组，避免回调中修改数组导致遍历错乱  \r\n    this.events[event].slice().forEach(listener => listener(...args));  \r\n  }  \r\n\r\n  // 单次订阅  \r\n  once(event, listener) {  \r\n    const onceWrapper = (...args) => {  \r\n      listener(...args);  \r\n      this.off(event, onceWrapper); // 执行后自动移除  \r\n    };  \r\n    this.on(event, onceWrapper);  \r\n  }  \r\n} \r\n```\r\n\r\n使用：\r\n\r\n```javascript\r\nconst emitter = new EventEmitter();  \r\n\r\n// 订阅  \r\nconst unsub = emitter.on('message', (msg) => console.log('收到消息：', msg));  \r\nemitter.emit('message', 'Hello!'); // 输出：收到消息：Hello!  \r\n\r\n// 取消订阅  \r\nunsub();  \r\nemitter.emit('message', '不再接收'); // 无输出  \r\n\r\n// 单次订阅  \r\nemitter.once('alert', () => console.log('仅触发一次'));  \r\nemitter.emit('alert'); // 输出：仅触发一次  \r\nemitter.emit('alert'); // 无输出  \r\n```"},{"title":"手写观察者模式","answer":"```javascript\r\n// 主题（被观察者）  \r\nclass Subject {  \r\n  constructor() {  \r\n    this.observers = []; // 观察者列表  \r\n  }  \r\n\r\n  // 添加观察者  \r\n  addObserver(observer) {  \r\n    if (observer && typeof observer.update === 'function') {  \r\n      this.observers.push(observer);  \r\n    }  \r\n  }  \r\n\r\n  // 移除观察者  \r\n  removeObserver(observer) {  \r\n    const index = this.observers.indexOf(observer);  \r\n    if (index > -1) this.observers.splice(index, 1);  \r\n  }  \r\n\r\n  // 通知所有观察者  \r\n  notify(data) {  \r\n    this.observers.forEach(observer => observer.update(data));  \r\n  }  \r\n}  \r\n\r\n// 观察者  \r\nclass Observer {  \r\n  constructor(name) {  \r\n    this.name = name;  \r\n  }  \r\n\r\n  // 定义统一的更新接口  \r\n  update(data) {  \r\n    console.log(`${this.name} 收到数据：`, data);  \r\n  }  \r\n}  \r\n```\r\n\r\n使用：\r\n\r\n```javascript\r\n// 创建主题  \r\nconst subject = new Subject();  \r\n\r\n// 创建观察者  \r\nconst observerA = new Observer('观察者A');  \r\nconst observerB = {  \r\n  update: (data) => console.log('观察者B收到：', data)  \r\n};  \r\n\r\n// 添加观察者  \r\nsubject.addObserver(observerA);  \r\nsubject.addObserver(observerB);  \r\n\r\n// 主题状态变化，触发通知  \r\nsubject.notify({ message: '状态更新' });  \r\n// 输出：  \r\n// 观察者A 收到数据： {message: '状态更新'}  \r\n// 观察者B收到： {message: '状态更新'}  \r\n\r\n// 移除观察者  \r\nsubject.removeObserver(observerB);  \r\nsubject.notify('第二次通知'); // 仅observerA接收  \r\n```"},{"title":"实现一个 flatten 函数（数组扁平化）","answer":"[数组拍平](#flat)"},{"title":"如何实现数组的随机排序？","answer":"**方法 1：Fisher-Yates 洗牌算法**\r\n\r\n```javascript\r\nfunction shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1)); // 随机选取 0~i 的索引\r\n    [array[i], array[j]] = [array[j], array[i]];    // 交换元素\r\n  }\r\n  return array;\r\n}\r\n```\r\n\r\n**优点**：\r\n\r\n- **均匀随机**：每个元素出现在每个位置的概率均等。\r\n- **时间复杂度 O(n)**：高效，只需一次遍历。\r\n\r\n**方法 2：Array.sort + Math.random（不推荐）**\r\n\r\n```javascript\r\nconst shuffled = array.sort(() => Math.random() - 0.5);\r\n```\r\n\r\n**缺点**：\r\n\r\n- **非均匀随机**：V8引擎的排序算法导致元素位置概率不均（如末尾元素更可能留在末尾）。\r\n- **时间复杂度 O(n log n)**：性能较差。"},{"title":"实现获取文件扩展名","answer":"**方法1：split + pop（适合简单场景）**\r\n\r\n```javascript\r\nfunction getExtension(filename) {  \r\n  // 处理无点或隐藏文件（如.gitignore）  \r\n  const parts = filename.split('.');  \r\n  return parts.length > 1 ? parts.pop() : '';  \r\n}  \r\n\r\n// 示例  \r\nconsole.log(getExtension('image.jpg'));      // 'jpg'  \r\nconsole.log(getExtension('archive.tar.gz')); // 'gz'  \r\nconsole.log(getExtension('README'));         // ''  \r\nconsole.log(getExtension('.env'));           // ''  \r\n```\r\n\r\n**方法2：正则表达式（精准高效）**\r\n\r\n```javascript\r\nfunction getExtension(filename) {  \r\n  // 匹配最后一个点后的非点字符（直到字符串末尾）  \r\n  const match = filename.match(/\\.([^.]+)$/);  \r\n  return match ? match[1] : '';  \r\n}  \r\n\r\n// 示例  \r\nconsole.log(getExtension('file.min.js'));    // 'js'  \r\nconsole.log(getExtension('image.JPEG'));     // 'JPEG'  \r\nconsole.log(getExtension('no_extension'));   // ''  \r\n```"},{"title":"为什么使用 setTimeout 实现 setInterval？怎么模拟？","answer":"**一、为什么用 `setTimeout` 替代 `setInterval`？**\r\n\r\n1. **避免回调堆积**：\r\n   - `setInterval` 会严格按间隔时间触发回调，若回调未完成，任务会堆积。\r\n   - `setTimeout` 递归调用可确保下次回调在上次执行**完成后**再触发。\r\n2. **动态调整间隔**：\r\n   - 每次递归前可动态修改间隔（如网络请求失败时增加延迟）。\r\n3. **精准控制启停**：\r\n   - 通过闭包保存 `timer`，实现精准的取消逻辑。\r\n\r\n**二、代码实现**\r\n\r\n```javascript\r\nfunction customInterval(callback, interval) {\r\n  let timer = null;\r\n  \r\n  function execute() {\r\n    callback();            // 执行回调\r\n    timer = setTimeout(execute, interval); // 递归调用\r\n  }\r\n  \r\n  timer = setTimeout(execute, interval);   // 首次触发\r\n  return () => clearTimeout(timer);        // 返回清除函数\r\n}\r\n\r\n// 使用示例\r\nconst clear = customInterval(() => {\r\n  console.log('执行任务');\r\n}, 1000);\r\n\r\n// 5秒后停止\r\nsetTimeout(() => clear(), 5000);\r\n```"},{"title":"手写一个函数将 12345 格式化为货币形式（如 \"12,345\"）","answer":"**反向遍历法（手写循环）**\r\n\r\n**原理**：从右往左每3位插入逗号\r\n\r\n```javascript\r\nfunction formatCurrency(num) {\r\n  const str = num.toString();\r\n  const [integerPart, decimalPart] = str.split('.');\r\n  const decimal = decimalPart ? `.${decimalPart}` : ''; // 处理小数部分\r\n  let sign = '';\r\n  let integer = integerPart;\r\n\r\n  // 处理负号\r\n  if (integer.startsWith('-')) {\r\n    sign = '-';\r\n    integer = integer.slice(1);\r\n  }\r\n\r\n  let result = '';\r\n  let count = 0;\r\n\r\n  // 从右往左遍历整数部分，每三位插入逗号\r\n  for (let i = integer.length - 1; i >= 0; i--) {\r\n    result = integer[i] + result;\r\n    count++;\r\n    if (count % 3 === 0 && i !== 0) { // 避免在最左侧加逗号\r\n      result = ',' + result;\r\n    }\r\n  }\r\n\r\n  return sign + result + decimal;\r\n}\r\n\r\n// 测试用例\r\nconsole.log(formatCurrency(12345));        // 输出 \"12,345\"\r\nconsole.log(formatCurrency(123456789));    // 输出 \"123,456,789\"\r\nconsole.log(formatCurrency(-12345.67));    // 输出 \"-12,345.67\"\r\nconsole.log(formatCurrency(123));          // 输出 \"123\"\r\n```\r\n\r\n**正则表达式法（代码极简）**\r\n\r\n**原理**：用正则匹配每三位数字前的位置\r\n\r\n```javascript\r\nfunction formatCurrency(num) {  \r\n  return num.toString().replace(/-?\\d+/g, m =>   \r\n    m.replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,')  \r\n  );  \r\n}  \r\n// 示例：12345 → \"12,345\"，-123456 → \"-123,456\"  \r\n```\r\n\r\n**数组分割法（直观易懂）**\r\n\r\n**原理**：将数字转为数组后反向插入逗号\r\n\r\n```javascript\r\nfunction formatCurrency(num) {  \r\n  const str = Math.abs(num).toString().split('.');  \r\n  const arr = str[0].split('').reverse();  \r\n  for (let i = 3; i < arr.length; i += 4) {  \r\n    arr.splice(i, 0, ',');  \r\n  }  \r\n  return (num < 0 ? '-' : '') +  \r\n    arr.reverse().join('') +  \r\n    (str[1] ? `.${str[1]}` : '');  \r\n}  \r\n```\r\n\r\n**原生API法（生产推荐）**\r\n\r\n**原理**：利用 `toLocaleString` 内置方法实现一个函数，将 hello-world 转换为驼峰命名（helloWorld）\r\n\r\n```javascript\r\nfunction formatCurrency(num) {  \r\n  return num.toLocaleString('en-US');  \r\n}  \r\n// 示例：12345 → \"12,345\"，12345.67 → \"12,345.67\"  \r\n```"},{"title":"如何实现一个无限累加的 add 函数？","answer":"```javascript\r\nfunction add(n) {\r\n  let sum = n;\r\n  const fn = (m) => { sum += m; return fn; };\r\n  fn.valueOf = () => sum;\r\n  return fn;\r\n}\r\nadd(1)(2)(3); // 输出 6\r\nadd(1)(2)(3)(4); // 输出 10\r\n```"},{"title":"实现链式调用：设计一个对象支持 obj.add(1).subtract(2).getValue()","answer":"要实现链式调用，需确保每个方法返回对象本身（`this`），从而允许连续调用其他方法。以下是具体实现：\r\n\r\n```javascript\r\nclass Calculator {\r\n  constructor(initialValue = 0) {\r\n    this.value = initialValue;\r\n  }\r\n\r\n  add(num) {\r\n    this.value += num;\r\n    return this; // 关键：返回实例以支持链式调用\r\n  }\r\n\r\n  subtract(num) {\r\n    this.value -= num;\r\n    return this;\r\n  }\r\n\r\n  getValue() {\r\n    return this.value; // 终止链式调用，返回最终结果\r\n  }\r\n}\r\n\r\n// 使用示例\r\nconst result = new Calculator()\r\n  .add(1)    // 0 + 1 = 1\r\n  .subtract(2) // 1 - 2 = -1\r\n  .getValue(); // 返回 -1\r\n\r\nconsole.log(result); // 输出: -1\r\n```"},{"title":"Vue项目中有封装过axios吗？怎么封装的？","answer":"**（1）创建Axios实例**\r\n\r\n```js\r\n// src/utils/request.js  \r\nimport axios from 'axios';  \r\n\r\nconst service = axios.create({  \r\n  baseURL: process.env.VUE_APP_API_URL, // 环境变量配置  \r\n  timeout: 10000  \r\n});  \r\n```\r\n\r\n**（2）请求拦截器**\r\n\r\n```js\r\nservice.interceptors.request.use(  \r\n  config => {  \r\n    // 添加Token、Content-Type等  \r\n    config.headers.Authorization = localStorage.getItem('token');  \r\n    return config;  \r\n  },  \r\n  error => Promise.reject(error)  \r\n);  \r\n```\r\n\r\n**（3）响应拦截器**\r\n\r\n```js\r\nservice.interceptors.response.use(  \r\n  response => {  \r\n    // 统一处理业务逻辑（如状态码判断）  \r\n    const res = response.data;  \r\n    if (res.code !== 200) {  \r\n      alert(res.message);  \r\n      return Promise.reject(res);  \r\n    }  \r\n    return res;  \r\n  },  \r\n  error => {  \r\n    // 处理HTTP错误（如401跳登录）  \r\n    if (error.response.status === 401) {  \r\n      router.push('/login');  \r\n    }  \r\n    return Promise.reject(error);  \r\n  }  \r\n);  \r\n```\r\n\r\n**（4）封装请求方法**\r\n\r\n```js\r\nexport const get = (url, params) => service.get(url, { params });  \r\nexport const post = (url, data) => service.post(url, data);  \r\n// 导出其他方法（put、delete等）  \r\n```\r\n\r\n**3. 使用示例**\r\n\r\n```js\r\n// 组件中调用  \r\nimport { get, post } from '@/utils/request';  \r\n\r\nget('/user', { id: 1 }).then(data => { ... });  \r\npost('/login', { username, password }).then(...);  \r\n```"},{"title":"Vue3封装一个带缓存的 useFetch Hook（支持重复请求去重）","answer":"```javascript\r\nimport { ref, reactive } from 'vue';\r\n\r\ntype CacheItem = {\r\n  data: any;\r\n  timestamp: number;\r\n};\r\n\r\ntype Options = {\r\n  cacheTTL?: number; // 缓存有效时间（毫秒）\r\n  immediate?: boolean; // 是否立即执行\r\n};\r\n\r\nconst cache = reactive(new Map<string, CacheItem>());\r\nconst pendingRequests = new Map<string, Promise<any>>();\r\n\r\nexport function useFetch<T>(url: string, options: Options = {}) {\r\n  const data = ref<T | null>(null);\r\n  const error = ref<Error | null>(null);\r\n  const loading = ref(false);\r\n  const { cacheTTL = 60000, immediate = true } = options;\r\n\r\n  // 生成唯一缓存键（可根据需求扩展参数哈希）\r\n  const cacheKey = url; \r\n\r\n  // 核心请求方法\r\n  const execute = async () => {\r\n    // 重复请求去重逻辑\r\n    if (pendingRequests.has(cacheKey)) {\r\n      return pendingRequests.get(cacheKey);\r\n    }\r\n\r\n    // 缓存有效直接返回\r\n    if (cache.has(cacheKey)) {\r\n      const cached = cache.get(cacheKey)!;\r\n      if (Date.now() - cached.timestamp < cacheTTL) {\r\n        data.value = cached.data;\r\n        return cached.data;\r\n      }\r\n    }\r\n\r\n    try {\r\n      loading.value = true;\r\n      const request = fetch(url)\r\n        .then(res => res.json())\r\n        .then(res => {\r\n          // 更新缓存\r\n          cache.set(cacheKey, { \r\n            data: res, \r\n            timestamp: Date.now() \r\n          });\r\n          data.value = res;\r\n          return res;\r\n        })\r\n        .finally(() => {\r\n          pendingRequests.delete(cacheKey);\r\n          loading.value = false;\r\n        });\r\n\r\n      pendingRequests.set(cacheKey, request);\r\n      return await request;\r\n    } catch (err) {\r\n      error.value = err as Error;\r\n      cache.delete(cacheKey); // 失败时清除缓存\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  // 立即执行\r\n  if (immediate) execute();\r\n\r\n  // 手动清除缓存方法\r\n  const clearCache = () => cache.delete(cacheKey);\r\n\r\n  return { data, error, loading, execute, clearCache };\r\n}\r\n```\r\n\r\n使用：\r\n\r\n```vue\r\n<script setup>\r\nimport { useFetch } from './useFetch';\r\n\r\nconst { data, loading } = useFetch('/api/user', { \r\n  cacheTTL: 300000 // 缓存5分钟\r\n});\r\n\r\n// 手动触发请求（自动去重）\r\nconst refresh = () => execute();\r\n</script>\r\n```\r\n\r\n**核心设计要点：**\r\n\r\n1. **双重缓存策略**\r\n   - **内存缓存**：`Map`存储已成功请求的数据\r\n   - **请求中缓存**：`pendingRequests`避免重复发送相同请求\r\n2. **自动缓存失效**\r\n   通过`cacheTTL`控制缓存有效期，超时后自动重新请求\r\n3. **智能去重机制**\r\n   - 相同URL同时触发多次请求时，仅实际发送一次\r\n   - 后续请求共享同一Promise结果\r\n4. **灵活扩展点**\r\n   - 可扩展`cacheKey`生成逻辑（如包含请求参数）\r\n   - 可添加请求取消功能（结合`AbortController`）"},{"title":"实现一个JS 函数， 解析 url 参数， 返回一个对象","answer":"**方案 1：纯字符串分割（基础版**）\r\n\r\n```javascript\r\nfunction parseUrlParams(url) {\r\n  const params = {};\r\n  const query = url.split('?')[1] || '';\r\n  query.split('&').forEach(pair => {\r\n    const [key, val] = pair.split('=');\r\n    if (key) {\r\n      params[decodeURIComponent(key)] = decodeURIComponent(val || '');\r\n    }\r\n  });\r\n  return params;\r\n}\r\n// 示例：'?name=John&age=30' → { name: 'John', age: '30' }\r\n```\r\n\r\n**优点**：代码简单，兼容性好\r\n**缺点**：未处理数组参数（如 `?key=1&key=2`）\r\n\r\n\r\n\r\n**方案 2：正则表达式（支持数组参数）**\r\n\r\n```javascript\r\nfunction parseUrlParams(url) {\r\n  const params = {};\r\n  url.replace(/[?&]([^=&#]+)=([^&#]*)/g, (_, key, val) => {\r\n    key = decodeURIComponent(key);\r\n    val = decodeURIComponent(val || '');\r\n    params[key] = params[key] ? [].concat(params[key], val) : val;\r\n  });\r\n  return params;\r\n}\r\n// 示例：'?key=1&key=2' → { key: ['1', '2'] }\r\n```\r\n\r\n**优点**：支持重复键转为数组\r\n**缺点**：正则复杂度高，需理解分组匹配\r\n\r\n\r\n\r\n**方案 3：URLSearchParams API（现代浏览器**）\r\n\r\n```javascript\r\nfunction parseUrlParams(url) {\r\n  const params = {};\r\n  const searchParams = new URL(url).searchParams;\r\n  searchParams.forEach((val, key) => {\r\n    params[key] = searchParams.getAll(key).length > 1 \r\n      ? searchParams.getAll(key) \r\n      : val;\r\n  });\r\n  return params;\r\n}\r\n// 示例：自动处理编码（如空格转为%20）\r\n```\r\n\r\n**优点**：原生 API 简洁，自动解码\r\n**缺点**：需兼容性处理（IE 不支持）"},{"title":"实现日期格式化 format 函数","answer":"**1. 原生拼接法（手动补零）**\r\n\r\n```javascript\r\nfunction formatDate(date, format = 'yyyy-MM-dd HH:mm:ss') {\r\n  const year = date.getFullYear();\r\n  const month = (date.getMonth() + 1).toString().padStart(2, '0');\r\n  const day = date.getDate().toString().padStart(2, '0');\r\n  const hours = date.getHours().toString().padStart(2, '0');\r\n  const minutes = date.getMinutes().toString().padStart(2, '0');\r\n  const seconds = date.getSeconds().toString().padStart(2, '0');\r\n  \r\n  return format\r\n    .replace('yyyy', year)\r\n    .replace('MM', month)\r\n    .replace('dd', day)\r\n    .replace('HH', hours)\r\n    .replace('mm', minutes)\r\n    .replace('ss', seconds);\r\n}\r\n\r\n// 使用示例\r\nconsole.log(formatDate(new Date(), 'yyyy/MM/dd')); // 输出 \"2023/09/28\"\r\n```\r\n\r\n**2. Intl.DateTimeFormat（本地化支持）**\r\n\r\n```JavaScript\r\nfunction formatDate(date, locale = 'zh-CN', options = {}) {\r\n  return new Intl.DateTimeFormat(locale, {\r\n    year: 'numeric',\r\n    month: '2-digit',\r\n    day: '2-digit',\r\n    hour: '2-digit',\r\n    minute: '2-digit',\r\n    second: '2-digit',\r\n    ...options\r\n  }).format(date);\r\n}\r\n\r\n// 使用示例\r\nconsole.log(formatDate(new Date())); // 输出 \"2023/09/28 14:30:45\"（中文环境）\r\nconsole.log(formatDate(new Date(), 'en-US')); // \"9/28/2023, 2:30:45 PM\"\r\n```\r\n\r\n**3. 正则替换法（灵活自定义）**\r\n\r\n```JavaScript\r\nfunction formatDate(date, format = 'yyyy-MM-dd') {\r\n  const map = {\r\n    'y+': date.getFullYear(),                // 年\r\n    'M+': date.getMonth() + 1,               // 月\r\n    'd+': date.getDate(),                    // 日\r\n    'H+': date.getHours(),                   // 时（24小时制）\r\n    'm+': date.getMinutes(),                 // 分\r\n    's+': date.getSeconds(),                 // 秒\r\n    'S': date.getMilliseconds()              // 毫秒\r\n  };\r\n\r\n  for (const [key, value] of Object.entries(map)) {\r\n    const regex = new RegExp(`(${key})`);\r\n    if (regex.test(format)) {\r\n      const str = value.toString().padStart(2, '0');\r\n      format = format.replace(regex, str);\r\n    }\r\n  }\r\n  return format;\r\n}\r\n\r\n// 使用示例\r\nconsole.log(formatDate(new Date(), 'yyyy年MM月dd日 HH时mm分')); \r\n// 输出 \"2023年09月28日 14时30分\"\r\n```"},{"title":"实现版本号排序","answer":"```javascript\r\nfunction sortVersionsEnhanced(versions) {\r\n  return versions.sort((a, b) => {\r\n    const splitPart = (part) => \r\n      part.split(/(\\d+)/) // 拆分数字和非数字部分\r\n          .filter(Boolean)\r\n          .map(s => isNaN(s) ? s : parseInt(s));\r\n\r\n    const aParts = splitPart(a);\r\n    const bParts = splitPart(b);\r\n\r\n    const maxLength = Math.max(aParts.length, bParts.length);\r\n    \r\n    for (let i = 0; i < maxLength; i++) {\r\n      const aVal = i < aParts.length ? aParts[i] : null;\r\n      const bVal = i < bParts.length ? bParts[i] : null;\r\n\r\n      if (aVal === bVal) continue;\r\n      \r\n      // 数字优先于非数字\r\n      if (typeof aVal === 'number' && typeof bVal !== 'number') return -1;\r\n      if (typeof bVal === 'number' && typeof aVal !== 'number') return 1;\r\n      \r\n      // 比较实际值\r\n      return (aVal < bVal) ? -1 : 1;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\n```"}]